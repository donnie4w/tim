#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class TimError:
  """
  Attributes:
   - errCode: 错误码
   - errMsg: 错误内容
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errCode', None, None, ), # 1
    (2, TType.STRING, 'errMsg', None, None, ), # 2
  )

  def __init__(self, errCode=None, errMsg=None,):
    self.errCode = errCode
    self.errMsg = errMsg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errCode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errMsg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimError')
    if self.errCode is not None:
      oprot.writeFieldBegin('errCode', TType.I32, 1)
      oprot.writeI32(self.errCode)
      oprot.writeFieldEnd()
    if self.errMsg is not None:
      oprot.writeFieldBegin('errMsg', TType.STRING, 2)
      oprot.writeString(self.errMsg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errCode)
    value = (value * 31) ^ hash(self.errMsg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimNode:
  """
  Attributes:
   - key: 键
   - value: 值
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimNode')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimAckBean:
  """
  Attributes:
   - id: id，返回所要回执协议的线程id
   - ackType: 类型，自定义 如：ping，message等
   - ackStatus: 状态，如成功，失败等
   - extraList: 附加信息
   - err: 错误信息
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'ackType', None, None, ), # 2
    (3, TType.STRING, 'ackStatus', None, None, ), # 3
    (4, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 4
    (5, TType.STRUCT, 'err', (TimError, TimError.thrift_spec), None, ), # 5
    (6, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, id=None, ackType=None, ackStatus=None, extraList=None, err=None, extraMap=None,):
    self.id = id
    self.ackType = ackType
    self.ackStatus = ackStatus
    self.extraList = extraList
    self.err = err
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ackType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ackStatus = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = TimNode()
            _elem5.read(iprot)
            self.extraList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.err = TimError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype7, _vtype8, _size6 ) = iprot.readMapBegin()
          for _i10 in xrange(_size6):
            _key11 = iprot.readString()
            _val12 = iprot.readString()
            self.extraMap[_key11] = _val12
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimAckBean')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.ackType is not None:
      oprot.writeFieldBegin('ackType', TType.STRING, 2)
      oprot.writeString(self.ackType)
      oprot.writeFieldEnd()
    if self.ackStatus is not None:
      oprot.writeFieldBegin('ackStatus', TType.STRING, 3)
      oprot.writeString(self.ackStatus)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter13 in self.extraList:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 5)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter14,viter15 in self.extraMap.items():
        oprot.writeString(kiter14)
        oprot.writeString(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.ackType)
    value = (value * 31) ^ hash(self.ackStatus)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.err)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimHBean:
  """
  Attributes:
   - chl: 渠道
   - platform: 平台
   - version: version 客户端协议版本
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'chl', None, None, ), # 1
    (2, TType.I32, 'platform', None, None, ), # 2
    (3, TType.I16, 'version', None, None, ), # 3
  )

  def __init__(self, chl=None, platform=None, version=None,):
    self.chl = chl
    self.platform = platform
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.chl = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.platform = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.version = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimHBean')
    if self.chl is not None:
      oprot.writeFieldBegin('chl', TType.I32, 1)
      oprot.writeI32(self.chl)
      oprot.writeFieldEnd()
    if self.platform is not None:
      oprot.writeFieldBegin('platform', TType.I32, 2)
      oprot.writeI32(self.platform)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I16, 3)
      oprot.writeI16(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.chl is None:
      raise TProtocol.TProtocolException(message='Required field chl is unset!')
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.chl)
    value = (value * 31) ^ hash(self.platform)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimParam:
  """
  Attributes:
   - timestamp: 服务器时间
   - version: 版本
   - lang: 语言
   - extraList: 附加信息
   - extraMap
   - interflow: 消息合流
   - tls: tls
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'timestamp', None, None, ), # 1
    (2, TType.I16, 'version', None, None, ), # 2
    (3, TType.STRING, 'lang', None, None, ), # 3
    (4, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'interflow', None, None, ), # 6
    (7, TType.STRING, 'tls', None, None, ), # 7
  )

  def __init__(self, timestamp=None, version=None, lang=None, extraList=None, extraMap=None, interflow=None, tls=None,):
    self.timestamp = timestamp
    self.version = version
    self.lang = lang
    self.extraList = extraList
    self.extraMap = extraMap
    self.interflow = interflow
    self.tls = tls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.version = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.lang = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = TimNode()
            _elem21.read(iprot)
            self.extraList.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype23, _vtype24, _size22 ) = iprot.readMapBegin()
          for _i26 in xrange(_size22):
            _key27 = iprot.readString()
            _val28 = iprot.readString()
            self.extraMap[_key27] = _val28
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.interflow = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.tls = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimParam')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 1)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I16, 2)
      oprot.writeI16(self.version)
      oprot.writeFieldEnd()
    if self.lang is not None:
      oprot.writeFieldBegin('lang', TType.STRING, 3)
      oprot.writeString(self.lang)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter29 in self.extraList:
        iter29.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter30,viter31 in self.extraMap.items():
        oprot.writeString(kiter30)
        oprot.writeString(viter31)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.interflow is not None:
      oprot.writeFieldBegin('interflow', TType.STRING, 6)
      oprot.writeString(self.interflow)
      oprot.writeFieldEnd()
    if self.tls is not None:
      oprot.writeFieldBegin('tls', TType.STRING, 7)
      oprot.writeString(self.tls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.lang)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    value = (value * 31) ^ hash(self.interflow)
    value = (value * 31) ^ hash(self.tls)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimTime:
  """
  Attributes:
   - timestamp: 时间戳    (毫秒)
   - formattime: 格式化时间
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'timestamp', None, None, ), # 1
    (2, TType.STRING, 'formattime', None, None, ), # 2
  )

  def __init__(self, timestamp=None, formattime=None,):
    self.timestamp = timestamp
    self.formattime = formattime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.formattime = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimTime')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 1)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.formattime is not None:
      oprot.writeFieldBegin('formattime', TType.STRING, 2)
      oprot.writeString(self.formattime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.formattime)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimArea:
  """
  Attributes:
   - country: 国家
   - province: 省
   - city: 市
   - extraList: 附加信息：如区，镇，乡等
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'country', None, None, ), # 1
    (2, TType.STRING, 'province', None, None, ), # 2
    (3, TType.STRING, 'city', None, None, ), # 3
    (4, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 5
  )

  def __init__(self, country=None, province=None, city=None, extraList=None, extraMap=None,):
    self.country = country
    self.province = province
    self.city = city
    self.extraList = extraList
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.country = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.province = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.city = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = TimNode()
            _elem37.read(iprot)
            self.extraList.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype39, _vtype40, _size38 ) = iprot.readMapBegin()
          for _i42 in xrange(_size38):
            _key43 = iprot.readString()
            _val44 = iprot.readString()
            self.extraMap[_key43] = _val44
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimArea')
    if self.country is not None:
      oprot.writeFieldBegin('country', TType.STRING, 1)
      oprot.writeString(self.country)
      oprot.writeFieldEnd()
    if self.province is not None:
      oprot.writeFieldBegin('province', TType.STRING, 2)
      oprot.writeString(self.province)
      oprot.writeFieldEnd()
    if self.city is not None:
      oprot.writeFieldBegin('city', TType.STRING, 3)
      oprot.writeString(self.city)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter45 in self.extraList:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter46,viter47 in self.extraMap.items():
        oprot.writeString(kiter46)
        oprot.writeString(viter47)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.country)
    value = (value * 31) ^ hash(self.province)
    value = (value * 31) ^ hash(self.city)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tid:
  """
  Attributes:
   - name: 登陆名   用户登录号，房间号等
   - domain: 域名 用于区分渠道等 appid，appsecret
   - resource: 系统 自行约定 如 ： 1IOS，2android，3H5，4WEB 等
   - type: normal，group
   - extraList: 附加信息：如传递客户端信息 iphone6，xiaomi，huawei等
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'domain', None, None, ), # 2
    (3, TType.STRING, 'resource', None, None, ), # 3
    (4, TType.STRING, 'type', None, None, ), # 4
    (5, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 5
    (6, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, name=None, domain=None, resource=None, type=None, extraList=None, extraMap=None,):
    self.name = name
    self.domain = domain
    self.resource = resource
    self.type = type
    self.extraList = extraList
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.domain = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.resource = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = TimNode()
            _elem53.read(iprot)
            self.extraList.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype55, _vtype56, _size54 ) = iprot.readMapBegin()
          for _i58 in xrange(_size54):
            _key59 = iprot.readString()
            _val60 = iprot.readString()
            self.extraMap[_key59] = _val60
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tid')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRING, 2)
      oprot.writeString(self.domain)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 3)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 4)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter61 in self.extraList:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter62,viter63 in self.extraMap.items():
        oprot.writeString(kiter62)
        oprot.writeString(viter63)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.domain)
    value = (value * 31) ^ hash(self.resource)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimUserBean:
  """
  Attributes:
   - tid: 用户bean
   - nickname: 昵称
   - remarkname: 备注名称
   - brithday: 生日     2000-01-01
   - gender: 性别  自行约定 如 ：  0不知，1男，2女
   - headurl: 头像地址 http://xxx.jpg
   - area: 地区
   - headbyte: 头像
   - photoBytes: 其他图片
   - extraList: 扩展字段
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRING, 'nickname', None, None, ), # 2
    (3, TType.STRING, 'remarkname', None, None, ), # 3
    (4, TType.STRING, 'brithday', None, None, ), # 4
    (5, TType.I16, 'gender', None, None, ), # 5
    (6, TType.STRING, 'headurl', None, None, ), # 6
    (7, TType.STRUCT, 'area', (TimArea, TimArea.thrift_spec), None, ), # 7
    (8, TType.STRING, 'headbyte', None, None, ), # 8
    (9, TType.LIST, 'photoBytes', (TType.STRING,None), None, ), # 9
    (10, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 10
    (11, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 11
  )

  def __init__(self, tid=None, nickname=None, remarkname=None, brithday=None, gender=None, headurl=None, area=None, headbyte=None, photoBytes=None, extraList=None, extraMap=None,):
    self.tid = tid
    self.nickname = nickname
    self.remarkname = remarkname
    self.brithday = brithday
    self.gender = gender
    self.headurl = headurl
    self.area = area
    self.headbyte = headbyte
    self.photoBytes = photoBytes
    self.extraList = extraList
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.nickname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.remarkname = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.brithday = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.gender = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.headurl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.area = TimArea()
          self.area.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.headbyte = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.photoBytes = []
          (_etype67, _size64) = iprot.readListBegin()
          for _i68 in xrange(_size64):
            _elem69 = iprot.readString()
            self.photoBytes.append(_elem69)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = TimNode()
            _elem75.read(iprot)
            self.extraList.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype77, _vtype78, _size76 ) = iprot.readMapBegin()
          for _i80 in xrange(_size76):
            _key81 = iprot.readString()
            _val82 = iprot.readString()
            self.extraMap[_key81] = _val82
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimUserBean')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.nickname is not None:
      oprot.writeFieldBegin('nickname', TType.STRING, 2)
      oprot.writeString(self.nickname)
      oprot.writeFieldEnd()
    if self.remarkname is not None:
      oprot.writeFieldBegin('remarkname', TType.STRING, 3)
      oprot.writeString(self.remarkname)
      oprot.writeFieldEnd()
    if self.brithday is not None:
      oprot.writeFieldBegin('brithday', TType.STRING, 4)
      oprot.writeString(self.brithday)
      oprot.writeFieldEnd()
    if self.gender is not None:
      oprot.writeFieldBegin('gender', TType.I16, 5)
      oprot.writeI16(self.gender)
      oprot.writeFieldEnd()
    if self.headurl is not None:
      oprot.writeFieldBegin('headurl', TType.STRING, 6)
      oprot.writeString(self.headurl)
      oprot.writeFieldEnd()
    if self.area is not None:
      oprot.writeFieldBegin('area', TType.STRUCT, 7)
      self.area.write(oprot)
      oprot.writeFieldEnd()
    if self.headbyte is not None:
      oprot.writeFieldBegin('headbyte', TType.STRING, 8)
      oprot.writeString(self.headbyte)
      oprot.writeFieldEnd()
    if self.photoBytes is not None:
      oprot.writeFieldBegin('photoBytes', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.photoBytes))
      for iter83 in self.photoBytes:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter84 in self.extraList:
        iter84.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter85,viter86 in self.extraMap.items():
        oprot.writeString(kiter85)
        oprot.writeString(viter86)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.nickname)
    value = (value * 31) ^ hash(self.remarkname)
    value = (value * 31) ^ hash(self.brithday)
    value = (value * 31) ^ hash(self.gender)
    value = (value * 31) ^ hash(self.headurl)
    value = (value * 31) ^ hash(self.area)
    value = (value * 31) ^ hash(self.headbyte)
    value = (value * 31) ^ hash(self.photoBytes)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimRoom:
  """
  Attributes:
   - tid: 房间Tid
   - founderTid: 创建人Tid
   - HostsTid: 主持人Tid
   - membersTid: memberTid
   - headurl: 头像地址 http://xxx.jpg
   - roomName: 房间名称
   - desc: 房间说明
   - createTime: 房间创建时间
   - extraList: 扩展字段
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'founderTid', (Tid, Tid.thrift_spec), None, ), # 2
    (3, TType.LIST, 'HostsTid', (TType.STRUCT,(Tid, Tid.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'membersTid', (TType.STRUCT,(Tid, Tid.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'headurl', None, None, ), # 5
    (6, TType.STRING, 'roomName', None, None, ), # 6
    (7, TType.STRING, 'desc', None, None, ), # 7
    (8, TType.STRUCT, 'createTime', (TimTime, TimTime.thrift_spec), None, ), # 8
    (9, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 10
  )

  def __init__(self, tid=None, founderTid=None, HostsTid=None, membersTid=None, headurl=None, roomName=None, desc=None, createTime=None, extraList=None, extraMap=None,):
    self.tid = tid
    self.founderTid = founderTid
    self.HostsTid = HostsTid
    self.membersTid = membersTid
    self.headurl = headurl
    self.roomName = roomName
    self.desc = desc
    self.createTime = createTime
    self.extraList = extraList
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.founderTid = Tid()
          self.founderTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.HostsTid = []
          (_etype90, _size87) = iprot.readListBegin()
          for _i91 in xrange(_size87):
            _elem92 = Tid()
            _elem92.read(iprot)
            self.HostsTid.append(_elem92)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.membersTid = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = Tid()
            _elem98.read(iprot)
            self.membersTid.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.headurl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.roomName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.desc = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.createTime = TimTime()
          self.createTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype102, _size99) = iprot.readListBegin()
          for _i103 in xrange(_size99):
            _elem104 = TimNode()
            _elem104.read(iprot)
            self.extraList.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin()
          for _i109 in xrange(_size105):
            _key110 = iprot.readString()
            _val111 = iprot.readString()
            self.extraMap[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimRoom')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.founderTid is not None:
      oprot.writeFieldBegin('founderTid', TType.STRUCT, 2)
      self.founderTid.write(oprot)
      oprot.writeFieldEnd()
    if self.HostsTid is not None:
      oprot.writeFieldBegin('HostsTid', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.HostsTid))
      for iter112 in self.HostsTid:
        iter112.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.membersTid is not None:
      oprot.writeFieldBegin('membersTid', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.membersTid))
      for iter113 in self.membersTid:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.headurl is not None:
      oprot.writeFieldBegin('headurl', TType.STRING, 5)
      oprot.writeString(self.headurl)
      oprot.writeFieldEnd()
    if self.roomName is not None:
      oprot.writeFieldBegin('roomName', TType.STRING, 6)
      oprot.writeString(self.roomName)
      oprot.writeFieldEnd()
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 7)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.STRUCT, 8)
      self.createTime.write(oprot)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter114 in self.extraList:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter115,viter116 in self.extraMap.items():
        oprot.writeString(kiter115)
        oprot.writeString(viter116)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.founderTid)
    value = (value * 31) ^ hash(self.HostsTid)
    value = (value * 31) ^ hash(self.membersTid)
    value = (value * 31) ^ hash(self.headurl)
    value = (value * 31) ^ hash(self.roomName)
    value = (value * 31) ^ hash(self.desc)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimPBean:
  """
  Attributes:
   - threadId: 标识
   - fromTid
   - toTid
   - status: subscribe：订阅其他用户的状态  probe：请求获取其他用户的状态  unavailable：不可用，离线（offline）状态
   - type: normal：类似于email，主要特点是不要求响应；
  chat：类似于qq里的好友即时聊天，主要特点是实时通讯；
  groupchat：类似于聊天室里的群聊；
  headline：用于发送alert和notification；
  error：如果发送message出错，发现错误的实体会用这个类别来通知发送者出错了；
   - priority: 优先权 0 。高优先级的resource能接受发送到bare JID的消息，低优先级的resource不能
   - show: chat：聊天中  away：暂时离开   xa：eXtend Away，长时间离开   dnd：勿打扰   online:在线   offline:离线
   - leaguerTid: 成员Tid   群聊时信息发送者Tid
   - extraList: 扩展字段
   - error: 错误码
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.STRUCT, 'fromTid', (Tid, Tid.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'toTid', (Tid, Tid.thrift_spec), None, ), # 3
    (4, TType.STRING, 'status', None, None, ), # 4
    (5, TType.STRING, 'type', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.STRING, 'show', None, None, ), # 7
    (8, TType.STRUCT, 'leaguerTid', (Tid, Tid.thrift_spec), None, ), # 8
    (9, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 9
    (10, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 10
    (11, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 11
  )

  def __init__(self, threadId=None, fromTid=None, toTid=None, status=None, type=None, priority=None, show=None, leaguerTid=None, extraList=None, error=None, extraMap=None,):
    self.threadId = threadId
    self.fromTid = fromTid
    self.toTid = toTid
    self.status = status
    self.type = type
    self.priority = priority
    self.show = show
    self.leaguerTid = leaguerTid
    self.extraList = extraList
    self.error = error
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fromTid = Tid()
          self.fromTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.toTid = Tid()
          self.toTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.status = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.show = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.leaguerTid = Tid()
          self.leaguerTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype120, _size117) = iprot.readListBegin()
          for _i121 in xrange(_size117):
            _elem122 = TimNode()
            _elem122.read(iprot)
            self.extraList.append(_elem122)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype124, _vtype125, _size123 ) = iprot.readMapBegin()
          for _i127 in xrange(_size123):
            _key128 = iprot.readString()
            _val129 = iprot.readString()
            self.extraMap[_key128] = _val129
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimPBean')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.fromTid is not None:
      oprot.writeFieldBegin('fromTid', TType.STRUCT, 2)
      self.fromTid.write(oprot)
      oprot.writeFieldEnd()
    if self.toTid is not None:
      oprot.writeFieldBegin('toTid', TType.STRUCT, 3)
      self.toTid.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRING, 4)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 5)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.show is not None:
      oprot.writeFieldBegin('show', TType.STRING, 7)
      oprot.writeString(self.show)
      oprot.writeFieldEnd()
    if self.leaguerTid is not None:
      oprot.writeFieldBegin('leaguerTid', TType.STRUCT, 8)
      self.leaguerTid.write(oprot)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter130 in self.extraList:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 10)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter131,viter132 in self.extraMap.items():
        oprot.writeString(kiter131)
        oprot.writeString(viter132)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.threadId is None:
      raise TProtocol.TProtocolException(message='Required field threadId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.fromTid)
    value = (value * 31) ^ hash(self.toTid)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.show)
    value = (value * 31) ^ hash(self.leaguerTid)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimMBean:
  """
  Attributes:
   - threadId: 线程id
   - mid: 消息id号
   - fromTid: 来源Tid
   - toTid: 目标Tid
   - body: 信息内容
   - type: normal：类似于email，主要特点是不要求响应；
  chat：类似于qq里的好友即时聊天，主要特点是实时通讯；
  groupchat：类似于聊天室里的群聊；
  headline：用于发送alert和notification；
  error：如果发送message出错，发现错误的实体会用这个类别来通知发送者出错了；
   - msgType: 消息类型  1 文字 2 图片 3 语音 4视频 5混合
   - offline: 是否离线信息
   - leaguerTid: 成员Tid   群聊时信息发送者Tid
   - extraList: 扩展字段
   - timestamp: 服务器发送信息时间戳(毫秒)
   - error: 错误码
   - extraMap
   - readstatus: 0未读  1已读
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.STRING, 'mid', None, None, ), # 2
    (3, TType.STRUCT, 'fromTid', (Tid, Tid.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'toTid', (Tid, Tid.thrift_spec), None, ), # 4
    (5, TType.STRING, 'body', None, None, ), # 5
    (6, TType.STRING, 'type', None, None, ), # 6
    (7, TType.I16, 'msgType', None, None, ), # 7
    (8, TType.STRUCT, 'offline', (TimTime, TimTime.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'leaguerTid', (Tid, Tid.thrift_spec), None, ), # 9
    (10, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 10
    (11, TType.STRING, 'timestamp', None, None, ), # 11
    (12, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 12
    (13, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 13
    (14, TType.I16, 'readstatus', None, None, ), # 14
  )

  def __init__(self, threadId=None, mid=None, fromTid=None, toTid=None, body=None, type=None, msgType=None, offline=None, leaguerTid=None, extraList=None, timestamp=None, error=None, extraMap=None, readstatus=None,):
    self.threadId = threadId
    self.mid = mid
    self.fromTid = fromTid
    self.toTid = toTid
    self.body = body
    self.type = type
    self.msgType = msgType
    self.offline = offline
    self.leaguerTid = leaguerTid
    self.extraList = extraList
    self.timestamp = timestamp
    self.error = error
    self.extraMap = extraMap
    self.readstatus = readstatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mid = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.fromTid = Tid()
          self.fromTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.toTid = Tid()
          self.toTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.body = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.msgType = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.offline = TimTime()
          self.offline.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.leaguerTid = Tid()
          self.leaguerTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = TimNode()
            _elem138.read(iprot)
            self.extraList.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype140, _vtype141, _size139 ) = iprot.readMapBegin()
          for _i143 in xrange(_size139):
            _key144 = iprot.readString()
            _val145 = iprot.readString()
            self.extraMap[_key144] = _val145
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.readstatus = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimMBean')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.mid is not None:
      oprot.writeFieldBegin('mid', TType.STRING, 2)
      oprot.writeString(self.mid)
      oprot.writeFieldEnd()
    if self.fromTid is not None:
      oprot.writeFieldBegin('fromTid', TType.STRUCT, 3)
      self.fromTid.write(oprot)
      oprot.writeFieldEnd()
    if self.toTid is not None:
      oprot.writeFieldBegin('toTid', TType.STRUCT, 4)
      self.toTid.write(oprot)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRING, 5)
      oprot.writeString(self.body)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 6)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.msgType is not None:
      oprot.writeFieldBegin('msgType', TType.I16, 7)
      oprot.writeI16(self.msgType)
      oprot.writeFieldEnd()
    if self.offline is not None:
      oprot.writeFieldBegin('offline', TType.STRUCT, 8)
      self.offline.write(oprot)
      oprot.writeFieldEnd()
    if self.leaguerTid is not None:
      oprot.writeFieldBegin('leaguerTid', TType.STRUCT, 9)
      self.leaguerTid.write(oprot)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter146 in self.extraList:
        iter146.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 11)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 12)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 13)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter147,viter148 in self.extraMap.items():
        oprot.writeString(kiter147)
        oprot.writeString(viter148)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.readstatus is not None:
      oprot.writeFieldBegin('readstatus', TType.I16, 14)
      oprot.writeI16(self.readstatus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.threadId is None:
      raise TProtocol.TProtocolException(message='Required field threadId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.mid)
    value = (value * 31) ^ hash(self.fromTid)
    value = (value * 31) ^ hash(self.toTid)
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.msgType)
    value = (value * 31) ^ hash(self.offline)
    value = (value * 31) ^ hash(self.leaguerTid)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.extraMap)
    value = (value * 31) ^ hash(self.readstatus)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimIqBean:
  """
  Attributes:
   - threadId: 线程id
   - fromTid
   - toTid
   - type: Get :获取当前域值。类似于http get方法
  Set :设置或替换get查询的值。类似于http put方法。
  Result :说明成功的响应了先前的查询。类似于http状态码200。
  Error: 查询和响应中出现的错误。
   - extraList: 扩展字段
   - error: 错误码
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.STRUCT, 'fromTid', (Tid, Tid.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'toTid', (Tid, Tid.thrift_spec), None, ), # 3
    (4, TType.STRING, 'type', None, None, ), # 4
    (5, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 5
    (6, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 6
    (7, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 7
  )

  def __init__(self, threadId=None, fromTid=None, toTid=None, type=None, extraList=None, error=None, extraMap=None,):
    self.threadId = threadId
    self.fromTid = fromTid
    self.toTid = toTid
    self.type = type
    self.extraList = extraList
    self.error = error
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fromTid = Tid()
          self.fromTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.toTid = Tid()
          self.toTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = TimNode()
            _elem154.read(iprot)
            self.extraList.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype156, _vtype157, _size155 ) = iprot.readMapBegin()
          for _i159 in xrange(_size155):
            _key160 = iprot.readString()
            _val161 = iprot.readString()
            self.extraMap[_key160] = _val161
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimIqBean')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.fromTid is not None:
      oprot.writeFieldBegin('fromTid', TType.STRUCT, 2)
      self.fromTid.write(oprot)
      oprot.writeFieldEnd()
    if self.toTid is not None:
      oprot.writeFieldBegin('toTid', TType.STRUCT, 3)
      self.toTid.write(oprot)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 4)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter162 in self.extraList:
        iter162.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 6)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter163,viter164 in self.extraMap.items():
        oprot.writeString(kiter163)
        oprot.writeString(viter164)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.threadId is None:
      raise TProtocol.TProtocolException(message='Required field threadId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.fromTid)
    value = (value * 31) ^ hash(self.toTid)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimRoster:
  """
  Attributes:
   - subscription: none表示用户和contact之前没有任何的关系（虽然在server的buddy list中存在）
  to表示用户能看到contact的presence，但是contact看不到用户的Presence
  from和to的含义相反，指用户看不到contact的presence，但是contact可以看到
  both表示相关之间都能看到对方的presence
   - tid
   - name: 用户名
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'subscription', None, None, ), # 1
    (2, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, subscription=None, tid=None, name=None, extraMap=None,):
    self.subscription = subscription
    self.tid = tid
    self.name = name
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.subscription = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype166, _vtype167, _size165 ) = iprot.readMapBegin()
          for _i169 in xrange(_size165):
            _key170 = iprot.readString()
            _val171 = iprot.readString()
            self.extraMap[_key170] = _val171
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimRoster')
    if self.subscription is not None:
      oprot.writeFieldBegin('subscription', TType.STRING, 1)
      oprot.writeString(self.subscription)
      oprot.writeFieldEnd()
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 2)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter172,viter173 in self.extraMap.items():
        oprot.writeString(kiter172)
        oprot.writeString(viter173)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.subscription is None:
      raise TProtocol.TProtocolException(message='Required field subscription is unset!')
    if self.tid is None:
      raise TProtocol.TProtocolException(message='Required field tid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.subscription)
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimRemoteUserBean:
  """
  Attributes:
   - error: 错误码
   - ub: 远程用户信息
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ub', (TimUserBean, TimUserBean.thrift_spec), None, ), # 2
    (3, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, error=None, ub=None, extraMap=None,):
    self.error = error
    self.ub = ub
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ub = TimUserBean()
          self.ub.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype175, _vtype176, _size174 ) = iprot.readMapBegin()
          for _i178 in xrange(_size174):
            _key179 = iprot.readString()
            _val180 = iprot.readString()
            self.extraMap[_key179] = _val180
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimRemoteUserBean')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.ub is not None:
      oprot.writeFieldBegin('ub', TType.STRUCT, 2)
      self.ub.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter181,viter182 in self.extraMap.items():
        oprot.writeString(kiter181)
        oprot.writeString(viter182)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.ub)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimRemoteRoom:
  """
  Attributes:
   - error: 错误码
   - room: 远程房间信息
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'room', (TimRoom, TimRoom.thrift_spec), None, ), # 2
    (3, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, error=None, room=None, extraMap=None,):
    self.error = error
    self.room = room
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.room = TimRoom()
          self.room.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype184, _vtype185, _size183 ) = iprot.readMapBegin()
          for _i187 in xrange(_size183):
            _key188 = iprot.readString()
            _val189 = iprot.readString()
            self.extraMap[_key188] = _val189
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimRemoteRoom')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.room is not None:
      oprot.writeFieldBegin('room', TType.STRUCT, 2)
      self.room.write(oprot)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter190,viter191 in self.extraMap.items():
        oprot.writeString(kiter190)
        oprot.writeString(viter191)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.room)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimResponseBean:
  """
  Attributes:
   - threadId
   - error: 错误码
   - extraList: 附加信息
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.STRUCT, 'error', (TimError, TimError.thrift_spec), None, ), # 2
    (3, TType.LIST, 'extraList', (TType.STRUCT,(TimNode, TimNode.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, threadId=None, error=None, extraList=None, extraMap=None,):
    self.threadId = threadId
    self.error = error
    self.extraList = extraList
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.error = TimError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.extraList = []
          (_etype195, _size192) = iprot.readListBegin()
          for _i196 in xrange(_size192):
            _elem197 = TimNode()
            _elem197.read(iprot)
            self.extraList.append(_elem197)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype199, _vtype200, _size198 ) = iprot.readMapBegin()
          for _i202 in xrange(_size198):
            _key203 = iprot.readString()
            _val204 = iprot.readString()
            self.extraMap[_key203] = _val204
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimResponseBean')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 2)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    if self.extraList is not None:
      oprot.writeFieldBegin('extraList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.extraList))
      for iter205 in self.extraList:
        iter205.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter206,viter207 in self.extraMap.items():
        oprot.writeString(kiter206)
        oprot.writeString(viter207)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.error)
    value = (value * 31) ^ hash(self.extraList)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimSock5Bean:
  """
  Attributes:
   - fromTid
   - toTid
   - addr: ip地址
   - port: 端口
   - transport: 传输类型  1:tcp 2:udp
   - pubId: 发布id 通过发布id 可以连接两个发布id相同的用户
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fromTid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'toTid', (Tid, Tid.thrift_spec), None, ), # 2
    (3, TType.STRING, 'addr', None, None, ), # 3
    (4, TType.I32, 'port', None, None, ), # 4
    (5, TType.I16, 'transport', None, None, ), # 5
    (6, TType.STRING, 'pubId', None, None, ), # 6
    (7, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 7
  )

  def __init__(self, fromTid=None, toTid=None, addr=None, port=None, transport=None, pubId=None, extraMap=None,):
    self.fromTid = fromTid
    self.toTid = toTid
    self.addr = addr
    self.port = port
    self.transport = transport
    self.pubId = pubId
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fromTid = Tid()
          self.fromTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.toTid = Tid()
          self.toTid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.addr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.transport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.pubId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype209, _vtype210, _size208 ) = iprot.readMapBegin()
          for _i212 in xrange(_size208):
            _key213 = iprot.readString()
            _val214 = iprot.readString()
            self.extraMap[_key213] = _val214
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimSock5Bean')
    if self.fromTid is not None:
      oprot.writeFieldBegin('fromTid', TType.STRUCT, 1)
      self.fromTid.write(oprot)
      oprot.writeFieldEnd()
    if self.toTid is not None:
      oprot.writeFieldBegin('toTid', TType.STRUCT, 2)
      self.toTid.write(oprot)
      oprot.writeFieldEnd()
    if self.addr is not None:
      oprot.writeFieldBegin('addr', TType.STRING, 3)
      oprot.writeString(self.addr)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 4)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.transport is not None:
      oprot.writeFieldBegin('transport', TType.I16, 5)
      oprot.writeI16(self.transport)
      oprot.writeFieldEnd()
    if self.pubId is not None:
      oprot.writeFieldBegin('pubId', TType.STRING, 6)
      oprot.writeString(self.pubId)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter215,viter216 in self.extraMap.items():
        oprot.writeString(kiter215)
        oprot.writeString(viter216)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fromTid is None:
      raise TProtocol.TProtocolException(message='Required field fromTid is unset!')
    if self.toTid is None:
      raise TProtocol.TProtocolException(message='Required field toTid is unset!')
    if self.addr is None:
      raise TProtocol.TProtocolException(message='Required field addr is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    if self.transport is None:
      raise TProtocol.TProtocolException(message='Required field transport is unset!')
    if self.pubId is None:
      raise TProtocol.TProtocolException(message='Required field pubId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fromTid)
    value = (value * 31) ^ hash(self.toTid)
    value = (value * 31) ^ hash(self.addr)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.transport)
    value = (value * 31) ^ hash(self.pubId)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimSock5Bytes:
  """
  Attributes:
   - pubId: 发布id
   - index: 序号数据块
   - bytes: 数据块
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pubId', None, None, ), # 1
    (2, TType.I32, 'index', None, None, ), # 2
    (3, TType.LIST, 'bytes', (TType.STRING,None), None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, pubId=None, index=None, bytes=None, extraMap=None,):
    self.pubId = pubId
    self.index = index
    self.bytes = bytes
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pubId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.index = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.bytes = []
          (_etype220, _size217) = iprot.readListBegin()
          for _i221 in xrange(_size217):
            _elem222 = iprot.readString()
            self.bytes.append(_elem222)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype224, _vtype225, _size223 ) = iprot.readMapBegin()
          for _i227 in xrange(_size223):
            _key228 = iprot.readString()
            _val229 = iprot.readString()
            self.extraMap[_key228] = _val229
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimSock5Bytes')
    if self.pubId is not None:
      oprot.writeFieldBegin('pubId', TType.STRING, 1)
      oprot.writeString(self.pubId)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 2)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.bytes))
      for iter230 in self.bytes:
        oprot.writeString(iter230)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter231,viter232 in self.extraMap.items():
        oprot.writeString(kiter231)
        oprot.writeString(viter232)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pubId is None:
      raise TProtocol.TProtocolException(message='Required field pubId is unset!')
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.bytes is None:
      raise TProtocol.TProtocolException(message='Required field bytes is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pubId)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.bytes)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimPage:
  """
  Attributes:
   - fromTimeStamp: 时间上
   - toTimeStamp: 时间下
   - limitCount: 条数
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fromTimeStamp', None, None, ), # 1
    (2, TType.STRING, 'toTimeStamp', None, None, ), # 2
    (3, TType.I32, 'limitCount', None, None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, fromTimeStamp=None, toTimeStamp=None, limitCount=None, extraMap=None,):
    self.fromTimeStamp = fromTimeStamp
    self.toTimeStamp = toTimeStamp
    self.limitCount = limitCount
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fromTimeStamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.toTimeStamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limitCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype234, _vtype235, _size233 ) = iprot.readMapBegin()
          for _i237 in xrange(_size233):
            _key238 = iprot.readString()
            _val239 = iprot.readString()
            self.extraMap[_key238] = _val239
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimPage')
    if self.fromTimeStamp is not None:
      oprot.writeFieldBegin('fromTimeStamp', TType.STRING, 1)
      oprot.writeString(self.fromTimeStamp)
      oprot.writeFieldEnd()
    if self.toTimeStamp is not None:
      oprot.writeFieldBegin('toTimeStamp', TType.STRING, 2)
      oprot.writeString(self.toTimeStamp)
      oprot.writeFieldEnd()
    if self.limitCount is not None:
      oprot.writeFieldBegin('limitCount', TType.I32, 3)
      oprot.writeI32(self.limitCount)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter240,viter241 in self.extraMap.items():
        oprot.writeString(kiter240)
        oprot.writeString(viter241)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fromTimeStamp)
    value = (value * 31) ^ hash(self.toTimeStamp)
    value = (value * 31) ^ hash(self.limitCount)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimMessageIq:
  """
  Attributes:
   - tidlist: tid集合
   - timPage: 分页
   - midlist: mid集合
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tidlist', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'timPage', (TimPage, TimPage.thrift_spec), None, ), # 2
    (3, TType.LIST, 'midlist', (TType.STRING,None), None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, tidlist=None, timPage=None, midlist=None, extraMap=None,):
    self.tidlist = tidlist
    self.timPage = timPage
    self.midlist = midlist
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tidlist = []
          (_etype245, _size242) = iprot.readListBegin()
          for _i246 in xrange(_size242):
            _elem247 = iprot.readString()
            self.tidlist.append(_elem247)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.timPage = TimPage()
          self.timPage.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.midlist = []
          (_etype251, _size248) = iprot.readListBegin()
          for _i252 in xrange(_size248):
            _elem253 = iprot.readString()
            self.midlist.append(_elem253)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype255, _vtype256, _size254 ) = iprot.readMapBegin()
          for _i258 in xrange(_size254):
            _key259 = iprot.readString()
            _val260 = iprot.readString()
            self.extraMap[_key259] = _val260
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimMessageIq')
    if self.tidlist is not None:
      oprot.writeFieldBegin('tidlist', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tidlist))
      for iter261 in self.tidlist:
        oprot.writeString(iter261)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timPage is not None:
      oprot.writeFieldBegin('timPage', TType.STRUCT, 2)
      self.timPage.write(oprot)
      oprot.writeFieldEnd()
    if self.midlist is not None:
      oprot.writeFieldBegin('midlist', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.midlist))
      for iter262 in self.midlist:
        oprot.writeString(iter262)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter263,viter264 in self.extraMap.items():
        oprot.writeString(kiter263)
        oprot.writeString(viter264)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tidlist)
    value = (value * 31) ^ hash(self.timPage)
    value = (value * 31) ^ hash(self.midlist)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimAuth:
  """
  Attributes:
   - domain: 域名
   - username: 用户名
   - pwd: 密码
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domain', None, None, ), # 1
    (2, TType.STRING, 'username', None, None, ), # 2
    (3, TType.STRING, 'pwd', None, None, ), # 3
  )

  def __init__(self, domain=None, username=None, pwd=None,):
    self.domain = domain
    self.username = username
    self.pwd = pwd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domain = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimAuth')
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRING, 1)
      oprot.writeString(self.domain)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 2)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.pwd is not None:
      oprot.writeFieldBegin('pwd', TType.STRING, 3)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domain)
    value = (value * 31) ^ hash(self.username)
    value = (value * 31) ^ hash(self.pwd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimMBeanList:
  """
  Attributes:
   - threadId
   - timMBeanList: 信息列表
   - reqType: 类型
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.LIST, 'timMBeanList', (TType.STRUCT,(TimMBean, TimMBean.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'reqType', None, None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, threadId=None, timMBeanList=None, reqType=None, extraMap=None,):
    self.threadId = threadId
    self.timMBeanList = timMBeanList
    self.reqType = reqType
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.timMBeanList = []
          (_etype268, _size265) = iprot.readListBegin()
          for _i269 in xrange(_size265):
            _elem270 = TimMBean()
            _elem270.read(iprot)
            self.timMBeanList.append(_elem270)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.reqType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype272, _vtype273, _size271 ) = iprot.readMapBegin()
          for _i275 in xrange(_size271):
            _key276 = iprot.readString()
            _val277 = iprot.readString()
            self.extraMap[_key276] = _val277
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimMBeanList')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.timMBeanList is not None:
      oprot.writeFieldBegin('timMBeanList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.timMBeanList))
      for iter278 in self.timMBeanList:
        iter278.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.reqType is not None:
      oprot.writeFieldBegin('reqType', TType.STRING, 3)
      oprot.writeString(self.reqType)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter279,viter280 in self.extraMap.items():
        oprot.writeString(kiter279)
        oprot.writeString(viter280)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.threadId is None:
      raise TProtocol.TProtocolException(message='Required field threadId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.timMBeanList)
    value = (value * 31) ^ hash(self.reqType)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimPBeanList:
  """
  Attributes:
   - threadId
   - timPBeanList: 状态信息列表
   - reqType: 类型
   - extraMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.LIST, 'timPBeanList', (TType.STRUCT,(TimPBean, TimPBean.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'reqType', None, None, ), # 3
    (4, TType.MAP, 'extraMap', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, threadId=None, timPBeanList=None, reqType=None, extraMap=None,):
    self.threadId = threadId
    self.timPBeanList = timPBeanList
    self.reqType = reqType
    self.extraMap = extraMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.timPBeanList = []
          (_etype284, _size281) = iprot.readListBegin()
          for _i285 in xrange(_size281):
            _elem286 = TimPBean()
            _elem286.read(iprot)
            self.timPBeanList.append(_elem286)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.reqType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extraMap = {}
          (_ktype288, _vtype289, _size287 ) = iprot.readMapBegin()
          for _i291 in xrange(_size287):
            _key292 = iprot.readString()
            _val293 = iprot.readString()
            self.extraMap[_key292] = _val293
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimPBeanList')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.timPBeanList is not None:
      oprot.writeFieldBegin('timPBeanList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.timPBeanList))
      for iter294 in self.timPBeanList:
        iter294.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.reqType is not None:
      oprot.writeFieldBegin('reqType', TType.STRING, 3)
      oprot.writeString(self.reqType)
      oprot.writeFieldEnd()
    if self.extraMap is not None:
      oprot.writeFieldBegin('extraMap', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extraMap))
      for kiter295,viter296 in self.extraMap.items():
        oprot.writeString(kiter295)
        oprot.writeString(viter296)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.threadId is None:
      raise TProtocol.TProtocolException(message='Required field threadId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.timPBeanList)
    value = (value * 31) ^ hash(self.reqType)
    value = (value * 31) ^ hash(self.extraMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimPropertyBean:
  """
  Attributes:
   - threadId
   - interflow: 消息合流
   - tls: tls
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
    (2, TType.STRING, 'interflow', None, None, ), # 2
    (3, TType.STRING, 'tls', None, None, ), # 3
  )

  def __init__(self, threadId=None, interflow=None, tls=None,):
    self.threadId = threadId
    self.interflow = interflow
    self.tls = tls

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.interflow = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tls = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimPropertyBean')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    if self.interflow is not None:
      oprot.writeFieldBegin('interflow', TType.STRING, 2)
      oprot.writeString(self.interflow)
      oprot.writeFieldEnd()
    if self.tls is not None:
      oprot.writeFieldBegin('tls', TType.STRING, 3)
      oprot.writeString(self.tls)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    value = (value * 31) ^ hash(self.interflow)
    value = (value * 31) ^ hash(self.tls)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
