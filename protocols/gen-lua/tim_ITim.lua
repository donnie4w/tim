--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'tim_ttypes'

ITimClient = __TObject.new(__TClient, {
  __type = 'ITimClient'
})

function ITimClient:timStream(param)
  self:send_timStream(param)
  end

function ITimClient:send_timStream(param)
  self.oprot:writeMessageBegin('timStream', TMessageType.ONEWAY, self._seqid)
  local args = timStream_args:new{}
  args.param = param
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timStarttls()
  self:send_timStarttls()
  end

function ITimClient:send_timStarttls()
  self.oprot:writeMessageBegin('timStarttls', TMessageType.ONEWAY, self._seqid)
  local args = timStarttls_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timLogin(tid, pwd)
  self:send_timLogin(tid, pwd)
  end

function ITimClient:send_timLogin(tid, pwd)
  self.oprot:writeMessageBegin('timLogin', TMessageType.ONEWAY, self._seqid)
  local args = timLogin_args:new{}
  args.tid = tid
  args.pwd = pwd
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timAck(ab)
  self:send_timAck(ab)
  end

function ITimClient:send_timAck(ab)
  self.oprot:writeMessageBegin('timAck', TMessageType.ONEWAY, self._seqid)
  local args = timAck_args:new{}
  args.ab = ab
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timPresence(pbean)
  self:send_timPresence(pbean)
  end

function ITimClient:send_timPresence(pbean)
  self.oprot:writeMessageBegin('timPresence', TMessageType.ONEWAY, self._seqid)
  local args = timPresence_args:new{}
  args.pbean = pbean
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timMessage(mbean)
  self:send_timMessage(mbean)
  end

function ITimClient:send_timMessage(mbean)
  self.oprot:writeMessageBegin('timMessage', TMessageType.ONEWAY, self._seqid)
  local args = timMessage_args:new{}
  args.mbean = mbean
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timPing(threadId)
  self:send_timPing(threadId)
  end

function ITimClient:send_timPing(threadId)
  self.oprot:writeMessageBegin('timPing', TMessageType.ONEWAY, self._seqid)
  local args = timPing_args:new{}
  args.threadId = threadId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timError(e)
  self:send_timError(e)
  end

function ITimClient:send_timError(e)
  self.oprot:writeMessageBegin('timError', TMessageType.ONEWAY, self._seqid)
  local args = timError_args:new{}
  args.e = e
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timLogout()
  self:send_timLogout()
  end

function ITimClient:send_timLogout()
  self.oprot:writeMessageBegin('timLogout', TMessageType.ONEWAY, self._seqid)
  local args = timLogout_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timRegist(tid, auth)
  self:send_timRegist(tid, auth)
  end

function ITimClient:send_timRegist(tid, auth)
  self.oprot:writeMessageBegin('timRegist', TMessageType.ONEWAY, self._seqid)
  local args = timRegist_args:new{}
  args.tid = tid
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timRoser(roster)
  self:send_timRoser(roster)
  end

function ITimClient:send_timRoser(roster)
  self.oprot:writeMessageBegin('timRoser', TMessageType.ONEWAY, self._seqid)
  local args = timRoser_args:new{}
  args.roster = roster
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timMessageList(mbeanList)
  self:send_timMessageList(mbeanList)
  end

function ITimClient:send_timMessageList(mbeanList)
  self.oprot:writeMessageBegin('timMessageList', TMessageType.ONEWAY, self._seqid)
  local args = timMessageList_args:new{}
  args.mbeanList = mbeanList
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timPresenceList(pbeanList)
  self:send_timPresenceList(pbeanList)
  end

function ITimClient:send_timPresenceList(pbeanList)
  self.oprot:writeMessageBegin('timPresenceList', TMessageType.ONEWAY, self._seqid)
  local args = timPresenceList_args:new{}
  args.pbeanList = pbeanList
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timMessageIq(timMsgIq, iqType)
  self:send_timMessageIq(timMsgIq, iqType)
  end

function ITimClient:send_timMessageIq(timMsgIq, iqType)
  self.oprot:writeMessageBegin('timMessageIq', TMessageType.ONEWAY, self._seqid)
  local args = timMessageIq_args:new{}
  args.timMsgIq = timMsgIq
  args.iqType = iqType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timMessageResult(mbean)
  self:send_timMessageResult(mbean)
  end

function ITimClient:send_timMessageResult(mbean)
  self.oprot:writeMessageBegin('timMessageResult', TMessageType.ONEWAY, self._seqid)
  local args = timMessageResult_args:new{}
  args.mbean = mbean
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timProperty(tpb)
  self:send_timProperty(tpb)
  end

function ITimClient:send_timProperty(tpb)
  self.oprot:writeMessageBegin('timProperty', TMessageType.ONEWAY, self._seqid)
  local args = timProperty_args:new{}
  args.tpb = tpb
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:timRemoteUserAuth(tid, pwd, auth)
  self:send_timRemoteUserAuth(tid, pwd, auth)
  return self:recv_timRemoteUserAuth(tid, pwd, auth)
end

function ITimClient:send_timRemoteUserAuth(tid, pwd, auth)
  self.oprot:writeMessageBegin('timRemoteUserAuth', TMessageType.CALL, self._seqid)
  local args = timRemoteUserAuth_args:new{}
  args.tid = tid
  args.pwd = pwd
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timRemoteUserAuth(tid, pwd, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timRemoteUserAuth_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timRemoteUserGet(tid, auth)
  self:send_timRemoteUserGet(tid, auth)
  return self:recv_timRemoteUserGet(tid, auth)
end

function ITimClient:send_timRemoteUserGet(tid, auth)
  self.oprot:writeMessageBegin('timRemoteUserGet', TMessageType.CALL, self._seqid)
  local args = timRemoteUserGet_args:new{}
  args.tid = tid
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timRemoteUserGet(tid, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timRemoteUserGet_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timRemoteUserEdit(tid, ub, auth)
  self:send_timRemoteUserEdit(tid, ub, auth)
  return self:recv_timRemoteUserEdit(tid, ub, auth)
end

function ITimClient:send_timRemoteUserEdit(tid, ub, auth)
  self.oprot:writeMessageBegin('timRemoteUserEdit', TMessageType.CALL, self._seqid)
  local args = timRemoteUserEdit_args:new{}
  args.tid = tid
  args.ub = ub
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timRemoteUserEdit(tid, ub, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timRemoteUserEdit_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timResponsePresence(pbean, auth)
  self:send_timResponsePresence(pbean, auth)
  return self:recv_timResponsePresence(pbean, auth)
end

function ITimClient:send_timResponsePresence(pbean, auth)
  self.oprot:writeMessageBegin('timResponsePresence', TMessageType.CALL, self._seqid)
  local args = timResponsePresence_args:new{}
  args.pbean = pbean
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timResponsePresence(pbean, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timResponsePresence_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timResponseMessage(mbean, auth)
  self:send_timResponseMessage(mbean, auth)
  return self:recv_timResponseMessage(mbean, auth)
end

function ITimClient:send_timResponseMessage(mbean, auth)
  self.oprot:writeMessageBegin('timResponseMessage', TMessageType.CALL, self._seqid)
  local args = timResponseMessage_args:new{}
  args.mbean = mbean
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timResponseMessage(mbean, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timResponseMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timResponseMessageIq(timMsgIq, iqType, auth)
  self:send_timResponseMessageIq(timMsgIq, iqType, auth)
  return self:recv_timResponseMessageIq(timMsgIq, iqType, auth)
end

function ITimClient:send_timResponseMessageIq(timMsgIq, iqType, auth)
  self.oprot:writeMessageBegin('timResponseMessageIq', TMessageType.CALL, self._seqid)
  local args = timResponseMessageIq_args:new{}
  args.timMsgIq = timMsgIq
  args.iqType = iqType
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timResponseMessageIq(timMsgIq, iqType, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timResponseMessageIq_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timResponsePresenceList(pbeanList, auth)
  self:send_timResponsePresenceList(pbeanList, auth)
  return self:recv_timResponsePresenceList(pbeanList, auth)
end

function ITimClient:send_timResponsePresenceList(pbeanList, auth)
  self.oprot:writeMessageBegin('timResponsePresenceList', TMessageType.CALL, self._seqid)
  local args = timResponsePresenceList_args:new{}
  args.pbeanList = pbeanList
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timResponsePresenceList(pbeanList, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timResponsePresenceList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ITimClient:timResponseMessageList(mbeanList, auth)
  self:send_timResponseMessageList(mbeanList, auth)
  return self:recv_timResponseMessageList(mbeanList, auth)
end

function ITimClient:send_timResponseMessageList(mbeanList, auth)
  self.oprot:writeMessageBegin('timResponseMessageList', TMessageType.CALL, self._seqid)
  local args = timResponseMessageList_args:new{}
  args.mbeanList = mbeanList
  args.auth = auth
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ITimClient:recv_timResponseMessageList(mbeanList, auth)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = timResponseMessageList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end
ITimIface = __TObject:new{
  __type = 'ITimIface'
}


ITimProcessor = __TObject.new(__TProcessor
, {
 __type = 'ITimProcessor'
})

function ITimProcessor:process(iprot, oprot, server_ctx)
  local name, mtype, seqid = iprot:readMessageBegin()
  local func_name = 'process_' .. name
  if not self[func_name] or ttype(self[func_name]) ~= 'function' then
    if oprot ~= nil then
      iprot:skip(TType.STRUCT)
      iprot:readMessageEnd()
      x = TApplicationException:new{
        errorCode = TApplicationException.UNKNOWN_METHOD
      }
      oprot:writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x:write(oprot)
      oprot:writeMessageEnd()
      oprot.trans:flush()
    end
    return false, 'Unknown function '..name
  else
    return self[func_name](self, seqid, iprot, oprot, server_ctx)
  end
end

function ITimProcessor:process_timStream(seqid, iprot, oprot, server_ctx)
  local args = timStream_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timStream, self.handler, args.param)
  return status, res
end

function ITimProcessor:process_timStarttls(seqid, iprot, oprot, server_ctx)
  local args = timStarttls_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timStarttls, self.handler)
  return status, res
end

function ITimProcessor:process_timLogin(seqid, iprot, oprot, server_ctx)
  local args = timLogin_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timLogin, self.handler, args.tid, args.pwd)
  return status, res
end

function ITimProcessor:process_timAck(seqid, iprot, oprot, server_ctx)
  local args = timAck_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timAck, self.handler, args.ab)
  return status, res
end

function ITimProcessor:process_timPresence(seqid, iprot, oprot, server_ctx)
  local args = timPresence_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timPresence, self.handler, args.pbean)
  return status, res
end

function ITimProcessor:process_timMessage(seqid, iprot, oprot, server_ctx)
  local args = timMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timMessage, self.handler, args.mbean)
  return status, res
end

function ITimProcessor:process_timPing(seqid, iprot, oprot, server_ctx)
  local args = timPing_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timPing, self.handler, args.threadId)
  return status, res
end

function ITimProcessor:process_timError(seqid, iprot, oprot, server_ctx)
  local args = timError_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timError, self.handler, args.e)
  return status, res
end

function ITimProcessor:process_timLogout(seqid, iprot, oprot, server_ctx)
  local args = timLogout_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timLogout, self.handler)
  return status, res
end

function ITimProcessor:process_timRegist(seqid, iprot, oprot, server_ctx)
  local args = timRegist_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timRegist, self.handler, args.tid, args.auth)
  return status, res
end

function ITimProcessor:process_timRoser(seqid, iprot, oprot, server_ctx)
  local args = timRoser_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timRoser, self.handler, args.roster)
  return status, res
end

function ITimProcessor:process_timMessageList(seqid, iprot, oprot, server_ctx)
  local args = timMessageList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timMessageList, self.handler, args.mbeanList)
  return status, res
end

function ITimProcessor:process_timPresenceList(seqid, iprot, oprot, server_ctx)
  local args = timPresenceList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timPresenceList, self.handler, args.pbeanList)
  return status, res
end

function ITimProcessor:process_timMessageIq(seqid, iprot, oprot, server_ctx)
  local args = timMessageIq_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timMessageIq, self.handler, args.timMsgIq, args.iqType)
  return status, res
end

function ITimProcessor:process_timMessageResult(seqid, iprot, oprot, server_ctx)
  local args = timMessageResult_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timMessageResult, self.handler, args.mbean)
  return status, res
end

function ITimProcessor:process_timProperty(seqid, iprot, oprot, server_ctx)
  local args = timProperty_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local status, res = pcall(self.handler.timProperty, self.handler, args.tpb)
  return status, res
end

function ITimProcessor:process_timRemoteUserAuth(seqid, iprot, oprot, server_ctx)
  local args = timRemoteUserAuth_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timRemoteUserAuth_result:new{}
  local status, res = pcall(self.handler.timRemoteUserAuth, self.handler, args.tid, args.pwd, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timRemoteUserAuth', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timRemoteUserGet(seqid, iprot, oprot, server_ctx)
  local args = timRemoteUserGet_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timRemoteUserGet_result:new{}
  local status, res = pcall(self.handler.timRemoteUserGet, self.handler, args.tid, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timRemoteUserGet', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timRemoteUserEdit(seqid, iprot, oprot, server_ctx)
  local args = timRemoteUserEdit_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timRemoteUserEdit_result:new{}
  local status, res = pcall(self.handler.timRemoteUserEdit, self.handler, args.tid, args.ub, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timRemoteUserEdit', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timResponsePresence(seqid, iprot, oprot, server_ctx)
  local args = timResponsePresence_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timResponsePresence_result:new{}
  local status, res = pcall(self.handler.timResponsePresence, self.handler, args.pbean, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timResponsePresence', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timResponseMessage(seqid, iprot, oprot, server_ctx)
  local args = timResponseMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timResponseMessage_result:new{}
  local status, res = pcall(self.handler.timResponseMessage, self.handler, args.mbean, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timResponseMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timResponseMessageIq(seqid, iprot, oprot, server_ctx)
  local args = timResponseMessageIq_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timResponseMessageIq_result:new{}
  local status, res = pcall(self.handler.timResponseMessageIq, self.handler, args.timMsgIq, args.iqType, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timResponseMessageIq', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timResponsePresenceList(seqid, iprot, oprot, server_ctx)
  local args = timResponsePresenceList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timResponsePresenceList_result:new{}
  local status, res = pcall(self.handler.timResponsePresenceList, self.handler, args.pbeanList, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timResponsePresenceList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

function ITimProcessor:process_timResponseMessageList(seqid, iprot, oprot, server_ctx)
  local args = timResponseMessageList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = timResponseMessageList_result:new{}
  local status, res = pcall(self.handler.timResponseMessageList, self.handler, args.mbeanList, args.auth)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('timResponseMessageList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
  return status, res
end

-- HELPER FUNCTIONS AND STRUCTURES

timStream_args = __TObject:new{
  param
}

function timStream_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.param = TimParam:new{}
        self.param:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timStream_args:write(oprot)
  oprot:writeStructBegin('timStream_args')
  if self.param ~= nil then
    oprot:writeFieldBegin('param', TType.STRUCT, 1)
    self.param:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timStarttls_args = __TObject:new{

}

function timStarttls_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timStarttls_args:write(oprot)
  oprot:writeStructBegin('timStarttls_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timLogin_args = __TObject:new{
  tid,
  pwd
}

function timLogin_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tid = Tid:new{}
        self.tid:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.pwd = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timLogin_args:write(oprot)
  oprot:writeStructBegin('timLogin_args')
  if self.tid ~= nil then
    oprot:writeFieldBegin('tid', TType.STRUCT, 1)
    self.tid:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.pwd ~= nil then
    oprot:writeFieldBegin('pwd', TType.STRING, 2)
    oprot:writeString(self.pwd)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timAck_args = __TObject:new{
  ab
}

function timAck_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.ab = TimAckBean:new{}
        self.ab:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timAck_args:write(oprot)
  oprot:writeStructBegin('timAck_args')
  if self.ab ~= nil then
    oprot:writeFieldBegin('ab', TType.STRUCT, 1)
    self.ab:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timPresence_args = __TObject:new{
  pbean
}

function timPresence_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.pbean = TimPBean:new{}
        self.pbean:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timPresence_args:write(oprot)
  oprot:writeStructBegin('timPresence_args')
  if self.pbean ~= nil then
    oprot:writeFieldBegin('pbean', TType.STRUCT, 1)
    self.pbean:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timMessage_args = __TObject:new{
  mbean
}

function timMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.mbean = TimMBean:new{}
        self.mbean:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timMessage_args:write(oprot)
  oprot:writeStructBegin('timMessage_args')
  if self.mbean ~= nil then
    oprot:writeFieldBegin('mbean', TType.STRUCT, 1)
    self.mbean:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timPing_args = __TObject:new{
  threadId
}

function timPing_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.threadId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timPing_args:write(oprot)
  oprot:writeStructBegin('timPing_args')
  if self.threadId ~= nil then
    oprot:writeFieldBegin('threadId', TType.STRING, 1)
    oprot:writeString(self.threadId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timError_args = __TObject:new{
  e
}

function timError_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TimError:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timError_args:write(oprot)
  oprot:writeStructBegin('timError_args')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timLogout_args = __TObject:new{

}

function timLogout_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timLogout_args:write(oprot)
  oprot:writeStructBegin('timLogout_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRegist_args = __TObject:new{
  tid,
  auth
}

function timRegist_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tid = Tid:new{}
        self.tid:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.auth = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRegist_args:write(oprot)
  oprot:writeStructBegin('timRegist_args')
  if self.tid ~= nil then
    oprot:writeFieldBegin('tid', TType.STRUCT, 1)
    self.tid:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRING, 2)
    oprot:writeString(self.auth)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRoser_args = __TObject:new{
  roster
}

function timRoser_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.roster = TimRoster:new{}
        self.roster:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRoser_args:write(oprot)
  oprot:writeStructBegin('timRoser_args')
  if self.roster ~= nil then
    oprot:writeFieldBegin('roster', TType.STRUCT, 1)
    self.roster:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timMessageList_args = __TObject:new{
  mbeanList
}

function timMessageList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.mbeanList = TimMBeanList:new{}
        self.mbeanList:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timMessageList_args:write(oprot)
  oprot:writeStructBegin('timMessageList_args')
  if self.mbeanList ~= nil then
    oprot:writeFieldBegin('mbeanList', TType.STRUCT, 1)
    self.mbeanList:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timPresenceList_args = __TObject:new{
  pbeanList
}

function timPresenceList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.pbeanList = TimPBeanList:new{}
        self.pbeanList:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timPresenceList_args:write(oprot)
  oprot:writeStructBegin('timPresenceList_args')
  if self.pbeanList ~= nil then
    oprot:writeFieldBegin('pbeanList', TType.STRUCT, 1)
    self.pbeanList:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timMessageIq_args = __TObject:new{
  timMsgIq,
  iqType
}

function timMessageIq_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.timMsgIq = TimMessageIq:new{}
        self.timMsgIq:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.iqType = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timMessageIq_args:write(oprot)
  oprot:writeStructBegin('timMessageIq_args')
  if self.timMsgIq ~= nil then
    oprot:writeFieldBegin('timMsgIq', TType.STRUCT, 1)
    self.timMsgIq:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.iqType ~= nil then
    oprot:writeFieldBegin('iqType', TType.STRING, 2)
    oprot:writeString(self.iqType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timMessageResult_args = __TObject:new{
  mbean
}

function timMessageResult_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.mbean = TimMBean:new{}
        self.mbean:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timMessageResult_args:write(oprot)
  oprot:writeStructBegin('timMessageResult_args')
  if self.mbean ~= nil then
    oprot:writeFieldBegin('mbean', TType.STRUCT, 1)
    self.mbean:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timProperty_args = __TObject:new{
  tpb
}

function timProperty_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tpb = TimPropertyBean:new{}
        self.tpb:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timProperty_args:write(oprot)
  oprot:writeStructBegin('timProperty_args')
  if self.tpb ~= nil then
    oprot:writeFieldBegin('tpb', TType.STRUCT, 1)
    self.tpb:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserAuth_args = __TObject:new{
  tid,
  pwd,
  auth
}

function timRemoteUserAuth_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tid = Tid:new{}
        self.tid:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.pwd = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserAuth_args:write(oprot)
  oprot:writeStructBegin('timRemoteUserAuth_args')
  if self.tid ~= nil then
    oprot:writeFieldBegin('tid', TType.STRUCT, 1)
    self.tid:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.pwd ~= nil then
    oprot:writeFieldBegin('pwd', TType.STRING, 2)
    oprot:writeString(self.pwd)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 3)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserAuth_result = __TObject:new{
  success
}

function timRemoteUserAuth_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimRemoteUserBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserAuth_result:write(oprot)
  oprot:writeStructBegin('timRemoteUserAuth_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserGet_args = __TObject:new{
  tid,
  auth
}

function timRemoteUserGet_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tid = Tid:new{}
        self.tid:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserGet_args:write(oprot)
  oprot:writeStructBegin('timRemoteUserGet_args')
  if self.tid ~= nil then
    oprot:writeFieldBegin('tid', TType.STRUCT, 1)
    self.tid:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 2)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserGet_result = __TObject:new{
  success
}

function timRemoteUserGet_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimRemoteUserBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserGet_result:write(oprot)
  oprot:writeStructBegin('timRemoteUserGet_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserEdit_args = __TObject:new{
  tid,
  ub,
  auth
}

function timRemoteUserEdit_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.tid = Tid:new{}
        self.tid:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.ub = TimUserBean:new{}
        self.ub:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserEdit_args:write(oprot)
  oprot:writeStructBegin('timRemoteUserEdit_args')
  if self.tid ~= nil then
    oprot:writeFieldBegin('tid', TType.STRUCT, 1)
    self.tid:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.ub ~= nil then
    oprot:writeFieldBegin('ub', TType.STRUCT, 2)
    self.ub:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 3)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timRemoteUserEdit_result = __TObject:new{
  success
}

function timRemoteUserEdit_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimRemoteUserBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timRemoteUserEdit_result:write(oprot)
  oprot:writeStructBegin('timRemoteUserEdit_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponsePresence_args = __TObject:new{
  pbean,
  auth
}

function timResponsePresence_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.pbean = TimPBean:new{}
        self.pbean:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponsePresence_args:write(oprot)
  oprot:writeStructBegin('timResponsePresence_args')
  if self.pbean ~= nil then
    oprot:writeFieldBegin('pbean', TType.STRUCT, 1)
    self.pbean:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 2)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponsePresence_result = __TObject:new{
  success
}

function timResponsePresence_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimResponseBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponsePresence_result:write(oprot)
  oprot:writeStructBegin('timResponsePresence_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessage_args = __TObject:new{
  mbean,
  auth
}

function timResponseMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.mbean = TimMBean:new{}
        self.mbean:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessage_args:write(oprot)
  oprot:writeStructBegin('timResponseMessage_args')
  if self.mbean ~= nil then
    oprot:writeFieldBegin('mbean', TType.STRUCT, 1)
    self.mbean:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 2)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessage_result = __TObject:new{
  success
}

function timResponseMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimResponseBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessage_result:write(oprot)
  oprot:writeStructBegin('timResponseMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessageIq_args = __TObject:new{
  timMsgIq,
  iqType,
  auth
}

function timResponseMessageIq_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.timMsgIq = TimMessageIq:new{}
        self.timMsgIq:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.iqType = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessageIq_args:write(oprot)
  oprot:writeStructBegin('timResponseMessageIq_args')
  if self.timMsgIq ~= nil then
    oprot:writeFieldBegin('timMsgIq', TType.STRUCT, 1)
    self.timMsgIq:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.iqType ~= nil then
    oprot:writeFieldBegin('iqType', TType.STRING, 2)
    oprot:writeString(self.iqType)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 3)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessageIq_result = __TObject:new{
  success
}

function timResponseMessageIq_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimMBeanList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessageIq_result:write(oprot)
  oprot:writeStructBegin('timResponseMessageIq_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponsePresenceList_args = __TObject:new{
  pbeanList,
  auth
}

function timResponsePresenceList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.pbeanList = TimPBeanList:new{}
        self.pbeanList:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponsePresenceList_args:write(oprot)
  oprot:writeStructBegin('timResponsePresenceList_args')
  if self.pbeanList ~= nil then
    oprot:writeFieldBegin('pbeanList', TType.STRUCT, 1)
    self.pbeanList:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 2)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponsePresenceList_result = __TObject:new{
  success
}

function timResponsePresenceList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimResponseBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponsePresenceList_result:write(oprot)
  oprot:writeStructBegin('timResponsePresenceList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessageList_args = __TObject:new{
  mbeanList,
  auth
}

function timResponseMessageList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.mbeanList = TimMBeanList:new{}
        self.mbeanList:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.auth = TimAuth:new{}
        self.auth:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessageList_args:write(oprot)
  oprot:writeStructBegin('timResponseMessageList_args')
  if self.mbeanList ~= nil then
    oprot:writeFieldBegin('mbeanList', TType.STRUCT, 1)
    self.mbeanList:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.auth ~= nil then
    oprot:writeFieldBegin('auth', TType.STRUCT, 2)
    self.auth:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

timResponseMessageList_result = __TObject:new{
  success
}

function timResponseMessageList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TimResponseBean:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function timResponseMessageList_result:write(oprot)
  oprot:writeStructBegin('timResponseMessageList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end