#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Types;


# HELPER FUNCTIONS AND STRUCTURES

package ITim_timStream_args;
use base qw(Class::Accessor);
ITim_timStream_args->mk_accessors( qw( param ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{param} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{param}) {
      $self->{param} = $vals->{param};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timStream_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{param} = TimParam->new();
        $xfer += $self->{param}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timStream_args');
  if (defined $self->{param}) {
    $xfer += $output->writeFieldBegin('param', Thrift::TType::STRUCT, 1);
    $xfer += $self->{param}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timStream_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timStream_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timStream_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timStarttls_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timStarttls_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timStarttls_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timStarttls_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timStarttls_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timStarttls_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timLogin_args;
use base qw(Class::Accessor);
ITim_timLogin_args->mk_accessors( qw( tid pwd ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tid} = undef;
  $self->{pwd} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tid}) {
      $self->{tid} = $vals->{tid};
    }
    if (defined $vals->{pwd}) {
      $self->{pwd} = $vals->{pwd};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timLogin_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tid} = Tid->new();
        $xfer += $self->{tid}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{pwd});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timLogin_args');
  if (defined $self->{tid}) {
    $xfer += $output->writeFieldBegin('tid', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tid}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{pwd}) {
    $xfer += $output->writeFieldBegin('pwd', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{pwd});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timLogin_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timLogin_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timLogin_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timAck_args;
use base qw(Class::Accessor);
ITim_timAck_args->mk_accessors( qw( ab ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ab} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ab}) {
      $self->{ab} = $vals->{ab};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timAck_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ab} = TimAckBean->new();
        $xfer += $self->{ab}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timAck_args');
  if (defined $self->{ab}) {
    $xfer += $output->writeFieldBegin('ab', Thrift::TType::STRUCT, 1);
    $xfer += $self->{ab}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timAck_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timAck_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timAck_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPresence_args;
use base qw(Class::Accessor);
ITim_timPresence_args->mk_accessors( qw( pbean ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pbean} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pbean}) {
      $self->{pbean} = $vals->{pbean};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPresence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{pbean} = TimPBean->new();
        $xfer += $self->{pbean}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPresence_args');
  if (defined $self->{pbean}) {
    $xfer += $output->writeFieldBegin('pbean', Thrift::TType::STRUCT, 1);
    $xfer += $self->{pbean}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPresence_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPresence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPresence_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessage_args;
use base qw(Class::Accessor);
ITim_timMessage_args->mk_accessors( qw( mbean ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mbean} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mbean}) {
      $self->{mbean} = $vals->{mbean};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessage_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mbean} = TimMBean->new();
        $xfer += $self->{mbean}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessage_args');
  if (defined $self->{mbean}) {
    $xfer += $output->writeFieldBegin('mbean', Thrift::TType::STRUCT, 1);
    $xfer += $self->{mbean}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessage_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessage_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessage_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPing_args;
use base qw(Class::Accessor);
ITim_timPing_args->mk_accessors( qw( threadId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{threadId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{threadId}) {
      $self->{threadId} = $vals->{threadId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{threadId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPing_args');
  if (defined $self->{threadId}) {
    $xfer += $output->writeFieldBegin('threadId', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{threadId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPing_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPing_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timError_args;
use base qw(Class::Accessor);
ITim_timError_args->mk_accessors( qw( e ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timError_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = TimError->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timError_args');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timError_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timError_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timError_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timLogout_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timLogout_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timLogout_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timLogout_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timLogout_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timLogout_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRegist_args;
use base qw(Class::Accessor);
ITim_timRegist_args->mk_accessors( qw( tid auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tid} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tid}) {
      $self->{tid} = $vals->{tid};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRegist_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tid} = Tid->new();
        $xfer += $self->{tid}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{auth});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRegist_args');
  if (defined $self->{tid}) {
    $xfer += $output->writeFieldBegin('tid', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tid}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{auth});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRegist_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRegist_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRegist_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRoser_args;
use base qw(Class::Accessor);
ITim_timRoser_args->mk_accessors( qw( roster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{roster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{roster}) {
      $self->{roster} = $vals->{roster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRoser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{roster} = TimRoster->new();
        $xfer += $self->{roster}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRoser_args');
  if (defined $self->{roster}) {
    $xfer += $output->writeFieldBegin('roster', Thrift::TType::STRUCT, 1);
    $xfer += $self->{roster}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRoser_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRoser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRoser_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageList_args;
use base qw(Class::Accessor);
ITim_timMessageList_args->mk_accessors( qw( mbeanList ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mbeanList} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mbeanList}) {
      $self->{mbeanList} = $vals->{mbeanList};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mbeanList} = TimMBeanList->new();
        $xfer += $self->{mbeanList}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageList_args');
  if (defined $self->{mbeanList}) {
    $xfer += $output->writeFieldBegin('mbeanList', Thrift::TType::STRUCT, 1);
    $xfer += $self->{mbeanList}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageList_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageList_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPresenceList_args;
use base qw(Class::Accessor);
ITim_timPresenceList_args->mk_accessors( qw( pbeanList ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pbeanList} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pbeanList}) {
      $self->{pbeanList} = $vals->{pbeanList};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPresenceList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{pbeanList} = TimPBeanList->new();
        $xfer += $self->{pbeanList}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPresenceList_args');
  if (defined $self->{pbeanList}) {
    $xfer += $output->writeFieldBegin('pbeanList', Thrift::TType::STRUCT, 1);
    $xfer += $self->{pbeanList}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timPresenceList_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timPresenceList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timPresenceList_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageIq_args;
use base qw(Class::Accessor);
ITim_timMessageIq_args->mk_accessors( qw( timMsgIq iqType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timMsgIq} = undef;
  $self->{iqType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timMsgIq}) {
      $self->{timMsgIq} = $vals->{timMsgIq};
    }
    if (defined $vals->{iqType}) {
      $self->{iqType} = $vals->{iqType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageIq_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{timMsgIq} = TimMessageIq->new();
        $xfer += $self->{timMsgIq}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{iqType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageIq_args');
  if (defined $self->{timMsgIq}) {
    $xfer += $output->writeFieldBegin('timMsgIq', Thrift::TType::STRUCT, 1);
    $xfer += $self->{timMsgIq}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{iqType}) {
    $xfer += $output->writeFieldBegin('iqType', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{iqType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageIq_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageIq_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageIq_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageResult_args;
use base qw(Class::Accessor);
ITim_timMessageResult_args->mk_accessors( qw( mbean ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mbean} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mbean}) {
      $self->{mbean} = $vals->{mbean};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageResult_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mbean} = TimMBean->new();
        $xfer += $self->{mbean}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageResult_args');
  if (defined $self->{mbean}) {
    $xfer += $output->writeFieldBegin('mbean', Thrift::TType::STRUCT, 1);
    $xfer += $self->{mbean}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timMessageResult_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timMessageResult_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timMessageResult_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timProperty_args;
use base qw(Class::Accessor);
ITim_timProperty_args->mk_accessors( qw( tpb ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tpb} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tpb}) {
      $self->{tpb} = $vals->{tpb};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timProperty_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tpb} = TimPropertyBean->new();
        $xfer += $self->{tpb}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timProperty_args');
  if (defined $self->{tpb}) {
    $xfer += $output->writeFieldBegin('tpb', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tpb}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timProperty_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timProperty_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timProperty_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserAuth_args;
use base qw(Class::Accessor);
ITim_timRemoteUserAuth_args->mk_accessors( qw( tid pwd auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tid} = undef;
  $self->{pwd} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tid}) {
      $self->{tid} = $vals->{tid};
    }
    if (defined $vals->{pwd}) {
      $self->{pwd} = $vals->{pwd};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserAuth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tid} = Tid->new();
        $xfer += $self->{tid}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{pwd});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserAuth_args');
  if (defined $self->{tid}) {
    $xfer += $output->writeFieldBegin('tid', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tid}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{pwd}) {
    $xfer += $output->writeFieldBegin('pwd', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{pwd});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 3);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserAuth_result;
use base qw(Class::Accessor);
ITim_timRemoteUserAuth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserAuth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimRemoteUserBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserAuth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserGet_args;
use base qw(Class::Accessor);
ITim_timRemoteUserGet_args->mk_accessors( qw( tid auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tid} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tid}) {
      $self->{tid} = $vals->{tid};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserGet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tid} = Tid->new();
        $xfer += $self->{tid}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserGet_args');
  if (defined $self->{tid}) {
    $xfer += $output->writeFieldBegin('tid', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tid}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 2);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserGet_result;
use base qw(Class::Accessor);
ITim_timRemoteUserGet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserGet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimRemoteUserBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserGet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserEdit_args;
use base qw(Class::Accessor);
ITim_timRemoteUserEdit_args->mk_accessors( qw( tid ub auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tid} = undef;
  $self->{ub} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tid}) {
      $self->{tid} = $vals->{tid};
    }
    if (defined $vals->{ub}) {
      $self->{ub} = $vals->{ub};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserEdit_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{tid} = Tid->new();
        $xfer += $self->{tid}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ub} = TimUserBean->new();
        $xfer += $self->{ub}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserEdit_args');
  if (defined $self->{tid}) {
    $xfer += $output->writeFieldBegin('tid', Thrift::TType::STRUCT, 1);
    $xfer += $self->{tid}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ub}) {
    $xfer += $output->writeFieldBegin('ub', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ub}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 3);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timRemoteUserEdit_result;
use base qw(Class::Accessor);
ITim_timRemoteUserEdit_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timRemoteUserEdit_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimRemoteUserBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timRemoteUserEdit_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponsePresence_args;
use base qw(Class::Accessor);
ITim_timResponsePresence_args->mk_accessors( qw( pbean auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pbean} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pbean}) {
      $self->{pbean} = $vals->{pbean};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponsePresence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{pbean} = TimPBean->new();
        $xfer += $self->{pbean}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponsePresence_args');
  if (defined $self->{pbean}) {
    $xfer += $output->writeFieldBegin('pbean', Thrift::TType::STRUCT, 1);
    $xfer += $self->{pbean}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 2);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponsePresence_result;
use base qw(Class::Accessor);
ITim_timResponsePresence_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponsePresence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimResponseBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponsePresence_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessage_args;
use base qw(Class::Accessor);
ITim_timResponseMessage_args->mk_accessors( qw( mbean auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mbean} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mbean}) {
      $self->{mbean} = $vals->{mbean};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessage_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mbean} = TimMBean->new();
        $xfer += $self->{mbean}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessage_args');
  if (defined $self->{mbean}) {
    $xfer += $output->writeFieldBegin('mbean', Thrift::TType::STRUCT, 1);
    $xfer += $self->{mbean}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 2);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessage_result;
use base qw(Class::Accessor);
ITim_timResponseMessage_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessage_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimResponseBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessage_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessageIq_args;
use base qw(Class::Accessor);
ITim_timResponseMessageIq_args->mk_accessors( qw( timMsgIq iqType auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timMsgIq} = undef;
  $self->{iqType} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timMsgIq}) {
      $self->{timMsgIq} = $vals->{timMsgIq};
    }
    if (defined $vals->{iqType}) {
      $self->{iqType} = $vals->{iqType};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessageIq_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{timMsgIq} = TimMessageIq->new();
        $xfer += $self->{timMsgIq}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{iqType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessageIq_args');
  if (defined $self->{timMsgIq}) {
    $xfer += $output->writeFieldBegin('timMsgIq', Thrift::TType::STRUCT, 1);
    $xfer += $self->{timMsgIq}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{iqType}) {
    $xfer += $output->writeFieldBegin('iqType', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{iqType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 3);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessageIq_result;
use base qw(Class::Accessor);
ITim_timResponseMessageIq_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessageIq_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimMBeanList->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessageIq_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponsePresenceList_args;
use base qw(Class::Accessor);
ITim_timResponsePresenceList_args->mk_accessors( qw( pbeanList auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pbeanList} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pbeanList}) {
      $self->{pbeanList} = $vals->{pbeanList};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponsePresenceList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{pbeanList} = TimPBeanList->new();
        $xfer += $self->{pbeanList}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponsePresenceList_args');
  if (defined $self->{pbeanList}) {
    $xfer += $output->writeFieldBegin('pbeanList', Thrift::TType::STRUCT, 1);
    $xfer += $self->{pbeanList}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 2);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponsePresenceList_result;
use base qw(Class::Accessor);
ITim_timResponsePresenceList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponsePresenceList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimResponseBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponsePresenceList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessageList_args;
use base qw(Class::Accessor);
ITim_timResponseMessageList_args->mk_accessors( qw( mbeanList auth ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mbeanList} = undef;
  $self->{auth} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mbeanList}) {
      $self->{mbeanList} = $vals->{mbeanList};
    }
    if (defined $vals->{auth}) {
      $self->{auth} = $vals->{auth};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessageList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mbeanList} = TimMBeanList->new();
        $xfer += $self->{mbeanList}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{auth} = TimAuth->new();
        $xfer += $self->{auth}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessageList_args');
  if (defined $self->{mbeanList}) {
    $xfer += $output->writeFieldBegin('mbeanList', Thrift::TType::STRUCT, 1);
    $xfer += $self->{mbeanList}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{auth}) {
    $xfer += $output->writeFieldBegin('auth', Thrift::TType::STRUCT, 2);
    $xfer += $self->{auth}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITim_timResponseMessageList_result;
use base qw(Class::Accessor);
ITim_timResponseMessageList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ITim_timResponseMessageList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = TimResponseBean->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ITim_timResponseMessageList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ITimIf;

use strict;


sub timStream{
  my $self = shift;
  my $param = shift;

  die 'implement interface';
}

sub timStarttls{
  my $self = shift;

  die 'implement interface';
}

sub timLogin{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;

  die 'implement interface';
}

sub timAck{
  my $self = shift;
  my $ab = shift;

  die 'implement interface';
}

sub timPresence{
  my $self = shift;
  my $pbean = shift;

  die 'implement interface';
}

sub timMessage{
  my $self = shift;
  my $mbean = shift;

  die 'implement interface';
}

sub timPing{
  my $self = shift;
  my $threadId = shift;

  die 'implement interface';
}

sub timError{
  my $self = shift;
  my $e = shift;

  die 'implement interface';
}

sub timLogout{
  my $self = shift;

  die 'implement interface';
}

sub timRegist{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timRoser{
  my $self = shift;
  my $roster = shift;

  die 'implement interface';
}

sub timMessageList{
  my $self = shift;
  my $mbeanList = shift;

  die 'implement interface';
}

sub timPresenceList{
  my $self = shift;
  my $pbeanList = shift;

  die 'implement interface';
}

sub timMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;

  die 'implement interface';
}

sub timMessageResult{
  my $self = shift;
  my $mbean = shift;

  die 'implement interface';
}

sub timProperty{
  my $self = shift;
  my $tpb = shift;

  die 'implement interface';
}

sub timRemoteUserAuth{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timRemoteUserGet{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timRemoteUserEdit{
  my $self = shift;
  my $tid = shift;
  my $ub = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timResponsePresence{
  my $self = shift;
  my $pbean = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timResponseMessage{
  my $self = shift;
  my $mbean = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timResponseMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timResponsePresenceList{
  my $self = shift;
  my $pbeanList = shift;
  my $auth = shift;

  die 'implement interface';
}

sub timResponseMessageList{
  my $self = shift;
  my $mbeanList = shift;
  my $auth = shift;

  die 'implement interface';
}

package ITimRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub timStream{
  my ($self, $request) = @_;

  my $param = ($request->{'param'}) ? $request->{'param'} : undef;
  return $self->{impl}->timStream($param);
}

sub timStarttls{
  my ($self, $request) = @_;

  return $self->{impl}->timStarttls();
}

sub timLogin{
  my ($self, $request) = @_;

  my $tid = ($request->{'tid'}) ? $request->{'tid'} : undef;
  my $pwd = ($request->{'pwd'}) ? $request->{'pwd'} : undef;
  return $self->{impl}->timLogin($tid, $pwd);
}

sub timAck{
  my ($self, $request) = @_;

  my $ab = ($request->{'ab'}) ? $request->{'ab'} : undef;
  return $self->{impl}->timAck($ab);
}

sub timPresence{
  my ($self, $request) = @_;

  my $pbean = ($request->{'pbean'}) ? $request->{'pbean'} : undef;
  return $self->{impl}->timPresence($pbean);
}

sub timMessage{
  my ($self, $request) = @_;

  my $mbean = ($request->{'mbean'}) ? $request->{'mbean'} : undef;
  return $self->{impl}->timMessage($mbean);
}

sub timPing{
  my ($self, $request) = @_;

  my $threadId = ($request->{'threadId'}) ? $request->{'threadId'} : undef;
  return $self->{impl}->timPing($threadId);
}

sub timError{
  my ($self, $request) = @_;

  my $e = ($request->{'e'}) ? $request->{'e'} : undef;
  return $self->{impl}->timError($e);
}

sub timLogout{
  my ($self, $request) = @_;

  return $self->{impl}->timLogout();
}

sub timRegist{
  my ($self, $request) = @_;

  my $tid = ($request->{'tid'}) ? $request->{'tid'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timRegist($tid, $auth);
}

sub timRoser{
  my ($self, $request) = @_;

  my $roster = ($request->{'roster'}) ? $request->{'roster'} : undef;
  return $self->{impl}->timRoser($roster);
}

sub timMessageList{
  my ($self, $request) = @_;

  my $mbeanList = ($request->{'mbeanList'}) ? $request->{'mbeanList'} : undef;
  return $self->{impl}->timMessageList($mbeanList);
}

sub timPresenceList{
  my ($self, $request) = @_;

  my $pbeanList = ($request->{'pbeanList'}) ? $request->{'pbeanList'} : undef;
  return $self->{impl}->timPresenceList($pbeanList);
}

sub timMessageIq{
  my ($self, $request) = @_;

  my $timMsgIq = ($request->{'timMsgIq'}) ? $request->{'timMsgIq'} : undef;
  my $iqType = ($request->{'iqType'}) ? $request->{'iqType'} : undef;
  return $self->{impl}->timMessageIq($timMsgIq, $iqType);
}

sub timMessageResult{
  my ($self, $request) = @_;

  my $mbean = ($request->{'mbean'}) ? $request->{'mbean'} : undef;
  return $self->{impl}->timMessageResult($mbean);
}

sub timProperty{
  my ($self, $request) = @_;

  my $tpb = ($request->{'tpb'}) ? $request->{'tpb'} : undef;
  return $self->{impl}->timProperty($tpb);
}

sub timRemoteUserAuth{
  my ($self, $request) = @_;

  my $tid = ($request->{'tid'}) ? $request->{'tid'} : undef;
  my $pwd = ($request->{'pwd'}) ? $request->{'pwd'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timRemoteUserAuth($tid, $pwd, $auth);
}

sub timRemoteUserGet{
  my ($self, $request) = @_;

  my $tid = ($request->{'tid'}) ? $request->{'tid'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timRemoteUserGet($tid, $auth);
}

sub timRemoteUserEdit{
  my ($self, $request) = @_;

  my $tid = ($request->{'tid'}) ? $request->{'tid'} : undef;
  my $ub = ($request->{'ub'}) ? $request->{'ub'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timRemoteUserEdit($tid, $ub, $auth);
}

sub timResponsePresence{
  my ($self, $request) = @_;

  my $pbean = ($request->{'pbean'}) ? $request->{'pbean'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timResponsePresence($pbean, $auth);
}

sub timResponseMessage{
  my ($self, $request) = @_;

  my $mbean = ($request->{'mbean'}) ? $request->{'mbean'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timResponseMessage($mbean, $auth);
}

sub timResponseMessageIq{
  my ($self, $request) = @_;

  my $timMsgIq = ($request->{'timMsgIq'}) ? $request->{'timMsgIq'} : undef;
  my $iqType = ($request->{'iqType'}) ? $request->{'iqType'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timResponseMessageIq($timMsgIq, $iqType, $auth);
}

sub timResponsePresenceList{
  my ($self, $request) = @_;

  my $pbeanList = ($request->{'pbeanList'}) ? $request->{'pbeanList'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timResponsePresenceList($pbeanList, $auth);
}

sub timResponseMessageList{
  my ($self, $request) = @_;

  my $mbeanList = ($request->{'mbeanList'}) ? $request->{'mbeanList'} : undef;
  my $auth = ($request->{'auth'}) ? $request->{'auth'} : undef;
  return $self->{impl}->timResponseMessageList($mbeanList, $auth);
}

package ITimClient;


use base qw(ITimIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub timStream{
  my $self = shift;
  my $param = shift;

    $self->send_timStream($param);
}

sub send_timStream{
  my $self = shift;
  my $param = shift;

  $self->{output}->writeMessageBegin('timStream', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timStream_args->new();
  $args->{param} = $param;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timStarttls{
  my $self = shift;

    $self->send_timStarttls();
}

sub send_timStarttls{
  my $self = shift;

  $self->{output}->writeMessageBegin('timStarttls', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timStarttls_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timLogin{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;

    $self->send_timLogin($tid, $pwd);
}

sub send_timLogin{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;

  $self->{output}->writeMessageBegin('timLogin', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timLogin_args->new();
  $args->{tid} = $tid;
  $args->{pwd} = $pwd;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timAck{
  my $self = shift;
  my $ab = shift;

    $self->send_timAck($ab);
}

sub send_timAck{
  my $self = shift;
  my $ab = shift;

  $self->{output}->writeMessageBegin('timAck', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timAck_args->new();
  $args->{ab} = $ab;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timPresence{
  my $self = shift;
  my $pbean = shift;

    $self->send_timPresence($pbean);
}

sub send_timPresence{
  my $self = shift;
  my $pbean = shift;

  $self->{output}->writeMessageBegin('timPresence', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timPresence_args->new();
  $args->{pbean} = $pbean;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timMessage{
  my $self = shift;
  my $mbean = shift;

    $self->send_timMessage($mbean);
}

sub send_timMessage{
  my $self = shift;
  my $mbean = shift;

  $self->{output}->writeMessageBegin('timMessage', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timMessage_args->new();
  $args->{mbean} = $mbean;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timPing{
  my $self = shift;
  my $threadId = shift;

    $self->send_timPing($threadId);
}

sub send_timPing{
  my $self = shift;
  my $threadId = shift;

  $self->{output}->writeMessageBegin('timPing', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timPing_args->new();
  $args->{threadId} = $threadId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timError{
  my $self = shift;
  my $e = shift;

    $self->send_timError($e);
}

sub send_timError{
  my $self = shift;
  my $e = shift;

  $self->{output}->writeMessageBegin('timError', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timError_args->new();
  $args->{e} = $e;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timLogout{
  my $self = shift;

    $self->send_timLogout();
}

sub send_timLogout{
  my $self = shift;

  $self->{output}->writeMessageBegin('timLogout', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timLogout_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timRegist{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

    $self->send_timRegist($tid, $auth);
}

sub send_timRegist{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timRegist', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timRegist_args->new();
  $args->{tid} = $tid;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timRoser{
  my $self = shift;
  my $roster = shift;

    $self->send_timRoser($roster);
}

sub send_timRoser{
  my $self = shift;
  my $roster = shift;

  $self->{output}->writeMessageBegin('timRoser', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timRoser_args->new();
  $args->{roster} = $roster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timMessageList{
  my $self = shift;
  my $mbeanList = shift;

    $self->send_timMessageList($mbeanList);
}

sub send_timMessageList{
  my $self = shift;
  my $mbeanList = shift;

  $self->{output}->writeMessageBegin('timMessageList', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timMessageList_args->new();
  $args->{mbeanList} = $mbeanList;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timPresenceList{
  my $self = shift;
  my $pbeanList = shift;

    $self->send_timPresenceList($pbeanList);
}

sub send_timPresenceList{
  my $self = shift;
  my $pbeanList = shift;

  $self->{output}->writeMessageBegin('timPresenceList', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timPresenceList_args->new();
  $args->{pbeanList} = $pbeanList;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;

    $self->send_timMessageIq($timMsgIq, $iqType);
}

sub send_timMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;

  $self->{output}->writeMessageBegin('timMessageIq', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timMessageIq_args->new();
  $args->{timMsgIq} = $timMsgIq;
  $args->{iqType} = $iqType;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timMessageResult{
  my $self = shift;
  my $mbean = shift;

    $self->send_timMessageResult($mbean);
}

sub send_timMessageResult{
  my $self = shift;
  my $mbean = shift;

  $self->{output}->writeMessageBegin('timMessageResult', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timMessageResult_args->new();
  $args->{mbean} = $mbean;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timProperty{
  my $self = shift;
  my $tpb = shift;

    $self->send_timProperty($tpb);
}

sub send_timProperty{
  my $self = shift;
  my $tpb = shift;

  $self->{output}->writeMessageBegin('timProperty', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ITim_timProperty_args->new();
  $args->{tpb} = $tpb;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub timRemoteUserAuth{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;
  my $auth = shift;

    $self->send_timRemoteUserAuth($tid, $pwd, $auth);
  return $self->recv_timRemoteUserAuth();
}

sub send_timRemoteUserAuth{
  my $self = shift;
  my $tid = shift;
  my $pwd = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timRemoteUserAuth', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timRemoteUserAuth_args->new();
  $args->{tid} = $tid;
  $args->{pwd} = $pwd;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timRemoteUserAuth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timRemoteUserAuth_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timRemoteUserAuth failed: unknown result";
}
sub timRemoteUserGet{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

    $self->send_timRemoteUserGet($tid, $auth);
  return $self->recv_timRemoteUserGet();
}

sub send_timRemoteUserGet{
  my $self = shift;
  my $tid = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timRemoteUserGet', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timRemoteUserGet_args->new();
  $args->{tid} = $tid;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timRemoteUserGet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timRemoteUserGet_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timRemoteUserGet failed: unknown result";
}
sub timRemoteUserEdit{
  my $self = shift;
  my $tid = shift;
  my $ub = shift;
  my $auth = shift;

    $self->send_timRemoteUserEdit($tid, $ub, $auth);
  return $self->recv_timRemoteUserEdit();
}

sub send_timRemoteUserEdit{
  my $self = shift;
  my $tid = shift;
  my $ub = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timRemoteUserEdit', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timRemoteUserEdit_args->new();
  $args->{tid} = $tid;
  $args->{ub} = $ub;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timRemoteUserEdit{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timRemoteUserEdit_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timRemoteUserEdit failed: unknown result";
}
sub timResponsePresence{
  my $self = shift;
  my $pbean = shift;
  my $auth = shift;

    $self->send_timResponsePresence($pbean, $auth);
  return $self->recv_timResponsePresence();
}

sub send_timResponsePresence{
  my $self = shift;
  my $pbean = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timResponsePresence', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timResponsePresence_args->new();
  $args->{pbean} = $pbean;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timResponsePresence{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timResponsePresence_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timResponsePresence failed: unknown result";
}
sub timResponseMessage{
  my $self = shift;
  my $mbean = shift;
  my $auth = shift;

    $self->send_timResponseMessage($mbean, $auth);
  return $self->recv_timResponseMessage();
}

sub send_timResponseMessage{
  my $self = shift;
  my $mbean = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timResponseMessage', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timResponseMessage_args->new();
  $args->{mbean} = $mbean;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timResponseMessage{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timResponseMessage_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timResponseMessage failed: unknown result";
}
sub timResponseMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;
  my $auth = shift;

    $self->send_timResponseMessageIq($timMsgIq, $iqType, $auth);
  return $self->recv_timResponseMessageIq();
}

sub send_timResponseMessageIq{
  my $self = shift;
  my $timMsgIq = shift;
  my $iqType = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timResponseMessageIq', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timResponseMessageIq_args->new();
  $args->{timMsgIq} = $timMsgIq;
  $args->{iqType} = $iqType;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timResponseMessageIq{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timResponseMessageIq_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timResponseMessageIq failed: unknown result";
}
sub timResponsePresenceList{
  my $self = shift;
  my $pbeanList = shift;
  my $auth = shift;

    $self->send_timResponsePresenceList($pbeanList, $auth);
  return $self->recv_timResponsePresenceList();
}

sub send_timResponsePresenceList{
  my $self = shift;
  my $pbeanList = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timResponsePresenceList', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timResponsePresenceList_args->new();
  $args->{pbeanList} = $pbeanList;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timResponsePresenceList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timResponsePresenceList_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timResponsePresenceList failed: unknown result";
}
sub timResponseMessageList{
  my $self = shift;
  my $mbeanList = shift;
  my $auth = shift;

    $self->send_timResponseMessageList($mbeanList, $auth);
  return $self->recv_timResponseMessageList();
}

sub send_timResponseMessageList{
  my $self = shift;
  my $mbeanList = shift;
  my $auth = shift;

  $self->{output}->writeMessageBegin('timResponseMessageList', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ITim_timResponseMessageList_args->new();
  $args->{mbeanList} = $mbeanList;
  $args->{auth} = $auth;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_timResponseMessageList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ITim_timResponseMessageList_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "timResponseMessageList failed: unknown result";
}
package ITimProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_timStream {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timStream_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timStream($args->param);
    return;
}
sub process_timStarttls {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timStarttls_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timStarttls();
    return;
}
sub process_timLogin {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timLogin_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timLogin($args->tid, $args->pwd);
    return;
}
sub process_timAck {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timAck_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timAck($args->ab);
    return;
}
sub process_timPresence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timPresence_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timPresence($args->pbean);
    return;
}
sub process_timMessage {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timMessage_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timMessage($args->mbean);
    return;
}
sub process_timPing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timPing_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timPing($args->threadId);
    return;
}
sub process_timError {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timError_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timError($args->e);
    return;
}
sub process_timLogout {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timLogout_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timLogout();
    return;
}
sub process_timRegist {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timRegist_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timRegist($args->tid, $args->auth);
    return;
}
sub process_timRoser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timRoser_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timRoser($args->roster);
    return;
}
sub process_timMessageList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timMessageList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timMessageList($args->mbeanList);
    return;
}
sub process_timPresenceList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timPresenceList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timPresenceList($args->pbeanList);
    return;
}
sub process_timMessageIq {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timMessageIq_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timMessageIq($args->timMsgIq, $args->iqType);
    return;
}
sub process_timMessageResult {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timMessageResult_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timMessageResult($args->mbean);
    return;
}
sub process_timProperty {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timProperty_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->timProperty($args->tpb);
    return;
}
sub process_timRemoteUserAuth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timRemoteUserAuth_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timRemoteUserAuth_result->new();
    $result->{success} = $self->{handler}->timRemoteUserAuth($args->tid, $args->pwd, $args->auth);
    $output->writeMessageBegin('timRemoteUserAuth', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timRemoteUserGet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timRemoteUserGet_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timRemoteUserGet_result->new();
    $result->{success} = $self->{handler}->timRemoteUserGet($args->tid, $args->auth);
    $output->writeMessageBegin('timRemoteUserGet', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timRemoteUserEdit {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timRemoteUserEdit_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timRemoteUserEdit_result->new();
    $result->{success} = $self->{handler}->timRemoteUserEdit($args->tid, $args->ub, $args->auth);
    $output->writeMessageBegin('timRemoteUserEdit', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timResponsePresence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timResponsePresence_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timResponsePresence_result->new();
    $result->{success} = $self->{handler}->timResponsePresence($args->pbean, $args->auth);
    $output->writeMessageBegin('timResponsePresence', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timResponseMessage {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timResponseMessage_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timResponseMessage_result->new();
    $result->{success} = $self->{handler}->timResponseMessage($args->mbean, $args->auth);
    $output->writeMessageBegin('timResponseMessage', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timResponseMessageIq {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timResponseMessageIq_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timResponseMessageIq_result->new();
    $result->{success} = $self->{handler}->timResponseMessageIq($args->timMsgIq, $args->iqType, $args->auth);
    $output->writeMessageBegin('timResponseMessageIq', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timResponsePresenceList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timResponsePresenceList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timResponsePresenceList_result->new();
    $result->{success} = $self->{handler}->timResponsePresenceList($args->pbeanList, $args->auth);
    $output->writeMessageBegin('timResponsePresenceList', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_timResponseMessageList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ITim_timResponseMessageList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ITim_timResponseMessageList_result->new();
    $result->{success} = $self->{handler}->timResponseMessageList($args->mbeanList, $args->auth);
    $output->writeMessageBegin('timResponseMessageList', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
