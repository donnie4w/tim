/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "tim_types.h"
#include <thrift/c_glib/thrift.h>

enum _TimErrorProperties
{
  PROP_TIM_ERROR_0,
  PROP_TIM_ERROR_ERR_CODE,
  PROP_TIM_ERROR_ERR_MSG
};

/* reads a tim_error object */
static gint32
tim_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimError * this_object = TIM_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->errMsg != NULL)
          {
            g_free(this_object->errMsg);
            this_object->errMsg = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->errMsg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errMsg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimError * this_object = TIM_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_errCode == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "errCode", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->errCode, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_errMsg == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "errMsg", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->errMsg, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_error_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimError *self = TIM_ERROR (object);

  switch (property_id)
  {
    case PROP_TIM_ERROR_ERR_CODE:
      self->errCode = g_value_get_int (value);
      self->__isset_errCode = TRUE;
      break;

    case PROP_TIM_ERROR_ERR_MSG:
      if (self->errMsg != NULL)
        g_free (self->errMsg);
      self->errMsg = g_value_dup_string (value);
      self->__isset_errMsg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_error_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimError *self = TIM_ERROR (object);

  switch (property_id)
  {
    case PROP_TIM_ERROR_ERR_CODE:
      g_value_set_int (value, self->errCode);
      break;

    case PROP_TIM_ERROR_ERR_MSG:
      g_value_set_string (value, self->errMsg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_error_instance_init (TimError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errCode = 0;
  object->__isset_errCode = FALSE;
  object->errMsg = NULL;
  object->__isset_errMsg = FALSE;
}

static void 
tim_error_finalize (GObject *object)
{
  TimError *tobject = TIM_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->errMsg != NULL)
  {
    g_free(tobject->errMsg);
    tobject->errMsg = NULL;
  }
}

static void
tim_error_class_init (TimErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_error_read;
  struct_class->write = tim_error_write;

  gobject_class->finalize = tim_error_finalize;
  gobject_class->get_property = tim_error_get_property;
  gobject_class->set_property = tim_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ERROR_ERR_CODE,
     g_param_spec_int ("errCode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ERROR_ERR_MSG,
     g_param_spec_string ("errMsg",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimError),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimErrorType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimNodeProperties
{
  PROP_TIM_NODE_0,
  PROP_TIM_NODE_KEY,
  PROP_TIM_NODE_VALUE
};

/* reads a tim_node object */
static gint32
tim_node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimNode * this_object = TIM_NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimNode * this_object = TIM_NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimNode", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_node_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimNode *self = TIM_NODE (object);

  switch (property_id)
  {
    case PROP_TIM_NODE_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_TIM_NODE_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_node_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimNode *self = TIM_NODE (object);

  switch (property_id)
  {
    case PROP_TIM_NODE_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_TIM_NODE_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_node_instance_init (TimNode * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
tim_node_finalize (GObject *object)
{
  TimNode *tobject = TIM_NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
tim_node_class_init (TimNodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_node_read;
  struct_class->write = tim_node_write;

  gobject_class->finalize = tim_node_finalize;
  gobject_class->get_property = tim_node_get_property;
  gobject_class->set_property = tim_node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODE_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_NODE_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimNodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimNode),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimNodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimAckBeanProperties
{
  PROP_TIM_ACK_BEAN_0,
  PROP_TIM_ACK_BEAN_ID,
  PROP_TIM_ACK_BEAN_ACK_TYPE,
  PROP_TIM_ACK_BEAN_ACK_STATUS,
  PROP_TIM_ACK_BEAN_EXTRA_LIST,
  PROP_TIM_ACK_BEAN_ERR,
  PROP_TIM_ACK_BEAN_EXTRA_MAP
};

/* reads a tim_ack_bean object */
static gint32
tim_ack_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimAckBean * this_object = TIM_ACK_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->ackType != NULL)
          {
            g_free(this_object->ackType);
            this_object->ackType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ackType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ackType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->ackStatus != NULL)
          {
            g_free(this_object->ackStatus);
            this_object->ackStatus = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ackStatus, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ackStatus = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key1 = NULL;
              gchar * val2 = NULL;
              if (key1 != NULL)
              {
                g_free(key1);
                key1 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key1, error)) < 0)
                return -1;
              xfer += ret;
              if (val2 != NULL)
              {
                g_free(val2);
                val2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val2, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key1)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key1, (gpointer) val2);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_ack_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimAckBean * this_object = TIM_ACK_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimAckBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ackType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ackType", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->ackType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ackStatus == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ackStatus", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->ackStatus, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i3;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i3 = 0; i3 < (this_object->extraList ? this_object->extraList->len : 0); i3++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i3))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key4 = NULL;
      gchar * val5 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key4 = keys[i];
        val5 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key4);

        if ((ret = thrift_protocol_write_string (protocol,  key4, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val5, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_ack_bean_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  TimAckBean *self = TIM_ACK_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_ACK_BEAN_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    case PROP_TIM_ACK_BEAN_ACK_TYPE:
      if (self->ackType != NULL)
        g_free (self->ackType);
      self->ackType = g_value_dup_string (value);
      self->__isset_ackType = TRUE;
      break;

    case PROP_TIM_ACK_BEAN_ACK_STATUS:
      if (self->ackStatus != NULL)
        g_free (self->ackStatus);
      self->ackStatus = g_value_dup_string (value);
      self->__isset_ackStatus = TRUE;
      break;

    case PROP_TIM_ACK_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_ACK_BEAN_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    case PROP_TIM_ACK_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_ack_bean_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  TimAckBean *self = TIM_ACK_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_ACK_BEAN_ID:
      g_value_set_string (value, self->id);
      break;

    case PROP_TIM_ACK_BEAN_ACK_TYPE:
      g_value_set_string (value, self->ackType);
      break;

    case PROP_TIM_ACK_BEAN_ACK_STATUS:
      g_value_set_string (value, self->ackStatus);
      break;

    case PROP_TIM_ACK_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_ACK_BEAN_ERR:
      g_value_set_object (value, self->err);
      break;

    case PROP_TIM_ACK_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_ack_bean_instance_init (TimAckBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
  object->ackType = NULL;
  object->__isset_ackType = FALSE;
  object->ackStatus = NULL;
  object->__isset_ackStatus = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->err = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_err = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_ack_bean_finalize (GObject *object)
{
  TimAckBean *tobject = TIM_ACK_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
  if (tobject->ackType != NULL)
  {
    g_free(tobject->ackType);
    tobject->ackType = NULL;
  }
  if (tobject->ackStatus != NULL)
  {
    g_free(tobject->ackStatus);
    tobject->ackStatus = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_ack_bean_class_init (TimAckBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_ack_bean_read;
  struct_class->write = tim_ack_bean_write;

  gobject_class->finalize = tim_ack_bean_finalize;
  gobject_class->get_property = tim_ack_bean_get_property;
  gobject_class->set_property = tim_ack_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_ACK_TYPE,
     g_param_spec_string ("ackType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_ACK_STATUS,
     g_param_spec_string ("ackStatus",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ACK_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_ack_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimAckBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_ack_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimAckBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_ack_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimAckBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimHBeanProperties
{
  PROP_TIM_H_BEAN_0,
  PROP_TIM_H_BEAN_CHL,
  PROP_TIM_H_BEAN_PLATFORM,
  PROP_TIM_H_BEAN_VERSION
};

/* reads a tim_h_bean object */
static gint32
tim_h_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimHBean * this_object = TIM_H_BEAN(object);
  gboolean isset_chl = FALSE;
  gboolean isset_version = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->chl, error)) < 0)
            return -1;
          xfer += ret;
          isset_chl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->platform, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_platform = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_chl)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_version)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_h_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimHBean * this_object = TIM_H_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimHBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "chl", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->chl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_platform == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "platform", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->platform, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_h_bean_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TimHBean *self = TIM_H_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_H_BEAN_CHL:
      self->chl = g_value_get_int (value);
      break;

    case PROP_TIM_H_BEAN_PLATFORM:
      self->platform = g_value_get_int (value);
      self->__isset_platform = TRUE;
      break;

    case PROP_TIM_H_BEAN_VERSION:
      self->version = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_h_bean_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TimHBean *self = TIM_H_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_H_BEAN_CHL:
      g_value_set_int (value, self->chl);
      break;

    case PROP_TIM_H_BEAN_PLATFORM:
      g_value_set_int (value, self->platform);
      break;

    case PROP_TIM_H_BEAN_VERSION:
      g_value_set_int (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_h_bean_instance_init (TimHBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->chl = 0;
  object->platform = 0;
  object->__isset_platform = FALSE;
  object->version = 0;
}

static void 
tim_h_bean_finalize (GObject *object)
{
  TimHBean *tobject = TIM_H_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
tim_h_bean_class_init (TimHBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_h_bean_read;
  struct_class->write = tim_h_bean_write;

  gobject_class->finalize = tim_h_bean_finalize;
  gobject_class->get_property = tim_h_bean_get_property;
  gobject_class->set_property = tim_h_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_H_BEAN_CHL,
     g_param_spec_int ("chl",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_H_BEAN_PLATFORM,
     g_param_spec_int ("platform",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_H_BEAN_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
tim_h_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimHBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_h_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimHBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_h_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimHBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimParamProperties
{
  PROP_TIM_PARAM_0,
  PROP_TIM_PARAM_TIMESTAMP,
  PROP_TIM_PARAM_VERSION,
  PROP_TIM_PARAM_LANG,
  PROP_TIM_PARAM_EXTRA_LIST,
  PROP_TIM_PARAM_EXTRA_MAP,
  PROP_TIM_PARAM_INTERFLOW,
  PROP_TIM_PARAM_TLS
};

/* reads a tim_param object */
static gint32
tim_param_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimParam * this_object = TIM_PARAM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->lang != NULL)
          {
            g_free(this_object->lang);
            this_object->lang = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->lang, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_lang = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key7 = NULL;
              gchar * val8 = NULL;
              if (key7 != NULL)
              {
                g_free(key7);
                key7 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key7, error)) < 0)
                return -1;
              xfer += ret;
              if (val8 != NULL)
              {
                g_free(val8);
                val8 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val8, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key7)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key7, (gpointer) val8);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->interflow != NULL)
          {
            g_free(this_object->interflow);
            this_object->interflow = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->interflow, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_interflow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->tls != NULL)
          {
            g_free(this_object->tls);
            this_object->tls = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tls, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tls = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_param_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimParam * this_object = TIM_PARAM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimParam", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I16, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->version, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_lang == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "lang", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->lang, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i9;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i9 = 0; i9 < (this_object->extraList ? this_object->extraList->len : 0); i9++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i9))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key10 = NULL;
      gchar * val11 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key10 = keys[i];
        val11 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key10);

        if ((ret = thrift_protocol_write_string (protocol,  key10, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val11, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_interflow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "interflow", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->interflow, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tls == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tls", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->tls, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_param_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimParam *self = TIM_PARAM (object);

  switch (property_id)
  {
    case PROP_TIM_PARAM_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_TIM_PARAM_VERSION:
      self->version = g_value_get_int (value);
      self->__isset_version = TRUE;
      break;

    case PROP_TIM_PARAM_LANG:
      if (self->lang != NULL)
        g_free (self->lang);
      self->lang = g_value_dup_string (value);
      self->__isset_lang = TRUE;
      break;

    case PROP_TIM_PARAM_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_PARAM_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    case PROP_TIM_PARAM_INTERFLOW:
      if (self->interflow != NULL)
        g_free (self->interflow);
      self->interflow = g_value_dup_string (value);
      self->__isset_interflow = TRUE;
      break;

    case PROP_TIM_PARAM_TLS:
      if (self->tls != NULL)
        g_free (self->tls);
      self->tls = g_value_dup_string (value);
      self->__isset_tls = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_param_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimParam *self = TIM_PARAM (object);

  switch (property_id)
  {
    case PROP_TIM_PARAM_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    case PROP_TIM_PARAM_VERSION:
      g_value_set_int (value, self->version);
      break;

    case PROP_TIM_PARAM_LANG:
      g_value_set_string (value, self->lang);
      break;

    case PROP_TIM_PARAM_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_PARAM_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    case PROP_TIM_PARAM_INTERFLOW:
      g_value_set_string (value, self->interflow);
      break;

    case PROP_TIM_PARAM_TLS:
      g_value_set_string (value, self->tls);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_param_instance_init (TimParam * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
  object->version = 0;
  object->__isset_version = FALSE;
  object->lang = NULL;
  object->__isset_lang = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
  object->interflow = NULL;
  object->__isset_interflow = FALSE;
  object->tls = NULL;
  object->__isset_tls = FALSE;
}

static void 
tim_param_finalize (GObject *object)
{
  TimParam *tobject = TIM_PARAM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
  if (tobject->lang != NULL)
  {
    g_free(tobject->lang);
    tobject->lang = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
  if (tobject->interflow != NULL)
  {
    g_free(tobject->interflow);
    tobject->interflow = NULL;
  }
  if (tobject->tls != NULL)
  {
    g_free(tobject->tls);
    tobject->tls = NULL;
  }
}

static void
tim_param_class_init (TimParamClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_param_read;
  struct_class->write = tim_param_write;

  gobject_class->finalize = tim_param_finalize;
  gobject_class->get_property = tim_param_get_property;
  gobject_class->set_property = tim_param_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_LANG,
     g_param_spec_string ("lang",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_INTERFLOW,
     g_param_spec_string ("interflow",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PARAM_TLS,
     g_param_spec_string ("tls",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_param_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimParamClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_param_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimParam),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_param_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimParamType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimTimeProperties
{
  PROP_TIM_TIME_0,
  PROP_TIM_TIME_TIMESTAMP,
  PROP_TIM_TIME_FORMATTIME
};

/* reads a tim_time object */
static gint32
tim_time_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimTime * this_object = TIM_TIME(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->formattime != NULL)
          {
            g_free(this_object->formattime);
            this_object->formattime = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->formattime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_formattime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_time_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimTime * this_object = TIM_TIME(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimTime", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_formattime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "formattime", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->formattime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_time_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimTime *self = TIM_TIME (object);

  switch (property_id)
  {
    case PROP_TIM_TIME_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_TIM_TIME_FORMATTIME:
      if (self->formattime != NULL)
        g_free (self->formattime);
      self->formattime = g_value_dup_string (value);
      self->__isset_formattime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_time_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimTime *self = TIM_TIME (object);

  switch (property_id)
  {
    case PROP_TIM_TIME_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    case PROP_TIM_TIME_FORMATTIME:
      g_value_set_string (value, self->formattime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_time_instance_init (TimTime * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
  object->formattime = NULL;
  object->__isset_formattime = FALSE;
}

static void 
tim_time_finalize (GObject *object)
{
  TimTime *tobject = TIM_TIME (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
  if (tobject->formattime != NULL)
  {
    g_free(tobject->formattime);
    tobject->formattime = NULL;
  }
}

static void
tim_time_class_init (TimTimeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_time_read;
  struct_class->write = tim_time_write;

  gobject_class->finalize = tim_time_finalize;
  gobject_class->get_property = tim_time_get_property;
  gobject_class->set_property = tim_time_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_TIME_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_TIME_FORMATTIME,
     g_param_spec_string ("formattime",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_time_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimTimeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_time_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimTime),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_time_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimTimeType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimAreaProperties
{
  PROP_TIM_AREA_0,
  PROP_TIM_AREA_COUNTRY,
  PROP_TIM_AREA_PROVINCE,
  PROP_TIM_AREA_CITY,
  PROP_TIM_AREA_EXTRA_LIST,
  PROP_TIM_AREA_EXTRA_MAP
};

/* reads a tim_area object */
static gint32
tim_area_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimArea * this_object = TIM_AREA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->country != NULL)
          {
            g_free(this_object->country);
            this_object->country = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->country, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_country = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->province != NULL)
          {
            g_free(this_object->province);
            this_object->province = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->province, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_province = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->city != NULL)
          {
            g_free(this_object->city);
            this_object->city = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->city, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_city = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem12 = NULL;
              if ( _elem12 != NULL)
              {
                g_object_unref (_elem12);
              }
              _elem12 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem12), protocol, error)) < 0)
              {
                g_object_unref (_elem12);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key13 = NULL;
              gchar * val14 = NULL;
              if (key13 != NULL)
              {
                g_free(key13);
                key13 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key13, error)) < 0)
                return -1;
              xfer += ret;
              if (val14 != NULL)
              {
                g_free(val14);
                val14 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val14, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key13)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key13, (gpointer) val14);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_area_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimArea * this_object = TIM_AREA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimArea", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_country == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "country", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->country, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_province == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "province", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->province, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_city == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "city", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->city, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i15;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i15 = 0; i15 < (this_object->extraList ? this_object->extraList->len : 0); i15++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i15))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key16 = NULL;
      gchar * val17 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key16 = keys[i];
        val17 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key16);

        if ((ret = thrift_protocol_write_string (protocol,  key16, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val17, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_area_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimArea *self = TIM_AREA (object);

  switch (property_id)
  {
    case PROP_TIM_AREA_COUNTRY:
      if (self->country != NULL)
        g_free (self->country);
      self->country = g_value_dup_string (value);
      self->__isset_country = TRUE;
      break;

    case PROP_TIM_AREA_PROVINCE:
      if (self->province != NULL)
        g_free (self->province);
      self->province = g_value_dup_string (value);
      self->__isset_province = TRUE;
      break;

    case PROP_TIM_AREA_CITY:
      if (self->city != NULL)
        g_free (self->city);
      self->city = g_value_dup_string (value);
      self->__isset_city = TRUE;
      break;

    case PROP_TIM_AREA_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_AREA_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_area_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimArea *self = TIM_AREA (object);

  switch (property_id)
  {
    case PROP_TIM_AREA_COUNTRY:
      g_value_set_string (value, self->country);
      break;

    case PROP_TIM_AREA_PROVINCE:
      g_value_set_string (value, self->province);
      break;

    case PROP_TIM_AREA_CITY:
      g_value_set_string (value, self->city);
      break;

    case PROP_TIM_AREA_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_AREA_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_area_instance_init (TimArea * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->country = NULL;
  object->__isset_country = FALSE;
  object->province = NULL;
  object->__isset_province = FALSE;
  object->city = NULL;
  object->__isset_city = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_area_finalize (GObject *object)
{
  TimArea *tobject = TIM_AREA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->country != NULL)
  {
    g_free(tobject->country);
    tobject->country = NULL;
  }
  if (tobject->province != NULL)
  {
    g_free(tobject->province);
    tobject->province = NULL;
  }
  if (tobject->city != NULL)
  {
    g_free(tobject->city);
    tobject->city = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_area_class_init (TimAreaClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_area_read;
  struct_class->write = tim_area_write;

  gobject_class->finalize = tim_area_finalize;
  gobject_class->get_property = tim_area_get_property;
  gobject_class->set_property = tim_area_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AREA_COUNTRY,
     g_param_spec_string ("country",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AREA_PROVINCE,
     g_param_spec_string ("province",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AREA_CITY,
     g_param_spec_string ("city",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AREA_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AREA_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_area_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimAreaClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_area_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimArea),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_area_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimAreaType",
                                   &type_info, 0);
  }

  return type;
}

enum _TidProperties
{
  PROP_TID_0,
  PROP_TID_NAME,
  PROP_TID_DOMAIN,
  PROP_TID_RESOURCE,
  PROP_TID_TYPE,
  PROP_TID_EXTRA_LIST,
  PROP_TID_EXTRA_MAP
};

/* reads a tid object */
static gint32
tid_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Tid * this_object = TID(object);
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->domain != NULL)
          {
            g_free(this_object->domain);
            this_object->domain = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->domain, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_domain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->resource != NULL)
          {
            g_free(this_object->resource);
            this_object->resource = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->resource, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_resource = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->type != NULL)
          {
            g_free(this_object->type);
            this_object->type = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem18 = NULL;
              if ( _elem18 != NULL)
              {
                g_object_unref (_elem18);
              }
              _elem18 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem18), protocol, error)) < 0)
              {
                g_object_unref (_elem18);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key19 = NULL;
              gchar * val20 = NULL;
              if (key19 != NULL)
              {
                g_free(key19);
                key19 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key19, error)) < 0)
                return -1;
              xfer += ret;
              if (val20 != NULL)
              {
                g_free(val20);
                val20 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val20, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key19)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key19, (gpointer) val20);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tid_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Tid * this_object = TID(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Tid", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_domain == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "domain", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->domain, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_resource == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "resource", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->resource, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i21;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i21 = 0; i21 < (this_object->extraList ? this_object->extraList->len : 0); i21++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i21))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key22 = NULL;
      gchar * val23 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key22 = keys[i];
        val23 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key22);

        if ((ret = thrift_protocol_write_string (protocol,  key22, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val23, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tid_set_property (GObject *object,
                  guint property_id,
                  const GValue *value,
                  GParamSpec *pspec)
{
  Tid *self = TID (object);

  switch (property_id)
  {
    case PROP_TID_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    case PROP_TID_DOMAIN:
      if (self->domain != NULL)
        g_free (self->domain);
      self->domain = g_value_dup_string (value);
      self->__isset_domain = TRUE;
      break;

    case PROP_TID_RESOURCE:
      if (self->resource != NULL)
        g_free (self->resource);
      self->resource = g_value_dup_string (value);
      self->__isset_resource = TRUE;
      break;

    case PROP_TID_TYPE:
      if (self->type != NULL)
        g_free (self->type);
      self->type = g_value_dup_string (value);
      self->__isset_type = TRUE;
      break;

    case PROP_TID_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TID_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tid_get_property (GObject *object,
                  guint property_id,
                  GValue *value,
                  GParamSpec *pspec)
{
  Tid *self = TID (object);

  switch (property_id)
  {
    case PROP_TID_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_TID_DOMAIN:
      g_value_set_string (value, self->domain);
      break;

    case PROP_TID_RESOURCE:
      g_value_set_string (value, self->resource);
      break;

    case PROP_TID_TYPE:
      g_value_set_string (value, self->type);
      break;

    case PROP_TID_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TID_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tid_instance_init (Tid * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->domain = NULL;
  object->__isset_domain = FALSE;
  object->resource = NULL;
  object->__isset_resource = FALSE;
  object->type = NULL;
  object->__isset_type = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tid_finalize (GObject *object)
{
  Tid *tobject = TID (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->domain != NULL)
  {
    g_free(tobject->domain);
    tobject->domain = NULL;
  }
  if (tobject->resource != NULL)
  {
    g_free(tobject->resource);
    tobject->resource = NULL;
  }
  if (tobject->type != NULL)
  {
    g_free(tobject->type);
    tobject->type = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tid_class_init (TidClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tid_read;
  struct_class->write = tid_write;

  gobject_class->finalize = tid_finalize;
  gobject_class->get_property = tid_get_property;
  gobject_class->set_property = tid_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TID_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_DOMAIN,
     g_param_spec_string ("domain",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_RESOURCE,
     g_param_spec_string ("resource",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_TYPE,
     g_param_spec_string ("type",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TID_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tid_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TidClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tid_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Tid),
      0, /* n_preallocs */
      (GInstanceInitFunc) tid_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TidType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimUserBeanProperties
{
  PROP_TIM_USER_BEAN_0,
  PROP_TIM_USER_BEAN_TID,
  PROP_TIM_USER_BEAN_NICKNAME,
  PROP_TIM_USER_BEAN_REMARKNAME,
  PROP_TIM_USER_BEAN_BRITHDAY,
  PROP_TIM_USER_BEAN_GENDER,
  PROP_TIM_USER_BEAN_HEADURL,
  PROP_TIM_USER_BEAN_AREA,
  PROP_TIM_USER_BEAN_HEADBYTE,
  PROP_TIM_USER_BEAN_PHOTO_BYTES,
  PROP_TIM_USER_BEAN_EXTRA_LIST,
  PROP_TIM_USER_BEAN_EXTRA_MAP
};

/* reads a tim_user_bean object */
static gint32
tim_user_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimUserBean * this_object = TIM_USER_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->nickname != NULL)
          {
            g_free(this_object->nickname);
            this_object->nickname = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nickname, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nickname = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->remarkname != NULL)
          {
            g_free(this_object->remarkname);
            this_object->remarkname = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remarkname, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remarkname = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->brithday != NULL)
          {
            g_free(this_object->brithday);
            this_object->brithday = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->brithday, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_brithday = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->gender, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_gender = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->headurl != NULL)
          {
            g_free(this_object->headurl);
            this_object->headurl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->headurl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_headurl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->area), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_area = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->headbyte != NULL)
          {
            g_free(this_object->headbyte);
            this_object->headbyte = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->headbyte = g_byte_array_new();
          g_byte_array_append (this_object->headbyte, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_headbyte = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem24 = NULL;
              if (_elem24 != NULL)
              {
                g_free(_elem24);
                _elem24 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem24 = g_byte_array_new();
              g_byte_array_append (_elem24, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->photoBytes, _elem24);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_photoBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem25 = NULL;
              if ( _elem25 != NULL)
              {
                g_object_unref (_elem25);
              }
              _elem25 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem25), protocol, error)) < 0)
              {
                g_object_unref (_elem25);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem25);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key26 = NULL;
              gchar * val27 = NULL;
              if (key26 != NULL)
              {
                g_free(key26);
                key26 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key26, error)) < 0)
                return -1;
              xfer += ret;
              if (val27 != NULL)
              {
                g_free(val27);
                val27 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val27, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key26)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key26, (gpointer) val27);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_user_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimUserBean * this_object = TIM_USER_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimUserBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_tid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_nickname == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "nickname", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->nickname, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remarkname == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remarkname", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remarkname, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_brithday == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "brithday", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->brithday, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_gender == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "gender", T_I16, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->gender, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_headurl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "headurl", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->headurl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_area == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "area", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->area), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_headbyte == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "headbyte", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->headbyte ? ((GByteArray *) this_object->headbyte)->data : NULL, this_object->headbyte ? ((GByteArray *) this_object->headbyte)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_photoBytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "photoBytes", T_LIST, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i28;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->photoBytes ? this_object->photoBytes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i28 = 0; i28 < (this_object->photoBytes ? this_object->photoBytes->len : 0); i28++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->photoBytes, i28)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->photoBytes, i28)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->photoBytes, i28)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->photoBytes, i28)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i29;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i29 = 0; i29 < (this_object->extraList ? this_object->extraList->len : 0); i29++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i29))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 11, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key30 = NULL;
      gchar * val31 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key30 = keys[i];
        val31 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key30);

        if ((ret = thrift_protocol_write_string (protocol,  key30, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val31, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_user_bean_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TimUserBean *self = TIM_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_USER_BEAN_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_TIM_USER_BEAN_NICKNAME:
      if (self->nickname != NULL)
        g_free (self->nickname);
      self->nickname = g_value_dup_string (value);
      self->__isset_nickname = TRUE;
      break;

    case PROP_TIM_USER_BEAN_REMARKNAME:
      if (self->remarkname != NULL)
        g_free (self->remarkname);
      self->remarkname = g_value_dup_string (value);
      self->__isset_remarkname = TRUE;
      break;

    case PROP_TIM_USER_BEAN_BRITHDAY:
      if (self->brithday != NULL)
        g_free (self->brithday);
      self->brithday = g_value_dup_string (value);
      self->__isset_brithday = TRUE;
      break;

    case PROP_TIM_USER_BEAN_GENDER:
      self->gender = g_value_get_int (value);
      self->__isset_gender = TRUE;
      break;

    case PROP_TIM_USER_BEAN_HEADURL:
      if (self->headurl != NULL)
        g_free (self->headurl);
      self->headurl = g_value_dup_string (value);
      self->__isset_headurl = TRUE;
      break;

    case PROP_TIM_USER_BEAN_AREA:
      if (self->area != NULL)
        g_object_unref (self->area);
      self->area = g_value_dup_object (value);
      self->__isset_area = TRUE;
      break;

    case PROP_TIM_USER_BEAN_HEADBYTE:
      if (self->headbyte != NULL)
        g_byte_array_unref (self->headbyte);
      self->headbyte = g_value_dup_boxed (value);
      self->__isset_headbyte = TRUE;
      break;

    case PROP_TIM_USER_BEAN_PHOTO_BYTES:
      if (self->photoBytes != NULL)
        g_ptr_array_unref (self->photoBytes);
      self->photoBytes = g_value_dup_boxed (value);
      self->__isset_photoBytes = TRUE;
      break;

    case PROP_TIM_USER_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_USER_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_user_bean_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TimUserBean *self = TIM_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_USER_BEAN_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_TIM_USER_BEAN_NICKNAME:
      g_value_set_string (value, self->nickname);
      break;

    case PROP_TIM_USER_BEAN_REMARKNAME:
      g_value_set_string (value, self->remarkname);
      break;

    case PROP_TIM_USER_BEAN_BRITHDAY:
      g_value_set_string (value, self->brithday);
      break;

    case PROP_TIM_USER_BEAN_GENDER:
      g_value_set_int (value, self->gender);
      break;

    case PROP_TIM_USER_BEAN_HEADURL:
      g_value_set_string (value, self->headurl);
      break;

    case PROP_TIM_USER_BEAN_AREA:
      g_value_set_object (value, self->area);
      break;

    case PROP_TIM_USER_BEAN_HEADBYTE:
      g_value_set_boxed (value, self->headbyte);
      break;

    case PROP_TIM_USER_BEAN_PHOTO_BYTES:
      g_value_set_boxed (value, self->photoBytes);
      break;

    case PROP_TIM_USER_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_USER_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_user_bean_instance_init (TimUserBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->nickname = NULL;
  object->__isset_nickname = FALSE;
  object->remarkname = NULL;
  object->__isset_remarkname = FALSE;
  object->brithday = NULL;
  object->__isset_brithday = FALSE;
  object->gender = 0;
  object->__isset_gender = FALSE;
  object->headurl = NULL;
  object->__isset_headurl = FALSE;
  object->area = g_object_new (TYPE_TIM_AREA, NULL);
  object->__isset_area = FALSE;
  object->headbyte = NULL;
  object->__isset_headbyte = FALSE;
  object->photoBytes = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_photoBytes = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_user_bean_finalize (GObject *object)
{
  TimUserBean *tobject = TIM_USER_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->nickname != NULL)
  {
    g_free(tobject->nickname);
    tobject->nickname = NULL;
  }
  if (tobject->remarkname != NULL)
  {
    g_free(tobject->remarkname);
    tobject->remarkname = NULL;
  }
  if (tobject->brithday != NULL)
  {
    g_free(tobject->brithday);
    tobject->brithday = NULL;
  }
  if (tobject->headurl != NULL)
  {
    g_free(tobject->headurl);
    tobject->headurl = NULL;
  }
  if (tobject->area != NULL)
  {
    g_object_unref(tobject->area);
    tobject->area = NULL;
  }
  if (tobject->headbyte != NULL)
  {
    thrift_string_free(tobject->headbyte);
    tobject->headbyte = NULL;
  }
  if (tobject->photoBytes != NULL)
  {
    g_ptr_array_unref (tobject->photoBytes);
    tobject->photoBytes = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_user_bean_class_init (TimUserBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_user_bean_read;
  struct_class->write = tim_user_bean_write;

  gobject_class->finalize = tim_user_bean_finalize;
  gobject_class->get_property = tim_user_bean_get_property;
  gobject_class->set_property = tim_user_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_NICKNAME,
     g_param_spec_string ("nickname",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_REMARKNAME,
     g_param_spec_string ("remarkname",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_BRITHDAY,
     g_param_spec_string ("brithday",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_GENDER,
     g_param_spec_int ("gender",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_HEADURL,
     g_param_spec_string ("headurl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_AREA,
     g_param_spec_object ("area",
                         NULL,
                         NULL,
                         TYPE_TIM_AREA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_HEADBYTE,
     g_param_spec_boxed ("headbyte",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_PHOTO_BYTES,
     g_param_spec_boxed ("photoBytes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_USER_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_user_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimUserBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_user_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimUserBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_user_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimUserBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimRoomProperties
{
  PROP_TIM_ROOM_0,
  PROP_TIM_ROOM_TID,
  PROP_TIM_ROOM_FOUNDER_TID,
  PROP_TIM_ROOM_HOSTS_TID,
  PROP_TIM_ROOM_MEMBERS_TID,
  PROP_TIM_ROOM_HEADURL,
  PROP_TIM_ROOM_ROOM_NAME,
  PROP_TIM_ROOM_DESC,
  PROP_TIM_ROOM_CREATE_TIME,
  PROP_TIM_ROOM_EXTRA_LIST,
  PROP_TIM_ROOM_EXTRA_MAP
};

/* reads a tim_room object */
static gint32
tim_room_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimRoom * this_object = TIM_ROOM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->founderTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_founderTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tid * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (TYPE_TID, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->HostsTid, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_HostsTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tid * _elem33 = NULL;
              if ( _elem33 != NULL)
              {
                g_object_unref (_elem33);
              }
              _elem33 = g_object_new (TYPE_TID, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem33), protocol, error)) < 0)
              {
                g_object_unref (_elem33);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->membersTid, _elem33);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_membersTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->headurl != NULL)
          {
            g_free(this_object->headurl);
            this_object->headurl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->headurl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_headurl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->roomName != NULL)
          {
            g_free(this_object->roomName);
            this_object->roomName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->roomName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_roomName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->desc != NULL)
          {
            g_free(this_object->desc);
            this_object->desc = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->desc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_desc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->createTime), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem34 = NULL;
              if ( _elem34 != NULL)
              {
                g_object_unref (_elem34);
              }
              _elem34 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem34), protocol, error)) < 0)
              {
                g_object_unref (_elem34);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem34);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key35 = NULL;
              gchar * val36 = NULL;
              if (key35 != NULL)
              {
                g_free(key35);
                key35 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key35, error)) < 0)
                return -1;
              xfer += ret;
              if (val36 != NULL)
              {
                g_free(val36);
                val36 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val36, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key35)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key35, (gpointer) val36);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_room_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimRoom * this_object = TIM_ROOM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimRoom", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_tid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_founderTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "founderTid", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->founderTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_HostsTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "HostsTid", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i37;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->HostsTid ? this_object->HostsTid->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i37 = 0; i37 < (this_object->HostsTid ? this_object->HostsTid->len : 0); i37++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->HostsTid, i37))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_membersTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "membersTid", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i38;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->membersTid ? this_object->membersTid->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i38 = 0; i38 < (this_object->membersTid ? this_object->membersTid->len : 0); i38++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->membersTid, i38))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_headurl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "headurl", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->headurl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_roomName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomName", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->roomName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_desc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "desc", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->desc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->createTime), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i39;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i39 = 0; i39 < (this_object->extraList ? this_object->extraList->len : 0); i39++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i39))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key40 = NULL;
      gchar * val41 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key40 = keys[i];
        val41 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key40);

        if ((ret = thrift_protocol_write_string (protocol,  key40, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val41, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_room_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimRoom *self = TIM_ROOM (object);

  switch (property_id)
  {
    case PROP_TIM_ROOM_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_TIM_ROOM_FOUNDER_TID:
      if (self->founderTid != NULL)
        g_object_unref (self->founderTid);
      self->founderTid = g_value_dup_object (value);
      self->__isset_founderTid = TRUE;
      break;

    case PROP_TIM_ROOM_HOSTS_TID:
      if (self->HostsTid != NULL)
        g_ptr_array_unref (self->HostsTid);
      self->HostsTid = g_value_dup_boxed (value);
      self->__isset_HostsTid = TRUE;
      break;

    case PROP_TIM_ROOM_MEMBERS_TID:
      if (self->membersTid != NULL)
        g_ptr_array_unref (self->membersTid);
      self->membersTid = g_value_dup_boxed (value);
      self->__isset_membersTid = TRUE;
      break;

    case PROP_TIM_ROOM_HEADURL:
      if (self->headurl != NULL)
        g_free (self->headurl);
      self->headurl = g_value_dup_string (value);
      self->__isset_headurl = TRUE;
      break;

    case PROP_TIM_ROOM_ROOM_NAME:
      if (self->roomName != NULL)
        g_free (self->roomName);
      self->roomName = g_value_dup_string (value);
      self->__isset_roomName = TRUE;
      break;

    case PROP_TIM_ROOM_DESC:
      if (self->desc != NULL)
        g_free (self->desc);
      self->desc = g_value_dup_string (value);
      self->__isset_desc = TRUE;
      break;

    case PROP_TIM_ROOM_CREATE_TIME:
      if (self->createTime != NULL)
        g_object_unref (self->createTime);
      self->createTime = g_value_dup_object (value);
      self->__isset_createTime = TRUE;
      break;

    case PROP_TIM_ROOM_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_ROOM_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_room_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimRoom *self = TIM_ROOM (object);

  switch (property_id)
  {
    case PROP_TIM_ROOM_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_TIM_ROOM_FOUNDER_TID:
      g_value_set_object (value, self->founderTid);
      break;

    case PROP_TIM_ROOM_HOSTS_TID:
      g_value_set_boxed (value, self->HostsTid);
      break;

    case PROP_TIM_ROOM_MEMBERS_TID:
      g_value_set_boxed (value, self->membersTid);
      break;

    case PROP_TIM_ROOM_HEADURL:
      g_value_set_string (value, self->headurl);
      break;

    case PROP_TIM_ROOM_ROOM_NAME:
      g_value_set_string (value, self->roomName);
      break;

    case PROP_TIM_ROOM_DESC:
      g_value_set_string (value, self->desc);
      break;

    case PROP_TIM_ROOM_CREATE_TIME:
      g_value_set_object (value, self->createTime);
      break;

    case PROP_TIM_ROOM_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_ROOM_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_room_instance_init (TimRoom * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->founderTid = g_object_new (TYPE_TID, NULL);
  object->__isset_founderTid = FALSE;
  object->HostsTid = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_HostsTid = FALSE;
  object->membersTid = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_membersTid = FALSE;
  object->headurl = NULL;
  object->__isset_headurl = FALSE;
  object->roomName = NULL;
  object->__isset_roomName = FALSE;
  object->desc = NULL;
  object->__isset_desc = FALSE;
  object->createTime = g_object_new (TYPE_TIM_TIME, NULL);
  object->__isset_createTime = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_room_finalize (GObject *object)
{
  TimRoom *tobject = TIM_ROOM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->founderTid != NULL)
  {
    g_object_unref(tobject->founderTid);
    tobject->founderTid = NULL;
  }
  if (tobject->HostsTid != NULL)
  {
    g_ptr_array_unref (tobject->HostsTid);
    tobject->HostsTid = NULL;
  }
  if (tobject->membersTid != NULL)
  {
    g_ptr_array_unref (tobject->membersTid);
    tobject->membersTid = NULL;
  }
  if (tobject->headurl != NULL)
  {
    g_free(tobject->headurl);
    tobject->headurl = NULL;
  }
  if (tobject->roomName != NULL)
  {
    g_free(tobject->roomName);
    tobject->roomName = NULL;
  }
  if (tobject->desc != NULL)
  {
    g_free(tobject->desc);
    tobject->desc = NULL;
  }
  if (tobject->createTime != NULL)
  {
    g_object_unref(tobject->createTime);
    tobject->createTime = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_room_class_init (TimRoomClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_room_read;
  struct_class->write = tim_room_write;

  gobject_class->finalize = tim_room_finalize;
  gobject_class->get_property = tim_room_get_property;
  gobject_class->set_property = tim_room_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_FOUNDER_TID,
     g_param_spec_object ("founderTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_HOSTS_TID,
     g_param_spec_boxed ("HostsTid",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_MEMBERS_TID,
     g_param_spec_boxed ("membersTid",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_HEADURL,
     g_param_spec_string ("headurl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_ROOM_NAME,
     g_param_spec_string ("roomName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_DESC,
     g_param_spec_string ("desc",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_CREATE_TIME,
     g_param_spec_object ("createTime",
                         NULL,
                         NULL,
                         TYPE_TIM_TIME,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROOM_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_room_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimRoomClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_room_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimRoom),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_room_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimRoomType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimPBeanProperties
{
  PROP_TIM_P_BEAN_0,
  PROP_TIM_P_BEAN_THREAD_ID,
  PROP_TIM_P_BEAN_FROM_TID,
  PROP_TIM_P_BEAN_TO_TID,
  PROP_TIM_P_BEAN_STATUS,
  PROP_TIM_P_BEAN_TYPE,
  PROP_TIM_P_BEAN_PRIORITY,
  PROP_TIM_P_BEAN_SHOW,
  PROP_TIM_P_BEAN_LEAGUER_TID,
  PROP_TIM_P_BEAN_EXTRA_LIST,
  PROP_TIM_P_BEAN_ERROR,
  PROP_TIM_P_BEAN_EXTRA_MAP
};

/* reads a tim_p_bean object */
static gint32
tim_p_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimPBean * this_object = TIM_P_BEAN(object);
  gboolean isset_threadId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->status != NULL)
          {
            g_free(this_object->status);
            this_object->status = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->status, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->type != NULL)
          {
            g_free(this_object->type);
            this_object->type = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->priority, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_priority = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->show != NULL)
          {
            g_free(this_object->show);
            this_object->show = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->show, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_show = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->leaguerTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_leaguerTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem42 = NULL;
              if ( _elem42 != NULL)
              {
                g_object_unref (_elem42);
              }
              _elem42 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem42), protocol, error)) < 0)
              {
                g_object_unref (_elem42);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem42);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key43 = NULL;
              gchar * val44 = NULL;
              if (key43 != NULL)
              {
                g_free(key43);
                key43 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key43, error)) < 0)
                return -1;
              xfer += ret;
              if (val44 != NULL)
              {
                g_free(val44);
                val44 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val44, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key43)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key43, (gpointer) val44);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_threadId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_p_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimPBean * this_object = TIM_P_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimPBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_fromTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_status == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->status, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_priority == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "priority", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->priority, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_show == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "show", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->show, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_leaguerTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "leaguerTid", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->leaguerTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i45;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i45 = 0; i45 < (this_object->extraList ? this_object->extraList->len : 0); i45++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i45))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 11, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key46 = NULL;
      gchar * val47 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key46 = keys[i];
        val47 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key46);

        if ((ret = thrift_protocol_write_string (protocol,  key46, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val47, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_p_bean_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TimPBean *self = TIM_P_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_P_BEAN_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      break;

    case PROP_TIM_P_BEAN_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      self->__isset_fromTid = TRUE;
      break;

    case PROP_TIM_P_BEAN_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      self->__isset_toTid = TRUE;
      break;

    case PROP_TIM_P_BEAN_STATUS:
      if (self->status != NULL)
        g_free (self->status);
      self->status = g_value_dup_string (value);
      self->__isset_status = TRUE;
      break;

    case PROP_TIM_P_BEAN_TYPE:
      if (self->type != NULL)
        g_free (self->type);
      self->type = g_value_dup_string (value);
      self->__isset_type = TRUE;
      break;

    case PROP_TIM_P_BEAN_PRIORITY:
      self->priority = g_value_get_int (value);
      self->__isset_priority = TRUE;
      break;

    case PROP_TIM_P_BEAN_SHOW:
      if (self->show != NULL)
        g_free (self->show);
      self->show = g_value_dup_string (value);
      self->__isset_show = TRUE;
      break;

    case PROP_TIM_P_BEAN_LEAGUER_TID:
      if (self->leaguerTid != NULL)
        g_object_unref (self->leaguerTid);
      self->leaguerTid = g_value_dup_object (value);
      self->__isset_leaguerTid = TRUE;
      break;

    case PROP_TIM_P_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_P_BEAN_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_P_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_p_bean_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TimPBean *self = TIM_P_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_P_BEAN_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_P_BEAN_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_P_BEAN_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_P_BEAN_STATUS:
      g_value_set_string (value, self->status);
      break;

    case PROP_TIM_P_BEAN_TYPE:
      g_value_set_string (value, self->type);
      break;

    case PROP_TIM_P_BEAN_PRIORITY:
      g_value_set_int (value, self->priority);
      break;

    case PROP_TIM_P_BEAN_SHOW:
      g_value_set_string (value, self->show);
      break;

    case PROP_TIM_P_BEAN_LEAGUER_TID:
      g_value_set_object (value, self->leaguerTid);
      break;

    case PROP_TIM_P_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_P_BEAN_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_P_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_p_bean_instance_init (TimPBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->__isset_fromTid = FALSE;
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->__isset_toTid = FALSE;
  object->status = NULL;
  object->__isset_status = FALSE;
  object->type = NULL;
  object->__isset_type = FALSE;
  object->priority = 0;
  object->__isset_priority = FALSE;
  object->show = NULL;
  object->__isset_show = FALSE;
  object->leaguerTid = g_object_new (TYPE_TID, NULL);
  object->__isset_leaguerTid = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_p_bean_finalize (GObject *object)
{
  TimPBean *tobject = TIM_P_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->status != NULL)
  {
    g_free(tobject->status);
    tobject->status = NULL;
  }
  if (tobject->type != NULL)
  {
    g_free(tobject->type);
    tobject->type = NULL;
  }
  if (tobject->show != NULL)
  {
    g_free(tobject->show);
    tobject->show = NULL;
  }
  if (tobject->leaguerTid != NULL)
  {
    g_object_unref(tobject->leaguerTid);
    tobject->leaguerTid = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_p_bean_class_init (TimPBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_p_bean_read;
  struct_class->write = tim_p_bean_write;

  gobject_class->finalize = tim_p_bean_finalize;
  gobject_class->get_property = tim_p_bean_get_property;
  gobject_class->set_property = tim_p_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_STATUS,
     g_param_spec_string ("status",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_TYPE,
     g_param_spec_string ("type",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_PRIORITY,
     g_param_spec_int ("priority",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_SHOW,
     g_param_spec_string ("show",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_LEAGUER_TID,
     g_param_spec_object ("leaguerTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_p_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimPBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_p_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimPBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_p_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimPBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimMBeanProperties
{
  PROP_TIM_M_BEAN_0,
  PROP_TIM_M_BEAN_THREAD_ID,
  PROP_TIM_M_BEAN_MID,
  PROP_TIM_M_BEAN_FROM_TID,
  PROP_TIM_M_BEAN_TO_TID,
  PROP_TIM_M_BEAN_BODY,
  PROP_TIM_M_BEAN_TYPE,
  PROP_TIM_M_BEAN_MSG_TYPE,
  PROP_TIM_M_BEAN_OFFLINE,
  PROP_TIM_M_BEAN_LEAGUER_TID,
  PROP_TIM_M_BEAN_EXTRA_LIST,
  PROP_TIM_M_BEAN_TIMESTAMP,
  PROP_TIM_M_BEAN_ERROR,
  PROP_TIM_M_BEAN_EXTRA_MAP,
  PROP_TIM_M_BEAN_READSTATUS
};

/* reads a tim_m_bean object */
static gint32
tim_m_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimMBean * this_object = TIM_M_BEAN(object);
  gboolean isset_threadId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->mid != NULL)
          {
            g_free(this_object->mid);
            this_object->mid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->body != NULL)
          {
            g_free(this_object->body);
            this_object->body = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->body, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_body = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->type != NULL)
          {
            g_free(this_object->type);
            this_object->type = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->msgType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_msgType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->offline), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_offline = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->leaguerTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_leaguerTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem48 = NULL;
              if ( _elem48 != NULL)
              {
                g_object_unref (_elem48);
              }
              _elem48 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem48), protocol, error)) < 0)
              {
                g_object_unref (_elem48);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key49 = NULL;
              gchar * val50 = NULL;
              if (key49 != NULL)
              {
                g_free(key49);
                key49 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key49, error)) < 0)
                return -1;
              xfer += ret;
              if (val50 != NULL)
              {
                g_free(val50);
                val50 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val50, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key49)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key49, (gpointer) val50);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->readstatus, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_readstatus = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_threadId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_m_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimMBean * this_object = TIM_M_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimMBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_mid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->mid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fromTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_body == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "body", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->body, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_msgType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "msgType", T_I16, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->msgType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offline == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offline", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->offline), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_leaguerTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "leaguerTid", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->leaguerTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i51;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i51 = 0; i51 < (this_object->extraList ? this_object->extraList->len : 0); i51++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i51))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key52 = NULL;
      gchar * val53 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key52 = keys[i];
        val53 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key52);

        if ((ret = thrift_protocol_write_string (protocol,  key52, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val53, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_readstatus == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "readstatus", T_I16, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->readstatus, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_m_bean_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TimMBean *self = TIM_M_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_M_BEAN_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      break;

    case PROP_TIM_M_BEAN_MID:
      if (self->mid != NULL)
        g_free (self->mid);
      self->mid = g_value_dup_string (value);
      self->__isset_mid = TRUE;
      break;

    case PROP_TIM_M_BEAN_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      self->__isset_fromTid = TRUE;
      break;

    case PROP_TIM_M_BEAN_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      self->__isset_toTid = TRUE;
      break;

    case PROP_TIM_M_BEAN_BODY:
      if (self->body != NULL)
        g_free (self->body);
      self->body = g_value_dup_string (value);
      self->__isset_body = TRUE;
      break;

    case PROP_TIM_M_BEAN_TYPE:
      if (self->type != NULL)
        g_free (self->type);
      self->type = g_value_dup_string (value);
      self->__isset_type = TRUE;
      break;

    case PROP_TIM_M_BEAN_MSG_TYPE:
      self->msgType = g_value_get_int (value);
      self->__isset_msgType = TRUE;
      break;

    case PROP_TIM_M_BEAN_OFFLINE:
      if (self->offline != NULL)
        g_object_unref (self->offline);
      self->offline = g_value_dup_object (value);
      self->__isset_offline = TRUE;
      break;

    case PROP_TIM_M_BEAN_LEAGUER_TID:
      if (self->leaguerTid != NULL)
        g_object_unref (self->leaguerTid);
      self->leaguerTid = g_value_dup_object (value);
      self->__isset_leaguerTid = TRUE;
      break;

    case PROP_TIM_M_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_M_BEAN_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_TIM_M_BEAN_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_M_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    case PROP_TIM_M_BEAN_READSTATUS:
      self->readstatus = g_value_get_int (value);
      self->__isset_readstatus = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_m_bean_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TimMBean *self = TIM_M_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_M_BEAN_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_M_BEAN_MID:
      g_value_set_string (value, self->mid);
      break;

    case PROP_TIM_M_BEAN_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_M_BEAN_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_M_BEAN_BODY:
      g_value_set_string (value, self->body);
      break;

    case PROP_TIM_M_BEAN_TYPE:
      g_value_set_string (value, self->type);
      break;

    case PROP_TIM_M_BEAN_MSG_TYPE:
      g_value_set_int (value, self->msgType);
      break;

    case PROP_TIM_M_BEAN_OFFLINE:
      g_value_set_object (value, self->offline);
      break;

    case PROP_TIM_M_BEAN_LEAGUER_TID:
      g_value_set_object (value, self->leaguerTid);
      break;

    case PROP_TIM_M_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_M_BEAN_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    case PROP_TIM_M_BEAN_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_M_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    case PROP_TIM_M_BEAN_READSTATUS:
      g_value_set_int (value, self->readstatus);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_m_bean_instance_init (TimMBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->mid = NULL;
  object->__isset_mid = FALSE;
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->__isset_fromTid = FALSE;
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->__isset_toTid = FALSE;
  object->body = NULL;
  object->__isset_body = FALSE;
  object->type = NULL;
  object->__isset_type = FALSE;
  object->msgType = 0;
  object->__isset_msgType = FALSE;
  object->offline = g_object_new (TYPE_TIM_TIME, NULL);
  object->__isset_offline = FALSE;
  object->leaguerTid = g_object_new (TYPE_TID, NULL);
  object->__isset_leaguerTid = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
  object->readstatus = 0;
  object->__isset_readstatus = FALSE;
}

static void 
tim_m_bean_finalize (GObject *object)
{
  TimMBean *tobject = TIM_M_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->mid != NULL)
  {
    g_free(tobject->mid);
    tobject->mid = NULL;
  }
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->body != NULL)
  {
    g_free(tobject->body);
    tobject->body = NULL;
  }
  if (tobject->type != NULL)
  {
    g_free(tobject->type);
    tobject->type = NULL;
  }
  if (tobject->offline != NULL)
  {
    g_object_unref(tobject->offline);
    tobject->offline = NULL;
  }
  if (tobject->leaguerTid != NULL)
  {
    g_object_unref(tobject->leaguerTid);
    tobject->leaguerTid = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_m_bean_class_init (TimMBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_m_bean_read;
  struct_class->write = tim_m_bean_write;

  gobject_class->finalize = tim_m_bean_finalize;
  gobject_class->get_property = tim_m_bean_get_property;
  gobject_class->set_property = tim_m_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_MID,
     g_param_spec_string ("mid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_BODY,
     g_param_spec_string ("body",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_TYPE,
     g_param_spec_string ("type",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_MSG_TYPE,
     g_param_spec_int ("msgType",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_OFFLINE,
     g_param_spec_object ("offline",
                         NULL,
                         NULL,
                         TYPE_TIM_TIME,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_LEAGUER_TID,
     g_param_spec_object ("leaguerTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_READSTATUS,
     g_param_spec_int ("readstatus",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
tim_m_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimMBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_m_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimMBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_m_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimMBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimIqBeanProperties
{
  PROP_TIM_IQ_BEAN_0,
  PROP_TIM_IQ_BEAN_THREAD_ID,
  PROP_TIM_IQ_BEAN_FROM_TID,
  PROP_TIM_IQ_BEAN_TO_TID,
  PROP_TIM_IQ_BEAN_TYPE,
  PROP_TIM_IQ_BEAN_EXTRA_LIST,
  PROP_TIM_IQ_BEAN_ERROR,
  PROP_TIM_IQ_BEAN_EXTRA_MAP
};

/* reads a tim_iq_bean object */
static gint32
tim_iq_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimIqBean * this_object = TIM_IQ_BEAN(object);
  gboolean isset_threadId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->type != NULL)
          {
            g_free(this_object->type);
            this_object->type = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem54 = NULL;
              if ( _elem54 != NULL)
              {
                g_object_unref (_elem54);
              }
              _elem54 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem54), protocol, error)) < 0)
              {
                g_object_unref (_elem54);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key55 = NULL;
              gchar * val56 = NULL;
              if (key55 != NULL)
              {
                g_free(key55);
                key55 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key55, error)) < 0)
                return -1;
              xfer += ret;
              if (val56 != NULL)
              {
                g_free(val56);
                val56 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val56, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key55)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key55, (gpointer) val56);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_threadId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_iq_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimIqBean * this_object = TIM_IQ_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimIqBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_fromTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i57;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i57 = 0; i57 < (this_object->extraList ? this_object->extraList->len : 0); i57++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i57))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key58 = NULL;
      gchar * val59 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key58 = keys[i];
        val59 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key58);

        if ((ret = thrift_protocol_write_string (protocol,  key58, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val59, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_iq_bean_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TimIqBean *self = TIM_IQ_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_IQ_BEAN_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      break;

    case PROP_TIM_IQ_BEAN_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      self->__isset_fromTid = TRUE;
      break;

    case PROP_TIM_IQ_BEAN_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      self->__isset_toTid = TRUE;
      break;

    case PROP_TIM_IQ_BEAN_TYPE:
      if (self->type != NULL)
        g_free (self->type);
      self->type = g_value_dup_string (value);
      self->__isset_type = TRUE;
      break;

    case PROP_TIM_IQ_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_IQ_BEAN_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_IQ_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_iq_bean_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TimIqBean *self = TIM_IQ_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_IQ_BEAN_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_IQ_BEAN_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_IQ_BEAN_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_IQ_BEAN_TYPE:
      g_value_set_string (value, self->type);
      break;

    case PROP_TIM_IQ_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_IQ_BEAN_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_IQ_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_iq_bean_instance_init (TimIqBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->__isset_fromTid = FALSE;
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->__isset_toTid = FALSE;
  object->type = NULL;
  object->__isset_type = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_iq_bean_finalize (GObject *object)
{
  TimIqBean *tobject = TIM_IQ_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->type != NULL)
  {
    g_free(tobject->type);
    tobject->type = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_iq_bean_class_init (TimIqBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_iq_bean_read;
  struct_class->write = tim_iq_bean_write;

  gobject_class->finalize = tim_iq_bean_finalize;
  gobject_class->get_property = tim_iq_bean_get_property;
  gobject_class->set_property = tim_iq_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_TYPE,
     g_param_spec_string ("type",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_IQ_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_iq_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimIqBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_iq_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimIqBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_iq_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimIqBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimRosterProperties
{
  PROP_TIM_ROSTER_0,
  PROP_TIM_ROSTER_SUBSCRIPTION,
  PROP_TIM_ROSTER_TID,
  PROP_TIM_ROSTER_NAME,
  PROP_TIM_ROSTER_EXTRA_MAP
};

/* reads a tim_roster object */
static gint32
tim_roster_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimRoster * this_object = TIM_ROSTER(object);
  gboolean isset_subscription = FALSE;
  gboolean isset_tid = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->subscription != NULL)
          {
            g_free(this_object->subscription);
            this_object->subscription = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->subscription, error)) < 0)
            return -1;
          xfer += ret;
          isset_subscription = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key60 = NULL;
              gchar * val61 = NULL;
              if (key60 != NULL)
              {
                g_free(key60);
                key60 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key60, error)) < 0)
                return -1;
              xfer += ret;
              if (val61 != NULL)
              {
                g_free(val61);
                val61 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val61, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key60)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key60, (gpointer) val61);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_subscription)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_roster_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimRoster * this_object = TIM_ROSTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimRoster", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "subscription", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->subscription, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key62 = NULL;
      gchar * val63 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key62 = keys[i];
        val63 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key62);

        if ((ret = thrift_protocol_write_string (protocol,  key62, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val63, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_roster_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TimRoster *self = TIM_ROSTER (object);

  switch (property_id)
  {
    case PROP_TIM_ROSTER_SUBSCRIPTION:
      if (self->subscription != NULL)
        g_free (self->subscription);
      self->subscription = g_value_dup_string (value);
      break;

    case PROP_TIM_ROSTER_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      break;

    case PROP_TIM_ROSTER_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_TIM_ROSTER_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_roster_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TimRoster *self = TIM_ROSTER (object);

  switch (property_id)
  {
    case PROP_TIM_ROSTER_SUBSCRIPTION:
      g_value_set_string (value, self->subscription);
      break;

    case PROP_TIM_ROSTER_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_TIM_ROSTER_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_TIM_ROSTER_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_roster_instance_init (TimRoster * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->subscription = NULL;
  object->tid = g_object_new (TYPE_TID, NULL);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_roster_finalize (GObject *object)
{
  TimRoster *tobject = TIM_ROSTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->subscription != NULL)
  {
    g_free(tobject->subscription);
    tobject->subscription = NULL;
  }
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_roster_class_init (TimRosterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_roster_read;
  struct_class->write = tim_roster_write;

  gobject_class->finalize = tim_roster_finalize;
  gobject_class->get_property = tim_roster_get_property;
  gobject_class->set_property = tim_roster_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROSTER_SUBSCRIPTION,
     g_param_spec_string ("subscription",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROSTER_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROSTER_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_ROSTER_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_roster_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimRosterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_roster_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimRoster),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_roster_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimRosterType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimRemoteUserBeanProperties
{
  PROP_TIM_REMOTE_USER_BEAN_0,
  PROP_TIM_REMOTE_USER_BEAN_ERROR,
  PROP_TIM_REMOTE_USER_BEAN_UB,
  PROP_TIM_REMOTE_USER_BEAN_EXTRA_MAP
};

/* reads a tim_remote_user_bean object */
static gint32
tim_remote_user_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimRemoteUserBean * this_object = TIM_REMOTE_USER_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ub), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key64 = NULL;
              gchar * val65 = NULL;
              if (key64 != NULL)
              {
                g_free(key64);
                key64 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key64, error)) < 0)
                return -1;
              xfer += ret;
              if (val65 != NULL)
              {
                g_free(val65);
                val65 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val65, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key64)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key64, (gpointer) val65);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_remote_user_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimRemoteUserBean * this_object = TIM_REMOTE_USER_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimRemoteUserBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ub == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ub", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ub), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key66 = NULL;
      gchar * val67 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key66 = keys[i];
        val67 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key66);

        if ((ret = thrift_protocol_write_string (protocol,  key66, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val67, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_remote_user_bean_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  TimRemoteUserBean *self = TIM_REMOTE_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_REMOTE_USER_BEAN_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_REMOTE_USER_BEAN_UB:
      if (self->ub != NULL)
        g_object_unref (self->ub);
      self->ub = g_value_dup_object (value);
      self->__isset_ub = TRUE;
      break;

    case PROP_TIM_REMOTE_USER_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_remote_user_bean_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  TimRemoteUserBean *self = TIM_REMOTE_USER_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_REMOTE_USER_BEAN_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_REMOTE_USER_BEAN_UB:
      g_value_set_object (value, self->ub);
      break;

    case PROP_TIM_REMOTE_USER_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_remote_user_bean_instance_init (TimRemoteUserBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->ub = g_object_new (TYPE_TIM_USER_BEAN, NULL);
  object->__isset_ub = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_remote_user_bean_finalize (GObject *object)
{
  TimRemoteUserBean *tobject = TIM_REMOTE_USER_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->ub != NULL)
  {
    g_object_unref(tobject->ub);
    tobject->ub = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_remote_user_bean_class_init (TimRemoteUserBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_remote_user_bean_read;
  struct_class->write = tim_remote_user_bean_write;

  gobject_class->finalize = tim_remote_user_bean_finalize;
  gobject_class->get_property = tim_remote_user_bean_get_property;
  gobject_class->set_property = tim_remote_user_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_USER_BEAN_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_USER_BEAN_UB,
     g_param_spec_object ("ub",
                         NULL,
                         NULL,
                         TYPE_TIM_USER_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_USER_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_remote_user_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimRemoteUserBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_remote_user_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimRemoteUserBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_remote_user_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimRemoteUserBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimRemoteRoomProperties
{
  PROP_TIM_REMOTE_ROOM_0,
  PROP_TIM_REMOTE_ROOM_ERROR,
  PROP_TIM_REMOTE_ROOM_ROOM,
  PROP_TIM_REMOTE_ROOM_EXTRA_MAP
};

/* reads a tim_remote_room object */
static gint32
tim_remote_room_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimRemoteRoom * this_object = TIM_REMOTE_ROOM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->room), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_room = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key68 = NULL;
              gchar * val69 = NULL;
              if (key68 != NULL)
              {
                g_free(key68);
                key68 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key68, error)) < 0)
                return -1;
              xfer += ret;
              if (val69 != NULL)
              {
                g_free(val69);
                val69 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val69, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key68)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key68, (gpointer) val69);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_remote_room_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimRemoteRoom * this_object = TIM_REMOTE_ROOM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimRemoteRoom", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_room == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "room", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->room), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key70 = NULL;
      gchar * val71 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key70 = keys[i];
        val71 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key70);

        if ((ret = thrift_protocol_write_string (protocol,  key70, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val71, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_remote_room_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TimRemoteRoom *self = TIM_REMOTE_ROOM (object);

  switch (property_id)
  {
    case PROP_TIM_REMOTE_ROOM_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_REMOTE_ROOM_ROOM:
      if (self->room != NULL)
        g_object_unref (self->room);
      self->room = g_value_dup_object (value);
      self->__isset_room = TRUE;
      break;

    case PROP_TIM_REMOTE_ROOM_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_remote_room_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TimRemoteRoom *self = TIM_REMOTE_ROOM (object);

  switch (property_id)
  {
    case PROP_TIM_REMOTE_ROOM_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_REMOTE_ROOM_ROOM:
      g_value_set_object (value, self->room);
      break;

    case PROP_TIM_REMOTE_ROOM_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_remote_room_instance_init (TimRemoteRoom * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->room = g_object_new (TYPE_TIM_ROOM, NULL);
  object->__isset_room = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_remote_room_finalize (GObject *object)
{
  TimRemoteRoom *tobject = TIM_REMOTE_ROOM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->room != NULL)
  {
    g_object_unref(tobject->room);
    tobject->room = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_remote_room_class_init (TimRemoteRoomClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_remote_room_read;
  struct_class->write = tim_remote_room_write;

  gobject_class->finalize = tim_remote_room_finalize;
  gobject_class->get_property = tim_remote_room_get_property;
  gobject_class->set_property = tim_remote_room_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_ROOM_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_ROOM_ROOM,
     g_param_spec_object ("room",
                         NULL,
                         NULL,
                         TYPE_TIM_ROOM,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_REMOTE_ROOM_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_remote_room_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimRemoteRoomClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_remote_room_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimRemoteRoom),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_remote_room_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimRemoteRoomType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimResponseBeanProperties
{
  PROP_TIM_RESPONSE_BEAN_0,
  PROP_TIM_RESPONSE_BEAN_THREAD_ID,
  PROP_TIM_RESPONSE_BEAN_ERROR,
  PROP_TIM_RESPONSE_BEAN_EXTRA_LIST,
  PROP_TIM_RESPONSE_BEAN_EXTRA_MAP
};

/* reads a tim_response_bean object */
static gint32
tim_response_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimResponseBean * this_object = TIM_RESPONSE_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimNode * _elem72 = NULL;
              if ( _elem72 != NULL)
              {
                g_object_unref (_elem72);
              }
              _elem72 = g_object_new (TYPE_TIM_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem72), protocol, error)) < 0)
              {
                g_object_unref (_elem72);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->extraList, _elem72);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key73 = NULL;
              gchar * val74 = NULL;
              if (key73 != NULL)
              {
                g_free(key73);
                key73 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key73, error)) < 0)
                return -1;
              xfer += ret;
              if (val74 != NULL)
              {
                g_free(val74);
                val74 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val74, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key73)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key73, (gpointer) val74);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_response_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimResponseBean * this_object = TIM_RESPONSE_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimResponseBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_threadId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraList", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i75;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->extraList ? this_object->extraList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i75 = 0; i75 < (this_object->extraList ? this_object->extraList->len : 0); i75++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->extraList, i75))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key76 = NULL;
      gchar * val77 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key76 = keys[i];
        val77 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key76);

        if ((ret = thrift_protocol_write_string (protocol,  key76, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val77, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_response_bean_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TimResponseBean *self = TIM_RESPONSE_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_RESPONSE_BEAN_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      self->__isset_threadId = TRUE;
      break;

    case PROP_TIM_RESPONSE_BEAN_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    case PROP_TIM_RESPONSE_BEAN_EXTRA_LIST:
      if (self->extraList != NULL)
        g_ptr_array_unref (self->extraList);
      self->extraList = g_value_dup_boxed (value);
      self->__isset_extraList = TRUE;
      break;

    case PROP_TIM_RESPONSE_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_response_bean_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TimResponseBean *self = TIM_RESPONSE_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_RESPONSE_BEAN_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_RESPONSE_BEAN_ERROR:
      g_value_set_object (value, self->error);
      break;

    case PROP_TIM_RESPONSE_BEAN_EXTRA_LIST:
      g_value_set_boxed (value, self->extraList);
      break;

    case PROP_TIM_RESPONSE_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_response_bean_instance_init (TimResponseBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->__isset_threadId = FALSE;
  object->error = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_error = FALSE;
  object->extraList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_extraList = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_response_bean_finalize (GObject *object)
{
  TimResponseBean *tobject = TIM_RESPONSE_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
  if (tobject->extraList != NULL)
  {
    g_ptr_array_unref (tobject->extraList);
    tobject->extraList = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_response_bean_class_init (TimResponseBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_response_bean_read;
  struct_class->write = tim_response_bean_write;

  gobject_class->finalize = tim_response_bean_finalize;
  gobject_class->get_property = tim_response_bean_get_property;
  gobject_class->set_property = tim_response_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_RESPONSE_BEAN_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_RESPONSE_BEAN_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_RESPONSE_BEAN_EXTRA_LIST,
     g_param_spec_boxed ("extraList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_RESPONSE_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_response_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimResponseBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_response_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimResponseBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_response_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimResponseBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimSock5BeanProperties
{
  PROP_TIM_SOCK5_BEAN_0,
  PROP_TIM_SOCK5_BEAN_FROM_TID,
  PROP_TIM_SOCK5_BEAN_TO_TID,
  PROP_TIM_SOCK5_BEAN_ADDR,
  PROP_TIM_SOCK5_BEAN_PORT,
  PROP_TIM_SOCK5_BEAN_TRANSPORT,
  PROP_TIM_SOCK5_BEAN_PUB_ID,
  PROP_TIM_SOCK5_BEAN_EXTRA_MAP
};

/* reads a tim_sock5_bean object */
static gint32
tim_sock5_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimSock5Bean * this_object = TIM_SOCK5_BEAN(object);
  gboolean isset_fromTid = FALSE;
  gboolean isset_toTid = FALSE;
  gboolean isset_addr = FALSE;
  gboolean isset_port = FALSE;
  gboolean isset_transport = FALSE;
  gboolean isset_pubId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_fromTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_toTid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->addr != NULL)
          {
            g_free(this_object->addr);
            this_object->addr = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->addr, error)) < 0)
            return -1;
          xfer += ret;
          isset_addr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->transport, error)) < 0)
            return -1;
          xfer += ret;
          isset_transport = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->pubId != NULL)
          {
            g_free(this_object->pubId);
            this_object->pubId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pubId, error)) < 0)
            return -1;
          xfer += ret;
          isset_pubId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key78 = NULL;
              gchar * val79 = NULL;
              if (key78 != NULL)
              {
                g_free(key78);
                key78 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key78, error)) < 0)
                return -1;
              xfer += ret;
              if (val79 != NULL)
              {
                g_free(val79);
                val79 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val79, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key78)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key78, (gpointer) val79);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_fromTid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_toTid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_addr)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_port)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_transport)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_pubId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_sock5_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimSock5Bean * this_object = TIM_SOCK5_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimSock5Bean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fromTid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fromTid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "toTid", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->toTid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "addr", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->addr, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "transport", T_I16, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->transport, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pubId", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->pubId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key80 = NULL;
      gchar * val81 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key80 = keys[i];
        val81 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key80);

        if ((ret = thrift_protocol_write_string (protocol,  key80, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val81, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_sock5_bean_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TimSock5Bean *self = TIM_SOCK5_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_SOCK5_BEAN_FROM_TID:
      if (self->fromTid != NULL)
        g_object_unref (self->fromTid);
      self->fromTid = g_value_dup_object (value);
      break;

    case PROP_TIM_SOCK5_BEAN_TO_TID:
      if (self->toTid != NULL)
        g_object_unref (self->toTid);
      self->toTid = g_value_dup_object (value);
      break;

    case PROP_TIM_SOCK5_BEAN_ADDR:
      if (self->addr != NULL)
        g_free (self->addr);
      self->addr = g_value_dup_string (value);
      break;

    case PROP_TIM_SOCK5_BEAN_PORT:
      self->port = g_value_get_int (value);
      break;

    case PROP_TIM_SOCK5_BEAN_TRANSPORT:
      self->transport = g_value_get_int (value);
      break;

    case PROP_TIM_SOCK5_BEAN_PUB_ID:
      if (self->pubId != NULL)
        g_free (self->pubId);
      self->pubId = g_value_dup_string (value);
      break;

    case PROP_TIM_SOCK5_BEAN_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_sock5_bean_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TimSock5Bean *self = TIM_SOCK5_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_SOCK5_BEAN_FROM_TID:
      g_value_set_object (value, self->fromTid);
      break;

    case PROP_TIM_SOCK5_BEAN_TO_TID:
      g_value_set_object (value, self->toTid);
      break;

    case PROP_TIM_SOCK5_BEAN_ADDR:
      g_value_set_string (value, self->addr);
      break;

    case PROP_TIM_SOCK5_BEAN_PORT:
      g_value_set_int (value, self->port);
      break;

    case PROP_TIM_SOCK5_BEAN_TRANSPORT:
      g_value_set_int (value, self->transport);
      break;

    case PROP_TIM_SOCK5_BEAN_PUB_ID:
      g_value_set_string (value, self->pubId);
      break;

    case PROP_TIM_SOCK5_BEAN_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_sock5_bean_instance_init (TimSock5Bean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->fromTid = g_object_new (TYPE_TID, NULL);
  object->toTid = g_object_new (TYPE_TID, NULL);
  object->addr = NULL;
  object->port = 0;
  object->transport = 0;
  object->pubId = NULL;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_sock5_bean_finalize (GObject *object)
{
  TimSock5Bean *tobject = TIM_SOCK5_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fromTid != NULL)
  {
    g_object_unref(tobject->fromTid);
    tobject->fromTid = NULL;
  }
  if (tobject->toTid != NULL)
  {
    g_object_unref(tobject->toTid);
    tobject->toTid = NULL;
  }
  if (tobject->addr != NULL)
  {
    g_free(tobject->addr);
    tobject->addr = NULL;
  }
  if (tobject->pubId != NULL)
  {
    g_free(tobject->pubId);
    tobject->pubId = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_sock5_bean_class_init (TimSock5BeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_sock5_bean_read;
  struct_class->write = tim_sock5_bean_write;

  gobject_class->finalize = tim_sock5_bean_finalize;
  gobject_class->get_property = tim_sock5_bean_get_property;
  gobject_class->set_property = tim_sock5_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_FROM_TID,
     g_param_spec_object ("fromTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_TO_TID,
     g_param_spec_object ("toTid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_ADDR,
     g_param_spec_string ("addr",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_TRANSPORT,
     g_param_spec_int ("transport",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_PUB_ID,
     g_param_spec_string ("pubId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BEAN_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_sock5_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimSock5BeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_sock5_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimSock5Bean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_sock5_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimSock5BeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimSock5BytesProperties
{
  PROP_TIM_SOCK5_BYTES_0,
  PROP_TIM_SOCK5_BYTES_PUB_ID,
  PROP_TIM_SOCK5_BYTES_INDEX,
  PROP_TIM_SOCK5_BYTES_BYTES,
  PROP_TIM_SOCK5_BYTES_EXTRA_MAP
};

/* reads a tim_sock5_bytes object */
static gint32
tim_sock5_bytes_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimSock5Bytes * this_object = TIM_SOCK5_BYTES(object);
  gboolean isset_pubId = FALSE;
  gboolean isset_index = FALSE;
  gboolean isset_bytes = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pubId != NULL)
          {
            g_free(this_object->pubId);
            this_object->pubId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pubId, error)) < 0)
            return -1;
          xfer += ret;
          isset_pubId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->index, error)) < 0)
            return -1;
          xfer += ret;
          isset_index = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem82 = NULL;
              if (_elem82 != NULL)
              {
                g_free(_elem82);
                _elem82 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem82 = g_byte_array_new();
              g_byte_array_append (_elem82, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->bytes, _elem82);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key83 = NULL;
              gchar * val84 = NULL;
              if (key83 != NULL)
              {
                g_free(key83);
                key83 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key83, error)) < 0)
                return -1;
              xfer += ret;
              if (val84 != NULL)
              {
                g_free(val84);
                val84 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val84, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key83)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key83, (gpointer) val84);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_pubId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_index)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_bytes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_sock5_bytes_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimSock5Bytes * this_object = TIM_SOCK5_BYTES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimSock5Bytes", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pubId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->pubId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "index", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->index, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bytes", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i85;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->bytes ? this_object->bytes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i85 = 0; i85 < (this_object->bytes ? this_object->bytes->len : 0); i85++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->bytes, i85)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->bytes, i85)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->bytes, i85)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->bytes, i85)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key86 = NULL;
      gchar * val87 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key86 = keys[i];
        val87 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key86);

        if ((ret = thrift_protocol_write_string (protocol,  key86, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val87, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_sock5_bytes_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TimSock5Bytes *self = TIM_SOCK5_BYTES (object);

  switch (property_id)
  {
    case PROP_TIM_SOCK5_BYTES_PUB_ID:
      if (self->pubId != NULL)
        g_free (self->pubId);
      self->pubId = g_value_dup_string (value);
      break;

    case PROP_TIM_SOCK5_BYTES_INDEX:
      self->index = g_value_get_int (value);
      break;

    case PROP_TIM_SOCK5_BYTES_BYTES:
      if (self->bytes != NULL)
        g_ptr_array_unref (self->bytes);
      self->bytes = g_value_dup_boxed (value);
      break;

    case PROP_TIM_SOCK5_BYTES_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_sock5_bytes_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TimSock5Bytes *self = TIM_SOCK5_BYTES (object);

  switch (property_id)
  {
    case PROP_TIM_SOCK5_BYTES_PUB_ID:
      g_value_set_string (value, self->pubId);
      break;

    case PROP_TIM_SOCK5_BYTES_INDEX:
      g_value_set_int (value, self->index);
      break;

    case PROP_TIM_SOCK5_BYTES_BYTES:
      g_value_set_boxed (value, self->bytes);
      break;

    case PROP_TIM_SOCK5_BYTES_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_sock5_bytes_instance_init (TimSock5Bytes * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pubId = NULL;
  object->index = 0;
  object->bytes = g_ptr_array_new_with_free_func (thrift_string_free);
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_sock5_bytes_finalize (GObject *object)
{
  TimSock5Bytes *tobject = TIM_SOCK5_BYTES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pubId != NULL)
  {
    g_free(tobject->pubId);
    tobject->pubId = NULL;
  }
  if (tobject->bytes != NULL)
  {
    g_ptr_array_unref (tobject->bytes);
    tobject->bytes = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_sock5_bytes_class_init (TimSock5BytesClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_sock5_bytes_read;
  struct_class->write = tim_sock5_bytes_write;

  gobject_class->finalize = tim_sock5_bytes_finalize;
  gobject_class->get_property = tim_sock5_bytes_get_property;
  gobject_class->set_property = tim_sock5_bytes_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BYTES_PUB_ID,
     g_param_spec_string ("pubId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BYTES_INDEX,
     g_param_spec_int ("index",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BYTES_BYTES,
     g_param_spec_boxed ("bytes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_SOCK5_BYTES_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_sock5_bytes_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimSock5BytesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_sock5_bytes_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimSock5Bytes),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_sock5_bytes_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimSock5BytesType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimPageProperties
{
  PROP_TIM_PAGE_0,
  PROP_TIM_PAGE_FROM_TIME_STAMP,
  PROP_TIM_PAGE_TO_TIME_STAMP,
  PROP_TIM_PAGE_LIMIT_COUNT,
  PROP_TIM_PAGE_EXTRA_MAP
};

/* reads a tim_page object */
static gint32
tim_page_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimPage * this_object = TIM_PAGE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->fromTimeStamp != NULL)
          {
            g_free(this_object->fromTimeStamp);
            this_object->fromTimeStamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->fromTimeStamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fromTimeStamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->toTimeStamp != NULL)
          {
            g_free(this_object->toTimeStamp);
            this_object->toTimeStamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->toTimeStamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_toTimeStamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->limitCount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_limitCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key88 = NULL;
              gchar * val89 = NULL;
              if (key88 != NULL)
              {
                g_free(key88);
                key88 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key88, error)) < 0)
                return -1;
              xfer += ret;
              if (val89 != NULL)
              {
                g_free(val89);
                val89 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val89, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key88)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key88, (gpointer) val89);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_page_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimPage * this_object = TIM_PAGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimPage", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_fromTimeStamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fromTimeStamp", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->fromTimeStamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toTimeStamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toTimeStamp", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->toTimeStamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_limitCount == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "limitCount", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->limitCount, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key90 = NULL;
      gchar * val91 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key90 = keys[i];
        val91 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key90);

        if ((ret = thrift_protocol_write_string (protocol,  key90, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val91, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_page_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimPage *self = TIM_PAGE (object);

  switch (property_id)
  {
    case PROP_TIM_PAGE_FROM_TIME_STAMP:
      if (self->fromTimeStamp != NULL)
        g_free (self->fromTimeStamp);
      self->fromTimeStamp = g_value_dup_string (value);
      self->__isset_fromTimeStamp = TRUE;
      break;

    case PROP_TIM_PAGE_TO_TIME_STAMP:
      if (self->toTimeStamp != NULL)
        g_free (self->toTimeStamp);
      self->toTimeStamp = g_value_dup_string (value);
      self->__isset_toTimeStamp = TRUE;
      break;

    case PROP_TIM_PAGE_LIMIT_COUNT:
      self->limitCount = g_value_get_int (value);
      self->__isset_limitCount = TRUE;
      break;

    case PROP_TIM_PAGE_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_page_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimPage *self = TIM_PAGE (object);

  switch (property_id)
  {
    case PROP_TIM_PAGE_FROM_TIME_STAMP:
      g_value_set_string (value, self->fromTimeStamp);
      break;

    case PROP_TIM_PAGE_TO_TIME_STAMP:
      g_value_set_string (value, self->toTimeStamp);
      break;

    case PROP_TIM_PAGE_LIMIT_COUNT:
      g_value_set_int (value, self->limitCount);
      break;

    case PROP_TIM_PAGE_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_page_instance_init (TimPage * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->fromTimeStamp = NULL;
  object->__isset_fromTimeStamp = FALSE;
  object->toTimeStamp = NULL;
  object->__isset_toTimeStamp = FALSE;
  object->limitCount = 0;
  object->__isset_limitCount = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_page_finalize (GObject *object)
{
  TimPage *tobject = TIM_PAGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fromTimeStamp != NULL)
  {
    g_free(tobject->fromTimeStamp);
    tobject->fromTimeStamp = NULL;
  }
  if (tobject->toTimeStamp != NULL)
  {
    g_free(tobject->toTimeStamp);
    tobject->toTimeStamp = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_page_class_init (TimPageClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_page_read;
  struct_class->write = tim_page_write;

  gobject_class->finalize = tim_page_finalize;
  gobject_class->get_property = tim_page_get_property;
  gobject_class->set_property = tim_page_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PAGE_FROM_TIME_STAMP,
     g_param_spec_string ("fromTimeStamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PAGE_TO_TIME_STAMP,
     g_param_spec_string ("toTimeStamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PAGE_LIMIT_COUNT,
     g_param_spec_int ("limitCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PAGE_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_page_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimPageClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_page_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimPage),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_page_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimPageType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimMessageIqProperties
{
  PROP_TIM_MESSAGE_IQ_0,
  PROP_TIM_MESSAGE_IQ_TIDLIST,
  PROP_TIM_MESSAGE_IQ_TIM_PAGE,
  PROP_TIM_MESSAGE_IQ_MIDLIST,
  PROP_TIM_MESSAGE_IQ_EXTRA_MAP
};

/* reads a tim_message_iq object */
static gint32
tim_message_iq_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimMessageIq * this_object = TIM_MESSAGE_IQ(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem92 = NULL;
              if (_elem92 != NULL)
              {
                g_free(_elem92);
                _elem92 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem92, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->tidlist, _elem92);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tidlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timPage), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_timPage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem93 = NULL;
              if (_elem93 != NULL)
              {
                g_free(_elem93);
                _elem93 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem93, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->midlist, _elem93);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_midlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key94 = NULL;
              gchar * val95 = NULL;
              if (key94 != NULL)
              {
                g_free(key94);
                key94 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key94, error)) < 0)
                return -1;
              xfer += ret;
              if (val95 != NULL)
              {
                g_free(val95);
                val95 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val95, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key94)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key94, (gpointer) val95);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_message_iq_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimMessageIq * this_object = TIM_MESSAGE_IQ(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimMessageIq", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_tidlist == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tidlist", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i96;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->tidlist ? this_object->tidlist->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i96 = 0; i96 < (this_object->tidlist ? this_object->tidlist->len : 0); i96++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->tidlist, i96)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timPage == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timPage", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timPage), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_midlist == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "midlist", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i97;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->midlist ? this_object->midlist->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i97 = 0; i97 < (this_object->midlist ? this_object->midlist->len : 0); i97++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->midlist, i97)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key98 = NULL;
      gchar * val99 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key98 = keys[i];
        val99 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key98);

        if ((ret = thrift_protocol_write_string (protocol,  key98, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val99, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_message_iq_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TimMessageIq *self = TIM_MESSAGE_IQ (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_IQ_TIDLIST:
      if (self->tidlist != NULL)
        g_ptr_array_unref (self->tidlist);
      self->tidlist = g_value_dup_boxed (value);
      self->__isset_tidlist = TRUE;
      break;

    case PROP_TIM_MESSAGE_IQ_TIM_PAGE:
      if (self->timPage != NULL)
        g_object_unref (self->timPage);
      self->timPage = g_value_dup_object (value);
      self->__isset_timPage = TRUE;
      break;

    case PROP_TIM_MESSAGE_IQ_MIDLIST:
      if (self->midlist != NULL)
        g_ptr_array_unref (self->midlist);
      self->midlist = g_value_dup_boxed (value);
      self->__isset_midlist = TRUE;
      break;

    case PROP_TIM_MESSAGE_IQ_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_message_iq_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TimMessageIq *self = TIM_MESSAGE_IQ (object);

  switch (property_id)
  {
    case PROP_TIM_MESSAGE_IQ_TIDLIST:
      g_value_set_boxed (value, self->tidlist);
      break;

    case PROP_TIM_MESSAGE_IQ_TIM_PAGE:
      g_value_set_object (value, self->timPage);
      break;

    case PROP_TIM_MESSAGE_IQ_MIDLIST:
      g_value_set_boxed (value, self->midlist);
      break;

    case PROP_TIM_MESSAGE_IQ_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_message_iq_instance_init (TimMessageIq * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tidlist = g_ptr_array_new_with_free_func (g_free);
  object->__isset_tidlist = FALSE;
  object->timPage = g_object_new (TYPE_TIM_PAGE, NULL);
  object->__isset_timPage = FALSE;
  object->midlist = g_ptr_array_new_with_free_func (g_free);
  object->__isset_midlist = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_message_iq_finalize (GObject *object)
{
  TimMessageIq *tobject = TIM_MESSAGE_IQ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tidlist != NULL)
  {
    g_ptr_array_unref (tobject->tidlist);
    tobject->tidlist = NULL;
  }
  if (tobject->timPage != NULL)
  {
    g_object_unref(tobject->timPage);
    tobject->timPage = NULL;
  }
  if (tobject->midlist != NULL)
  {
    g_ptr_array_unref (tobject->midlist);
    tobject->midlist = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_message_iq_class_init (TimMessageIqClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_message_iq_read;
  struct_class->write = tim_message_iq_write;

  gobject_class->finalize = tim_message_iq_finalize;
  gobject_class->get_property = tim_message_iq_get_property;
  gobject_class->set_property = tim_message_iq_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_IQ_TIDLIST,
     g_param_spec_boxed ("tidlist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_IQ_TIM_PAGE,
     g_param_spec_object ("timPage",
                         NULL,
                         NULL,
                         TYPE_TIM_PAGE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_IQ_MIDLIST,
     g_param_spec_boxed ("midlist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_MESSAGE_IQ_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_message_iq_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimMessageIqClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_message_iq_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimMessageIq),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_message_iq_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimMessageIqType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimAuthProperties
{
  PROP_TIM_AUTH_0,
  PROP_TIM_AUTH_DOMAIN,
  PROP_TIM_AUTH_USERNAME,
  PROP_TIM_AUTH_PWD
};

/* reads a tim_auth object */
static gint32
tim_auth_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimAuth * this_object = TIM_AUTH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->domain != NULL)
          {
            g_free(this_object->domain);
            this_object->domain = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->domain, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_domain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->username != NULL)
          {
            g_free(this_object->username);
            this_object->username = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->username, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_username = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->pwd != NULL)
          {
            g_free(this_object->pwd);
            this_object->pwd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pwd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pwd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_auth_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimAuth * this_object = TIM_AUTH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimAuth", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_domain == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "domain", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->domain, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_username == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "username", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->username, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_pwd == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pwd", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->pwd, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_auth_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TimAuth *self = TIM_AUTH (object);

  switch (property_id)
  {
    case PROP_TIM_AUTH_DOMAIN:
      if (self->domain != NULL)
        g_free (self->domain);
      self->domain = g_value_dup_string (value);
      self->__isset_domain = TRUE;
      break;

    case PROP_TIM_AUTH_USERNAME:
      if (self->username != NULL)
        g_free (self->username);
      self->username = g_value_dup_string (value);
      self->__isset_username = TRUE;
      break;

    case PROP_TIM_AUTH_PWD:
      if (self->pwd != NULL)
        g_free (self->pwd);
      self->pwd = g_value_dup_string (value);
      self->__isset_pwd = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_auth_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TimAuth *self = TIM_AUTH (object);

  switch (property_id)
  {
    case PROP_TIM_AUTH_DOMAIN:
      g_value_set_string (value, self->domain);
      break;

    case PROP_TIM_AUTH_USERNAME:
      g_value_set_string (value, self->username);
      break;

    case PROP_TIM_AUTH_PWD:
      g_value_set_string (value, self->pwd);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_auth_instance_init (TimAuth * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->domain = NULL;
  object->__isset_domain = FALSE;
  object->username = NULL;
  object->__isset_username = FALSE;
  object->pwd = NULL;
  object->__isset_pwd = FALSE;
}

static void 
tim_auth_finalize (GObject *object)
{
  TimAuth *tobject = TIM_AUTH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->domain != NULL)
  {
    g_free(tobject->domain);
    tobject->domain = NULL;
  }
  if (tobject->username != NULL)
  {
    g_free(tobject->username);
    tobject->username = NULL;
  }
  if (tobject->pwd != NULL)
  {
    g_free(tobject->pwd);
    tobject->pwd = NULL;
  }
}

static void
tim_auth_class_init (TimAuthClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_auth_read;
  struct_class->write = tim_auth_write;

  gobject_class->finalize = tim_auth_finalize;
  gobject_class->get_property = tim_auth_get_property;
  gobject_class->set_property = tim_auth_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_DOMAIN,
     g_param_spec_string ("domain",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_USERNAME,
     g_param_spec_string ("username",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_AUTH_PWD,
     g_param_spec_string ("pwd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_auth_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimAuthClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_auth_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimAuth),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_auth_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimAuthType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimMBeanListProperties
{
  PROP_TIM_M_BEAN_LIST_0,
  PROP_TIM_M_BEAN_LIST_THREAD_ID,
  PROP_TIM_M_BEAN_LIST_TIM_M_BEAN_LIST,
  PROP_TIM_M_BEAN_LIST_REQ_TYPE,
  PROP_TIM_M_BEAN_LIST_EXTRA_MAP
};

/* reads a tim_m_bean_list object */
static gint32
tim_m_bean_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimMBeanList * this_object = TIM_M_BEAN_LIST(object);
  gboolean isset_threadId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimMBean * _elem100 = NULL;
              if ( _elem100 != NULL)
              {
                g_object_unref (_elem100);
              }
              _elem100 = g_object_new (TYPE_TIM_M_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem100), protocol, error)) < 0)
              {
                g_object_unref (_elem100);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->timMBeanList, _elem100);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_timMBeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->reqType != NULL)
          {
            g_free(this_object->reqType);
            this_object->reqType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->reqType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key101 = NULL;
              gchar * val102 = NULL;
              if (key101 != NULL)
              {
                g_free(key101);
                key101 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key101, error)) < 0)
                return -1;
              xfer += ret;
              if (val102 != NULL)
              {
                g_free(val102);
                val102 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val102, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key101)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key101, (gpointer) val102);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_threadId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_m_bean_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimMBeanList * this_object = TIM_M_BEAN_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimMBeanList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timMBeanList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timMBeanList", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i103;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->timMBeanList ? this_object->timMBeanList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i103 = 0; i103 < (this_object->timMBeanList ? this_object->timMBeanList->len : 0); i103++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->timMBeanList, i103))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqType", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->reqType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key104 = NULL;
      gchar * val105 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key104 = keys[i];
        val105 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key104);

        if ((ret = thrift_protocol_write_string (protocol,  key104, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val105, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_m_bean_list_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TimMBeanList *self = TIM_M_BEAN_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_M_BEAN_LIST_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      break;

    case PROP_TIM_M_BEAN_LIST_TIM_M_BEAN_LIST:
      if (self->timMBeanList != NULL)
        g_ptr_array_unref (self->timMBeanList);
      self->timMBeanList = g_value_dup_boxed (value);
      self->__isset_timMBeanList = TRUE;
      break;

    case PROP_TIM_M_BEAN_LIST_REQ_TYPE:
      if (self->reqType != NULL)
        g_free (self->reqType);
      self->reqType = g_value_dup_string (value);
      self->__isset_reqType = TRUE;
      break;

    case PROP_TIM_M_BEAN_LIST_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_m_bean_list_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TimMBeanList *self = TIM_M_BEAN_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_M_BEAN_LIST_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_M_BEAN_LIST_TIM_M_BEAN_LIST:
      g_value_set_boxed (value, self->timMBeanList);
      break;

    case PROP_TIM_M_BEAN_LIST_REQ_TYPE:
      g_value_set_string (value, self->reqType);
      break;

    case PROP_TIM_M_BEAN_LIST_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_m_bean_list_instance_init (TimMBeanList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->timMBeanList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_timMBeanList = FALSE;
  object->reqType = NULL;
  object->__isset_reqType = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_m_bean_list_finalize (GObject *object)
{
  TimMBeanList *tobject = TIM_M_BEAN_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->timMBeanList != NULL)
  {
    g_ptr_array_unref (tobject->timMBeanList);
    tobject->timMBeanList = NULL;
  }
  if (tobject->reqType != NULL)
  {
    g_free(tobject->reqType);
    tobject->reqType = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_m_bean_list_class_init (TimMBeanListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_m_bean_list_read;
  struct_class->write = tim_m_bean_list_write;

  gobject_class->finalize = tim_m_bean_list_finalize;
  gobject_class->get_property = tim_m_bean_list_get_property;
  gobject_class->set_property = tim_m_bean_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_LIST_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_LIST_TIM_M_BEAN_LIST,
     g_param_spec_boxed ("timMBeanList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_LIST_REQ_TYPE,
     g_param_spec_string ("reqType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_M_BEAN_LIST_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_m_bean_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimMBeanListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_m_bean_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimMBeanList),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_m_bean_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimMBeanListType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimPBeanListProperties
{
  PROP_TIM_P_BEAN_LIST_0,
  PROP_TIM_P_BEAN_LIST_THREAD_ID,
  PROP_TIM_P_BEAN_LIST_TIM_P_BEAN_LIST,
  PROP_TIM_P_BEAN_LIST_REQ_TYPE,
  PROP_TIM_P_BEAN_LIST_EXTRA_MAP
};

/* reads a tim_p_bean_list object */
static gint32
tim_p_bean_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimPBeanList * this_object = TIM_P_BEAN_LIST(object);
  gboolean isset_threadId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TimPBean * _elem106 = NULL;
              if ( _elem106 != NULL)
              {
                g_object_unref (_elem106);
              }
              _elem106 = g_object_new (TYPE_TIM_P_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem106), protocol, error)) < 0)
              {
                g_object_unref (_elem106);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->timPBeanList, _elem106);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_timPBeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->reqType != NULL)
          {
            g_free(this_object->reqType);
            this_object->reqType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->reqType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reqType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key107 = NULL;
              gchar * val108 = NULL;
              if (key107 != NULL)
              {
                g_free(key107);
                key107 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key107, error)) < 0)
                return -1;
              xfer += ret;
              if (val108 != NULL)
              {
                g_free(val108);
                val108 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val108, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->extraMap && key107)
                g_hash_table_insert ((GHashTable *)this_object->extraMap, (gpointer) key107, (gpointer) val108);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_extraMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_threadId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
tim_p_bean_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimPBeanList * this_object = TIM_P_BEAN_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimPBeanList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timPBeanList == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timPBeanList", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i109;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->timPBeanList ? this_object->timPBeanList->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i109 = 0; i109 < (this_object->timPBeanList ? this_object->timPBeanList->len : 0); i109++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->timPBeanList, i109))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reqType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqType", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->reqType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extraMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extraMap", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key110 = NULL;
      gchar * val111 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->extraMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->extraMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->extraMap)
        g_hash_table_foreach ((GHashTable *) this_object->extraMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key110 = keys[i];
        val111 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->extraMap), (gpointer) key110);

        if ((ret = thrift_protocol_write_string (protocol,  key110, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val111, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_p_bean_list_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TimPBeanList *self = TIM_P_BEAN_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_P_BEAN_LIST_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      break;

    case PROP_TIM_P_BEAN_LIST_TIM_P_BEAN_LIST:
      if (self->timPBeanList != NULL)
        g_ptr_array_unref (self->timPBeanList);
      self->timPBeanList = g_value_dup_boxed (value);
      self->__isset_timPBeanList = TRUE;
      break;

    case PROP_TIM_P_BEAN_LIST_REQ_TYPE:
      if (self->reqType != NULL)
        g_free (self->reqType);
      self->reqType = g_value_dup_string (value);
      self->__isset_reqType = TRUE;
      break;

    case PROP_TIM_P_BEAN_LIST_EXTRA_MAP:
      if (self->extraMap != NULL)
        g_hash_table_unref (self->extraMap);
      self->extraMap = g_value_dup_boxed (value);
      self->__isset_extraMap = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_p_bean_list_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TimPBeanList *self = TIM_P_BEAN_LIST (object);

  switch (property_id)
  {
    case PROP_TIM_P_BEAN_LIST_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_P_BEAN_LIST_TIM_P_BEAN_LIST:
      g_value_set_boxed (value, self->timPBeanList);
      break;

    case PROP_TIM_P_BEAN_LIST_REQ_TYPE:
      g_value_set_string (value, self->reqType);
      break;

    case PROP_TIM_P_BEAN_LIST_EXTRA_MAP:
      g_value_set_boxed (value, self->extraMap);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_p_bean_list_instance_init (TimPBeanList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->timPBeanList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_timPBeanList = FALSE;
  object->reqType = NULL;
  object->__isset_reqType = FALSE;
  object->extraMap = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_extraMap = FALSE;
}

static void 
tim_p_bean_list_finalize (GObject *object)
{
  TimPBeanList *tobject = TIM_P_BEAN_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->timPBeanList != NULL)
  {
    g_ptr_array_unref (tobject->timPBeanList);
    tobject->timPBeanList = NULL;
  }
  if (tobject->reqType != NULL)
  {
    g_free(tobject->reqType);
    tobject->reqType = NULL;
  }
  if (tobject->extraMap != NULL)
  {
    g_hash_table_destroy (tobject->extraMap);
    tobject->extraMap = NULL;
  }
}

static void
tim_p_bean_list_class_init (TimPBeanListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_p_bean_list_read;
  struct_class->write = tim_p_bean_list_write;

  gobject_class->finalize = tim_p_bean_list_finalize;
  gobject_class->get_property = tim_p_bean_list_get_property;
  gobject_class->set_property = tim_p_bean_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_LIST_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_LIST_TIM_P_BEAN_LIST,
     g_param_spec_boxed ("timPBeanList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_LIST_REQ_TYPE,
     g_param_spec_string ("reqType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_P_BEAN_LIST_EXTRA_MAP,
     g_param_spec_boxed ("extraMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
tim_p_bean_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimPBeanListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_p_bean_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimPBeanList),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_p_bean_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimPBeanListType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimPropertyBeanProperties
{
  PROP_TIM_PROPERTY_BEAN_0,
  PROP_TIM_PROPERTY_BEAN_THREAD_ID,
  PROP_TIM_PROPERTY_BEAN_INTERFLOW,
  PROP_TIM_PROPERTY_BEAN_TLS
};

/* reads a tim_property_bean object */
static gint32
tim_property_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimPropertyBean * this_object = TIM_PROPERTY_BEAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->interflow != NULL)
          {
            g_free(this_object->interflow);
            this_object->interflow = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->interflow, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_interflow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->tls != NULL)
          {
            g_free(this_object->tls);
            this_object->tls = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tls, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tls = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
tim_property_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimPropertyBean * this_object = TIM_PROPERTY_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimPropertyBean", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_threadId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_interflow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "interflow", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->interflow, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tls == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tls", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->tls, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
tim_property_bean_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TimPropertyBean *self = TIM_PROPERTY_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_PROPERTY_BEAN_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      self->__isset_threadId = TRUE;
      break;

    case PROP_TIM_PROPERTY_BEAN_INTERFLOW:
      if (self->interflow != NULL)
        g_free (self->interflow);
      self->interflow = g_value_dup_string (value);
      self->__isset_interflow = TRUE;
      break;

    case PROP_TIM_PROPERTY_BEAN_TLS:
      if (self->tls != NULL)
        g_free (self->tls);
      self->tls = g_value_dup_string (value);
      self->__isset_tls = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
tim_property_bean_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TimPropertyBean *self = TIM_PROPERTY_BEAN (object);

  switch (property_id)
  {
    case PROP_TIM_PROPERTY_BEAN_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    case PROP_TIM_PROPERTY_BEAN_INTERFLOW:
      g_value_set_string (value, self->interflow);
      break;

    case PROP_TIM_PROPERTY_BEAN_TLS:
      g_value_set_string (value, self->tls);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
tim_property_bean_instance_init (TimPropertyBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->__isset_threadId = FALSE;
  object->interflow = NULL;
  object->__isset_interflow = FALSE;
  object->tls = NULL;
  object->__isset_tls = FALSE;
}

static void 
tim_property_bean_finalize (GObject *object)
{
  TimPropertyBean *tobject = TIM_PROPERTY_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
  if (tobject->interflow != NULL)
  {
    g_free(tobject->interflow);
    tobject->interflow = NULL;
  }
  if (tobject->tls != NULL)
  {
    g_free(tobject->tls);
    tobject->tls = NULL;
  }
}

static void
tim_property_bean_class_init (TimPropertyBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = tim_property_bean_read;
  struct_class->write = tim_property_bean_write;

  gobject_class->finalize = tim_property_bean_finalize;
  gobject_class->get_property = tim_property_bean_get_property;
  gobject_class->set_property = tim_property_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PROPERTY_BEAN_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PROPERTY_BEAN_INTERFLOW,
     g_param_spec_string ("interflow",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIM_PROPERTY_BEAN_TLS,
     g_param_spec_string ("tls",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
tim_property_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimPropertyBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) tim_property_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimPropertyBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) tim_property_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimPropertyBeanType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _ITimTimStreamArgsProperties
{
  PROP_I_TIM_TIM_STREAM_ARGS_0,
  PROP_I_TIM_TIM_STREAM_ARGS_PARAM
};

/* reads a i_tim_tim_stream_args object */
static gint32
i_tim_tim_stream_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimStreamArgs * this_object = I_TIM_TIM_STREAM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->param), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_param = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_stream_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimStreamArgs * this_object = I_TIM_TIM_STREAM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimStreamArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "param", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->param), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_stream_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ITimTimStreamArgs *self = I_TIM_TIM_STREAM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_STREAM_ARGS_PARAM:
      if (self->param != NULL)
        g_object_unref (self->param);
      self->param = g_value_dup_object (value);
      self->__isset_param = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_stream_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ITimTimStreamArgs *self = I_TIM_TIM_STREAM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_STREAM_ARGS_PARAM:
      g_value_set_object (value, self->param);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_stream_args_instance_init (ITimTimStreamArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->param = g_object_new (TYPE_TIM_PARAM, NULL);
  object->__isset_param = FALSE;
}

static void 
i_tim_tim_stream_args_finalize (GObject *object)
{
  ITimTimStreamArgs *tobject = I_TIM_TIM_STREAM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->param != NULL)
  {
    g_object_unref(tobject->param);
    tobject->param = NULL;
  }
}

static void
i_tim_tim_stream_args_class_init (ITimTimStreamArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_stream_args_read;
  struct_class->write = i_tim_tim_stream_args_write;

  gobject_class->finalize = i_tim_tim_stream_args_finalize;
  gobject_class->get_property = i_tim_tim_stream_args_get_property;
  gobject_class->set_property = i_tim_tim_stream_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_STREAM_ARGS_PARAM,
     g_param_spec_object ("param",
                         NULL,
                         NULL,
                         TYPE_TIM_PARAM,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_stream_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimStreamArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_stream_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimStreamArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_stream_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimStreamArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_tim_tim_starttls_args object */
static gint32
i_tim_tim_starttls_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimStarttlsArgs * this_object = I_TIM_TIM_STARTTLS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_starttls_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimStarttlsArgs * this_object = I_TIM_TIM_STARTTLS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimStarttlsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_tim_tim_starttls_args_instance_init (ITimTimStarttlsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_tim_tim_starttls_args_finalize (GObject *object)
{
  ITimTimStarttlsArgs *tobject = I_TIM_TIM_STARTTLS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_tim_tim_starttls_args_class_init (ITimTimStarttlsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_starttls_args_read;
  struct_class->write = i_tim_tim_starttls_args_write;

  gobject_class->finalize = i_tim_tim_starttls_args_finalize;
}

GType
i_tim_tim_starttls_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimStarttlsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_starttls_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimStarttlsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_starttls_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimStarttlsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimLoginArgsProperties
{
  PROP_I_TIM_TIM_LOGIN_ARGS_0,
  PROP_I_TIM_TIM_LOGIN_ARGS_TID,
  PROP_I_TIM_TIM_LOGIN_ARGS_PWD
};

/* reads a i_tim_tim_login_args object */
static gint32
i_tim_tim_login_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimLoginArgs * this_object = I_TIM_TIM_LOGIN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pwd != NULL)
          {
            g_free(this_object->pwd);
            this_object->pwd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pwd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pwd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_login_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimLoginArgs * this_object = I_TIM_TIM_LOGIN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimLoginArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pwd", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->pwd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_login_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimLoginArgs *self = I_TIM_TIM_LOGIN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_LOGIN_ARGS_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_I_TIM_TIM_LOGIN_ARGS_PWD:
      if (self->pwd != NULL)
        g_free (self->pwd);
      self->pwd = g_value_dup_string (value);
      self->__isset_pwd = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_login_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimLoginArgs *self = I_TIM_TIM_LOGIN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_LOGIN_ARGS_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_I_TIM_TIM_LOGIN_ARGS_PWD:
      g_value_set_string (value, self->pwd);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_login_args_instance_init (ITimTimLoginArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->pwd = NULL;
  object->__isset_pwd = FALSE;
}

static void 
i_tim_tim_login_args_finalize (GObject *object)
{
  ITimTimLoginArgs *tobject = I_TIM_TIM_LOGIN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->pwd != NULL)
  {
    g_free(tobject->pwd);
    tobject->pwd = NULL;
  }
}

static void
i_tim_tim_login_args_class_init (ITimTimLoginArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_login_args_read;
  struct_class->write = i_tim_tim_login_args_write;

  gobject_class->finalize = i_tim_tim_login_args_finalize;
  gobject_class->get_property = i_tim_tim_login_args_get_property;
  gobject_class->set_property = i_tim_tim_login_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_LOGIN_ARGS_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_LOGIN_ARGS_PWD,
     g_param_spec_string ("pwd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_tim_tim_login_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimLoginArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_login_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimLoginArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_login_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimLoginArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimAckArgsProperties
{
  PROP_I_TIM_TIM_ACK_ARGS_0,
  PROP_I_TIM_TIM_ACK_ARGS_AB
};

/* reads a i_tim_tim_ack_args object */
static gint32
i_tim_tim_ack_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimAckArgs * this_object = I_TIM_TIM_ACK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ab = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_ack_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimAckArgs * this_object = I_TIM_TIM_ACK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimAckArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ab", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ab), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_ack_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  ITimTimAckArgs *self = I_TIM_TIM_ACK_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ACK_ARGS_AB:
      if (self->ab != NULL)
        g_object_unref (self->ab);
      self->ab = g_value_dup_object (value);
      self->__isset_ab = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_ack_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  ITimTimAckArgs *self = I_TIM_TIM_ACK_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ACK_ARGS_AB:
      g_value_set_object (value, self->ab);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_ack_args_instance_init (ITimTimAckArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ab = g_object_new (TYPE_TIM_ACK_BEAN, NULL);
  object->__isset_ab = FALSE;
}

static void 
i_tim_tim_ack_args_finalize (GObject *object)
{
  ITimTimAckArgs *tobject = I_TIM_TIM_ACK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ab != NULL)
  {
    g_object_unref(tobject->ab);
    tobject->ab = NULL;
  }
}

static void
i_tim_tim_ack_args_class_init (ITimTimAckArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_ack_args_read;
  struct_class->write = i_tim_tim_ack_args_write;

  gobject_class->finalize = i_tim_tim_ack_args_finalize;
  gobject_class->get_property = i_tim_tim_ack_args_get_property;
  gobject_class->set_property = i_tim_tim_ack_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_ACK_ARGS_AB,
     g_param_spec_object ("ab",
                         NULL,
                         NULL,
                         TYPE_TIM_ACK_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_ack_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimAckArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_ack_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimAckArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_ack_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimAckArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimPresenceArgsProperties
{
  PROP_I_TIM_TIM_PRESENCE_ARGS_0,
  PROP_I_TIM_TIM_PRESENCE_ARGS_PBEAN
};

/* reads a i_tim_tim_presence_args object */
static gint32
i_tim_tim_presence_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimPresenceArgs * this_object = I_TIM_TIM_PRESENCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->pbean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_pbean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_presence_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimPresenceArgs * this_object = I_TIM_TIM_PRESENCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimPresenceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pbean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->pbean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_presence_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ITimTimPresenceArgs *self = I_TIM_TIM_PRESENCE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PRESENCE_ARGS_PBEAN:
      if (self->pbean != NULL)
        g_object_unref (self->pbean);
      self->pbean = g_value_dup_object (value);
      self->__isset_pbean = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_presence_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ITimTimPresenceArgs *self = I_TIM_TIM_PRESENCE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PRESENCE_ARGS_PBEAN:
      g_value_set_object (value, self->pbean);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_presence_args_instance_init (ITimTimPresenceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pbean = g_object_new (TYPE_TIM_P_BEAN, NULL);
  object->__isset_pbean = FALSE;
}

static void 
i_tim_tim_presence_args_finalize (GObject *object)
{
  ITimTimPresenceArgs *tobject = I_TIM_TIM_PRESENCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pbean != NULL)
  {
    g_object_unref(tobject->pbean);
    tobject->pbean = NULL;
  }
}

static void
i_tim_tim_presence_args_class_init (ITimTimPresenceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_presence_args_read;
  struct_class->write = i_tim_tim_presence_args_write;

  gobject_class->finalize = i_tim_tim_presence_args_finalize;
  gobject_class->get_property = i_tim_tim_presence_args_get_property;
  gobject_class->set_property = i_tim_tim_presence_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_PRESENCE_ARGS_PBEAN,
     g_param_spec_object ("pbean",
                         NULL,
                         NULL,
                         TYPE_TIM_P_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_presence_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimPresenceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_presence_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimPresenceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_presence_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimPresenceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimMessageArgsProperties
{
  PROP_I_TIM_TIM_MESSAGE_ARGS_0,
  PROP_I_TIM_TIM_MESSAGE_ARGS_MBEAN
};

/* reads a i_tim_tim_message_args object */
static gint32
i_tim_tim_message_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimMessageArgs * this_object = I_TIM_TIM_MESSAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mbean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_message_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimMessageArgs * this_object = I_TIM_TIM_MESSAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimMessageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mbean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_message_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  ITimTimMessageArgs *self = I_TIM_TIM_MESSAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_ARGS_MBEAN:
      if (self->mbean != NULL)
        g_object_unref (self->mbean);
      self->mbean = g_value_dup_object (value);
      self->__isset_mbean = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_message_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  ITimTimMessageArgs *self = I_TIM_TIM_MESSAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_ARGS_MBEAN:
      g_value_set_object (value, self->mbean);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_message_args_instance_init (ITimTimMessageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mbean = g_object_new (TYPE_TIM_M_BEAN, NULL);
  object->__isset_mbean = FALSE;
}

static void 
i_tim_tim_message_args_finalize (GObject *object)
{
  ITimTimMessageArgs *tobject = I_TIM_TIM_MESSAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mbean != NULL)
  {
    g_object_unref(tobject->mbean);
    tobject->mbean = NULL;
  }
}

static void
i_tim_tim_message_args_class_init (ITimTimMessageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_message_args_read;
  struct_class->write = i_tim_tim_message_args_write;

  gobject_class->finalize = i_tim_tim_message_args_finalize;
  gobject_class->get_property = i_tim_tim_message_args_get_property;
  gobject_class->set_property = i_tim_tim_message_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_MESSAGE_ARGS_MBEAN,
     g_param_spec_object ("mbean",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_message_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimMessageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_message_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimMessageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_message_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimMessageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimPingArgsProperties
{
  PROP_I_TIM_TIM_PING_ARGS_0,
  PROP_I_TIM_TIM_PING_ARGS_THREAD_ID
};

/* reads a i_tim_tim_ping_args object */
static gint32
i_tim_tim_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimPingArgs * this_object = I_TIM_TIM_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->threadId != NULL)
          {
            g_free(this_object->threadId);
            this_object->threadId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->threadId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_threadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimPingArgs * this_object = I_TIM_TIM_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "threadId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->threadId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_ping_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ITimTimPingArgs *self = I_TIM_TIM_PING_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PING_ARGS_THREAD_ID:
      if (self->threadId != NULL)
        g_free (self->threadId);
      self->threadId = g_value_dup_string (value);
      self->__isset_threadId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_ping_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ITimTimPingArgs *self = I_TIM_TIM_PING_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PING_ARGS_THREAD_ID:
      g_value_set_string (value, self->threadId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_ping_args_instance_init (ITimTimPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->threadId = NULL;
  object->__isset_threadId = FALSE;
}

static void 
i_tim_tim_ping_args_finalize (GObject *object)
{
  ITimTimPingArgs *tobject = I_TIM_TIM_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->threadId != NULL)
  {
    g_free(tobject->threadId);
    tobject->threadId = NULL;
  }
}

static void
i_tim_tim_ping_args_class_init (ITimTimPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_ping_args_read;
  struct_class->write = i_tim_tim_ping_args_write;

  gobject_class->finalize = i_tim_tim_ping_args_finalize;
  gobject_class->get_property = i_tim_tim_ping_args_get_property;
  gobject_class->set_property = i_tim_tim_ping_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_PING_ARGS_THREAD_ID,
     g_param_spec_string ("threadId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_tim_tim_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimErrorArgsProperties
{
  PROP_I_TIM_TIM_ERROR_ARGS_0,
  PROP_I_TIM_TIM_ERROR_ARGS_E
};

/* reads a i_tim_tim_error_args object */
static gint32
i_tim_tim_error_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimErrorArgs * this_object = I_TIM_TIM_ERROR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_error_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimErrorArgs * this_object = I_TIM_TIM_ERROR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimErrorArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_error_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimErrorArgs *self = I_TIM_TIM_ERROR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ERROR_ARGS_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_error_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimErrorArgs *self = I_TIM_TIM_ERROR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ERROR_ARGS_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_error_args_instance_init (ITimTimErrorArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = g_object_new (TYPE_TIM_ERROR, NULL);
  object->__isset_e = FALSE;
}

static void 
i_tim_tim_error_args_finalize (GObject *object)
{
  ITimTimErrorArgs *tobject = I_TIM_TIM_ERROR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
i_tim_tim_error_args_class_init (ITimTimErrorArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_error_args_read;
  struct_class->write = i_tim_tim_error_args_write;

  gobject_class->finalize = i_tim_tim_error_args_finalize;
  gobject_class->get_property = i_tim_tim_error_args_get_property;
  gobject_class->set_property = i_tim_tim_error_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_ERROR_ARGS_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_TIM_ERROR,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_error_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimErrorArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_error_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimErrorArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_error_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimErrorArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_tim_tim_logout_args object */
static gint32
i_tim_tim_logout_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimLogoutArgs * this_object = I_TIM_TIM_LOGOUT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_logout_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimLogoutArgs * this_object = I_TIM_TIM_LOGOUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimLogoutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_tim_tim_logout_args_instance_init (ITimTimLogoutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_tim_tim_logout_args_finalize (GObject *object)
{
  ITimTimLogoutArgs *tobject = I_TIM_TIM_LOGOUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_tim_tim_logout_args_class_init (ITimTimLogoutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_logout_args_read;
  struct_class->write = i_tim_tim_logout_args_write;

  gobject_class->finalize = i_tim_tim_logout_args_finalize;
}

GType
i_tim_tim_logout_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimLogoutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_logout_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimLogoutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_logout_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimLogoutArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRegistArgsProperties
{
  PROP_I_TIM_TIM_REGIST_ARGS_0,
  PROP_I_TIM_TIM_REGIST_ARGS_TID,
  PROP_I_TIM_TIM_REGIST_ARGS_AUTH
};

/* reads a i_tim_tim_regist_args object */
static gint32
i_tim_tim_regist_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRegistArgs * this_object = I_TIM_TIM_REGIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->auth != NULL)
          {
            g_free(this_object->auth);
            this_object->auth = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->auth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_regist_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRegistArgs * this_object = I_TIM_TIM_REGIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRegistArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->auth, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_regist_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ITimTimRegistArgs *self = I_TIM_TIM_REGIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REGIST_ARGS_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_I_TIM_TIM_REGIST_ARGS_AUTH:
      if (self->auth != NULL)
        g_free (self->auth);
      self->auth = g_value_dup_string (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_regist_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ITimTimRegistArgs *self = I_TIM_TIM_REGIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REGIST_ARGS_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_I_TIM_TIM_REGIST_ARGS_AUTH:
      g_value_set_string (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_regist_args_instance_init (ITimTimRegistArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->auth = NULL;
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_regist_args_finalize (GObject *object)
{
  ITimTimRegistArgs *tobject = I_TIM_TIM_REGIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_free(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_regist_args_class_init (ITimTimRegistArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_regist_args_read;
  struct_class->write = i_tim_tim_regist_args_write;

  gobject_class->finalize = i_tim_tim_regist_args_finalize;
  gobject_class->get_property = i_tim_tim_regist_args_get_property;
  gobject_class->set_property = i_tim_tim_regist_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REGIST_ARGS_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REGIST_ARGS_AUTH,
     g_param_spec_string ("auth",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_tim_tim_regist_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRegistArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_regist_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRegistArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_regist_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRegistArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRoserArgsProperties
{
  PROP_I_TIM_TIM_ROSER_ARGS_0,
  PROP_I_TIM_TIM_ROSER_ARGS_ROSTER
};

/* reads a i_tim_tim_roser_args object */
static gint32
i_tim_tim_roser_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRoserArgs * this_object = I_TIM_TIM_ROSER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->roster), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_roster = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_roser_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRoserArgs * this_object = I_TIM_TIM_ROSER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRoserArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "roster", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->roster), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_roser_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimRoserArgs *self = I_TIM_TIM_ROSER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ROSER_ARGS_ROSTER:
      if (self->roster != NULL)
        g_object_unref (self->roster);
      self->roster = g_value_dup_object (value);
      self->__isset_roster = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_roser_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ITimTimRoserArgs *self = I_TIM_TIM_ROSER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_ROSER_ARGS_ROSTER:
      g_value_set_object (value, self->roster);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_roser_args_instance_init (ITimTimRoserArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->roster = g_object_new (TYPE_TIM_ROSTER, NULL);
  object->__isset_roster = FALSE;
}

static void 
i_tim_tim_roser_args_finalize (GObject *object)
{
  ITimTimRoserArgs *tobject = I_TIM_TIM_ROSER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->roster != NULL)
  {
    g_object_unref(tobject->roster);
    tobject->roster = NULL;
  }
}

static void
i_tim_tim_roser_args_class_init (ITimTimRoserArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_roser_args_read;
  struct_class->write = i_tim_tim_roser_args_write;

  gobject_class->finalize = i_tim_tim_roser_args_finalize;
  gobject_class->get_property = i_tim_tim_roser_args_get_property;
  gobject_class->set_property = i_tim_tim_roser_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_ROSER_ARGS_ROSTER,
     g_param_spec_object ("roster",
                         NULL,
                         NULL,
                         TYPE_TIM_ROSTER,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_roser_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRoserArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_roser_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRoserArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_roser_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRoserArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimMessageListArgsProperties
{
  PROP_I_TIM_TIM_MESSAGE_LIST_ARGS_0,
  PROP_I_TIM_TIM_MESSAGE_LIST_ARGS_MBEAN_LIST
};

/* reads a i_tim_tim_message_list_args object */
static gint32
i_tim_tim_message_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimMessageListArgs * this_object = I_TIM_TIM_MESSAGE_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mbeanList), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mbeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_message_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimMessageListArgs * this_object = I_TIM_TIM_MESSAGE_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimMessageListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mbeanList", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mbeanList), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_message_list_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ITimTimMessageListArgs *self = I_TIM_TIM_MESSAGE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_LIST_ARGS_MBEAN_LIST:
      if (self->mbeanList != NULL)
        g_object_unref (self->mbeanList);
      self->mbeanList = g_value_dup_object (value);
      self->__isset_mbeanList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_message_list_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ITimTimMessageListArgs *self = I_TIM_TIM_MESSAGE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_LIST_ARGS_MBEAN_LIST:
      g_value_set_object (value, self->mbeanList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_message_list_args_instance_init (ITimTimMessageListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mbeanList = g_object_new (TYPE_TIM_M_BEAN_LIST, NULL);
  object->__isset_mbeanList = FALSE;
}

static void 
i_tim_tim_message_list_args_finalize (GObject *object)
{
  ITimTimMessageListArgs *tobject = I_TIM_TIM_MESSAGE_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mbeanList != NULL)
  {
    g_object_unref(tobject->mbeanList);
    tobject->mbeanList = NULL;
  }
}

static void
i_tim_tim_message_list_args_class_init (ITimTimMessageListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_message_list_args_read;
  struct_class->write = i_tim_tim_message_list_args_write;

  gobject_class->finalize = i_tim_tim_message_list_args_finalize;
  gobject_class->get_property = i_tim_tim_message_list_args_get_property;
  gobject_class->set_property = i_tim_tim_message_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_MESSAGE_LIST_ARGS_MBEAN_LIST,
     g_param_spec_object ("mbeanList",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN_LIST,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_message_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimMessageListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_message_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimMessageListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_message_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimMessageListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimPresenceListArgsProperties
{
  PROP_I_TIM_TIM_PRESENCE_LIST_ARGS_0,
  PROP_I_TIM_TIM_PRESENCE_LIST_ARGS_PBEAN_LIST
};

/* reads a i_tim_tim_presence_list_args object */
static gint32
i_tim_tim_presence_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimPresenceListArgs * this_object = I_TIM_TIM_PRESENCE_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->pbeanList), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_pbeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_presence_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimPresenceListArgs * this_object = I_TIM_TIM_PRESENCE_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimPresenceListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pbeanList", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->pbeanList), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_presence_list_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ITimTimPresenceListArgs *self = I_TIM_TIM_PRESENCE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PRESENCE_LIST_ARGS_PBEAN_LIST:
      if (self->pbeanList != NULL)
        g_object_unref (self->pbeanList);
      self->pbeanList = g_value_dup_object (value);
      self->__isset_pbeanList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_presence_list_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ITimTimPresenceListArgs *self = I_TIM_TIM_PRESENCE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PRESENCE_LIST_ARGS_PBEAN_LIST:
      g_value_set_object (value, self->pbeanList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_presence_list_args_instance_init (ITimTimPresenceListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pbeanList = g_object_new (TYPE_TIM_P_BEAN_LIST, NULL);
  object->__isset_pbeanList = FALSE;
}

static void 
i_tim_tim_presence_list_args_finalize (GObject *object)
{
  ITimTimPresenceListArgs *tobject = I_TIM_TIM_PRESENCE_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pbeanList != NULL)
  {
    g_object_unref(tobject->pbeanList);
    tobject->pbeanList = NULL;
  }
}

static void
i_tim_tim_presence_list_args_class_init (ITimTimPresenceListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_presence_list_args_read;
  struct_class->write = i_tim_tim_presence_list_args_write;

  gobject_class->finalize = i_tim_tim_presence_list_args_finalize;
  gobject_class->get_property = i_tim_tim_presence_list_args_get_property;
  gobject_class->set_property = i_tim_tim_presence_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_PRESENCE_LIST_ARGS_PBEAN_LIST,
     g_param_spec_object ("pbeanList",
                         NULL,
                         NULL,
                         TYPE_TIM_P_BEAN_LIST,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_presence_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimPresenceListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_presence_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimPresenceListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_presence_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimPresenceListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimMessageIqArgsProperties
{
  PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_0,
  PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_TIM_MSG_IQ,
  PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_IQ_TYPE
};

/* reads a i_tim_tim_message_iq_args object */
static gint32
i_tim_tim_message_iq_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimMessageIqArgs * this_object = I_TIM_TIM_MESSAGE_IQ_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timMsgIq), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_timMsgIq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->iqType != NULL)
          {
            g_free(this_object->iqType);
            this_object->iqType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->iqType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_iqType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_message_iq_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimMessageIqArgs * this_object = I_TIM_TIM_MESSAGE_IQ_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimMessageIqArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timMsgIq", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timMsgIq), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "iqType", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->iqType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_message_iq_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ITimTimMessageIqArgs *self = I_TIM_TIM_MESSAGE_IQ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_TIM_MSG_IQ:
      if (self->timMsgIq != NULL)
        g_object_unref (self->timMsgIq);
      self->timMsgIq = g_value_dup_object (value);
      self->__isset_timMsgIq = TRUE;
      break;

    case PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_IQ_TYPE:
      if (self->iqType != NULL)
        g_free (self->iqType);
      self->iqType = g_value_dup_string (value);
      self->__isset_iqType = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_message_iq_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ITimTimMessageIqArgs *self = I_TIM_TIM_MESSAGE_IQ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_TIM_MSG_IQ:
      g_value_set_object (value, self->timMsgIq);
      break;

    case PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_IQ_TYPE:
      g_value_set_string (value, self->iqType);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_message_iq_args_instance_init (ITimTimMessageIqArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timMsgIq = g_object_new (TYPE_TIM_MESSAGE_IQ, NULL);
  object->__isset_timMsgIq = FALSE;
  object->iqType = NULL;
  object->__isset_iqType = FALSE;
}

static void 
i_tim_tim_message_iq_args_finalize (GObject *object)
{
  ITimTimMessageIqArgs *tobject = I_TIM_TIM_MESSAGE_IQ_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timMsgIq != NULL)
  {
    g_object_unref(tobject->timMsgIq);
    tobject->timMsgIq = NULL;
  }
  if (tobject->iqType != NULL)
  {
    g_free(tobject->iqType);
    tobject->iqType = NULL;
  }
}

static void
i_tim_tim_message_iq_args_class_init (ITimTimMessageIqArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_message_iq_args_read;
  struct_class->write = i_tim_tim_message_iq_args_write;

  gobject_class->finalize = i_tim_tim_message_iq_args_finalize;
  gobject_class->get_property = i_tim_tim_message_iq_args_get_property;
  gobject_class->set_property = i_tim_tim_message_iq_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_TIM_MSG_IQ,
     g_param_spec_object ("timMsgIq",
                         NULL,
                         NULL,
                         TYPE_TIM_MESSAGE_IQ,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_MESSAGE_IQ_ARGS_IQ_TYPE,
     g_param_spec_string ("iqType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_tim_tim_message_iq_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimMessageIqArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_message_iq_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimMessageIqArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_message_iq_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimMessageIqArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimMessageResultArgsProperties
{
  PROP_I_TIM_TIM_MESSAGE_RESULT_ARGS_0,
  PROP_I_TIM_TIM_MESSAGE_RESULT_ARGS_MBEAN
};

/* reads a i_tim_tim_message_result_args object */
static gint32
i_tim_tim_message_result_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimMessageResultArgs * this_object = I_TIM_TIM_MESSAGE_RESULT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mbean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_message_result_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimMessageResultArgs * this_object = I_TIM_TIM_MESSAGE_RESULT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimMessageResultArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mbean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_message_result_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ITimTimMessageResultArgs *self = I_TIM_TIM_MESSAGE_RESULT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_RESULT_ARGS_MBEAN:
      if (self->mbean != NULL)
        g_object_unref (self->mbean);
      self->mbean = g_value_dup_object (value);
      self->__isset_mbean = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_message_result_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ITimTimMessageResultArgs *self = I_TIM_TIM_MESSAGE_RESULT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_MESSAGE_RESULT_ARGS_MBEAN:
      g_value_set_object (value, self->mbean);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_message_result_args_instance_init (ITimTimMessageResultArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mbean = g_object_new (TYPE_TIM_M_BEAN, NULL);
  object->__isset_mbean = FALSE;
}

static void 
i_tim_tim_message_result_args_finalize (GObject *object)
{
  ITimTimMessageResultArgs *tobject = I_TIM_TIM_MESSAGE_RESULT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mbean != NULL)
  {
    g_object_unref(tobject->mbean);
    tobject->mbean = NULL;
  }
}

static void
i_tim_tim_message_result_args_class_init (ITimTimMessageResultArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_message_result_args_read;
  struct_class->write = i_tim_tim_message_result_args_write;

  gobject_class->finalize = i_tim_tim_message_result_args_finalize;
  gobject_class->get_property = i_tim_tim_message_result_args_get_property;
  gobject_class->set_property = i_tim_tim_message_result_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_MESSAGE_RESULT_ARGS_MBEAN,
     g_param_spec_object ("mbean",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_message_result_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimMessageResultArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_message_result_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimMessageResultArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_message_result_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimMessageResultArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimPropertyArgsProperties
{
  PROP_I_TIM_TIM_PROPERTY_ARGS_0,
  PROP_I_TIM_TIM_PROPERTY_ARGS_TPB
};

/* reads a i_tim_tim_property_args object */
static gint32
i_tim_tim_property_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimPropertyArgs * this_object = I_TIM_TIM_PROPERTY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tpb), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tpb = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_property_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimPropertyArgs * this_object = I_TIM_TIM_PROPERTY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimPropertyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tpb", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tpb), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_property_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ITimTimPropertyArgs *self = I_TIM_TIM_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PROPERTY_ARGS_TPB:
      if (self->tpb != NULL)
        g_object_unref (self->tpb);
      self->tpb = g_value_dup_object (value);
      self->__isset_tpb = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_property_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ITimTimPropertyArgs *self = I_TIM_TIM_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_PROPERTY_ARGS_TPB:
      g_value_set_object (value, self->tpb);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_property_args_instance_init (ITimTimPropertyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tpb = g_object_new (TYPE_TIM_PROPERTY_BEAN, NULL);
  object->__isset_tpb = FALSE;
}

static void 
i_tim_tim_property_args_finalize (GObject *object)
{
  ITimTimPropertyArgs *tobject = I_TIM_TIM_PROPERTY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tpb != NULL)
  {
    g_object_unref(tobject->tpb);
    tobject->tpb = NULL;
  }
}

static void
i_tim_tim_property_args_class_init (ITimTimPropertyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_property_args_read;
  struct_class->write = i_tim_tim_property_args_write;

  gobject_class->finalize = i_tim_tim_property_args_finalize;
  gobject_class->get_property = i_tim_tim_property_args_get_property;
  gobject_class->set_property = i_tim_tim_property_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_PROPERTY_ARGS_TPB,
     g_param_spec_object ("tpb",
                         NULL,
                         NULL,
                         TYPE_TIM_PROPERTY_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_property_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimPropertyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_property_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimPropertyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_property_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimPropertyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserAuthArgsProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_0,
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_TID,
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_PWD,
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_AUTH
};

/* reads a i_tim_tim_remote_user_auth_args object */
static gint32
i_tim_tim_remote_user_auth_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserAuthArgs * this_object = I_TIM_TIM_REMOTE_USER_AUTH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pwd != NULL)
          {
            g_free(this_object->pwd);
            this_object->pwd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pwd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pwd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_auth_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserAuthArgs * this_object = I_TIM_TIM_REMOTE_USER_AUTH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserAuthArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pwd", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->pwd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_auth_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimRemoteUserAuthArgs *self = I_TIM_TIM_REMOTE_USER_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_PWD:
      if (self->pwd != NULL)
        g_free (self->pwd);
      self->pwd = g_value_dup_string (value);
      self->__isset_pwd = TRUE;
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_auth_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimRemoteUserAuthArgs *self = I_TIM_TIM_REMOTE_USER_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_PWD:
      g_value_set_string (value, self->pwd);
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_auth_args_instance_init (ITimTimRemoteUserAuthArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->pwd = NULL;
  object->__isset_pwd = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_remote_user_auth_args_finalize (GObject *object)
{
  ITimTimRemoteUserAuthArgs *tobject = I_TIM_TIM_REMOTE_USER_AUTH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->pwd != NULL)
  {
    g_free(tobject->pwd);
    tobject->pwd = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_remote_user_auth_args_class_init (ITimTimRemoteUserAuthArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_auth_args_read;
  struct_class->write = i_tim_tim_remote_user_auth_args_write;

  gobject_class->finalize = i_tim_tim_remote_user_auth_args_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_auth_args_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_auth_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_PWD,
     g_param_spec_string ("pwd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_AUTH_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_auth_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserAuthArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_auth_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserAuthArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_auth_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserAuthArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserAuthResultProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_RESULT_0,
  PROP_I_TIM_TIM_REMOTE_USER_AUTH_RESULT_SUCCESS
};

/* reads a i_tim_tim_remote_user_auth_result object */
static gint32
i_tim_tim_remote_user_auth_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserAuthResult * this_object = I_TIM_TIM_REMOTE_USER_AUTH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_auth_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserAuthResult * this_object = I_TIM_TIM_REMOTE_USER_AUTH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserAuthResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_auth_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimRemoteUserAuthResult *self = I_TIM_TIM_REMOTE_USER_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_auth_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimRemoteUserAuthResult *self = I_TIM_TIM_REMOTE_USER_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_AUTH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_auth_result_instance_init (ITimTimRemoteUserAuthResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_REMOTE_USER_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_remote_user_auth_result_finalize (GObject *object)
{
  ITimTimRemoteUserAuthResult *tobject = I_TIM_TIM_REMOTE_USER_AUTH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_remote_user_auth_result_class_init (ITimTimRemoteUserAuthResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_auth_result_read;
  struct_class->write = i_tim_tim_remote_user_auth_result_write;

  gobject_class->finalize = i_tim_tim_remote_user_auth_result_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_auth_result_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_auth_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_AUTH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_REMOTE_USER_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_auth_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserAuthResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_auth_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserAuthResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_auth_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserAuthResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserGetArgsProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_0,
  PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_TID,
  PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_AUTH
};

/* reads a i_tim_tim_remote_user_get_args object */
static gint32
i_tim_tim_remote_user_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserGetArgs * this_object = I_TIM_TIM_REMOTE_USER_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserGetArgs * this_object = I_TIM_TIM_REMOTE_USER_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_get_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  ITimTimRemoteUserGetArgs *self = I_TIM_TIM_REMOTE_USER_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_get_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  ITimTimRemoteUserGetArgs *self = I_TIM_TIM_REMOTE_USER_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_get_args_instance_init (ITimTimRemoteUserGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_remote_user_get_args_finalize (GObject *object)
{
  ITimTimRemoteUserGetArgs *tobject = I_TIM_TIM_REMOTE_USER_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_remote_user_get_args_class_init (ITimTimRemoteUserGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_get_args_read;
  struct_class->write = i_tim_tim_remote_user_get_args_write;

  gobject_class->finalize = i_tim_tim_remote_user_get_args_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_get_args_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_GET_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserGetResultProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_GET_RESULT_0,
  PROP_I_TIM_TIM_REMOTE_USER_GET_RESULT_SUCCESS
};

/* reads a i_tim_tim_remote_user_get_result object */
static gint32
i_tim_tim_remote_user_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserGetResult * this_object = I_TIM_TIM_REMOTE_USER_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserGetResult * this_object = I_TIM_TIM_REMOTE_USER_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_get_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  ITimTimRemoteUserGetResult *self = I_TIM_TIM_REMOTE_USER_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_get_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  ITimTimRemoteUserGetResult *self = I_TIM_TIM_REMOTE_USER_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_GET_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_get_result_instance_init (ITimTimRemoteUserGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_REMOTE_USER_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_remote_user_get_result_finalize (GObject *object)
{
  ITimTimRemoteUserGetResult *tobject = I_TIM_TIM_REMOTE_USER_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_remote_user_get_result_class_init (ITimTimRemoteUserGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_get_result_read;
  struct_class->write = i_tim_tim_remote_user_get_result_write;

  gobject_class->finalize = i_tim_tim_remote_user_get_result_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_get_result_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_GET_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_REMOTE_USER_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserEditArgsProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_0,
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_TID,
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_UB,
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_AUTH
};

/* reads a i_tim_tim_remote_user_edit_args object */
static gint32
i_tim_tim_remote_user_edit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserEditArgs * this_object = I_TIM_TIM_REMOTE_USER_EDIT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ub), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_edit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserEditArgs * this_object = I_TIM_TIM_REMOTE_USER_EDIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserEditArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tid", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tid), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ub", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ub), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_edit_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimRemoteUserEditArgs *self = I_TIM_TIM_REMOTE_USER_EDIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_TID:
      if (self->tid != NULL)
        g_object_unref (self->tid);
      self->tid = g_value_dup_object (value);
      self->__isset_tid = TRUE;
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_UB:
      if (self->ub != NULL)
        g_object_unref (self->ub);
      self->ub = g_value_dup_object (value);
      self->__isset_ub = TRUE;
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_edit_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimRemoteUserEditArgs *self = I_TIM_TIM_REMOTE_USER_EDIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_TID:
      g_value_set_object (value, self->tid);
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_UB:
      g_value_set_object (value, self->ub);
      break;

    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_edit_args_instance_init (ITimTimRemoteUserEditArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tid = g_object_new (TYPE_TID, NULL);
  object->__isset_tid = FALSE;
  object->ub = g_object_new (TYPE_TIM_USER_BEAN, NULL);
  object->__isset_ub = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_remote_user_edit_args_finalize (GObject *object)
{
  ITimTimRemoteUserEditArgs *tobject = I_TIM_TIM_REMOTE_USER_EDIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tid != NULL)
  {
    g_object_unref(tobject->tid);
    tobject->tid = NULL;
  }
  if (tobject->ub != NULL)
  {
    g_object_unref(tobject->ub);
    tobject->ub = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_remote_user_edit_args_class_init (ITimTimRemoteUserEditArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_edit_args_read;
  struct_class->write = i_tim_tim_remote_user_edit_args_write;

  gobject_class->finalize = i_tim_tim_remote_user_edit_args_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_edit_args_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_edit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_TID,
     g_param_spec_object ("tid",
                         NULL,
                         NULL,
                         TYPE_TID,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_UB,
     g_param_spec_object ("ub",
                         NULL,
                         NULL,
                         TYPE_TIM_USER_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_EDIT_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_edit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserEditArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_edit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserEditArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_edit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserEditArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimRemoteUserEditResultProperties
{
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_RESULT_0,
  PROP_I_TIM_TIM_REMOTE_USER_EDIT_RESULT_SUCCESS
};

/* reads a i_tim_tim_remote_user_edit_result object */
static gint32
i_tim_tim_remote_user_edit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimRemoteUserEditResult * this_object = I_TIM_TIM_REMOTE_USER_EDIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_remote_user_edit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimRemoteUserEditResult * this_object = I_TIM_TIM_REMOTE_USER_EDIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimRemoteUserEditResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_remote_user_edit_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimRemoteUserEditResult *self = I_TIM_TIM_REMOTE_USER_EDIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_remote_user_edit_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimRemoteUserEditResult *self = I_TIM_TIM_REMOTE_USER_EDIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_REMOTE_USER_EDIT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_remote_user_edit_result_instance_init (ITimTimRemoteUserEditResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_REMOTE_USER_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_remote_user_edit_result_finalize (GObject *object)
{
  ITimTimRemoteUserEditResult *tobject = I_TIM_TIM_REMOTE_USER_EDIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_remote_user_edit_result_class_init (ITimTimRemoteUserEditResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_remote_user_edit_result_read;
  struct_class->write = i_tim_tim_remote_user_edit_result_write;

  gobject_class->finalize = i_tim_tim_remote_user_edit_result_finalize;
  gobject_class->get_property = i_tim_tim_remote_user_edit_result_get_property;
  gobject_class->set_property = i_tim_tim_remote_user_edit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_REMOTE_USER_EDIT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_REMOTE_USER_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_remote_user_edit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimRemoteUserEditResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_remote_user_edit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimRemoteUserEditResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_remote_user_edit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimRemoteUserEditResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponsePresenceArgsProperties
{
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_0,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_PBEAN,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_AUTH
};

/* reads a i_tim_tim_response_presence_args object */
static gint32
i_tim_tim_response_presence_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponsePresenceArgs * this_object = I_TIM_TIM_RESPONSE_PRESENCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->pbean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_pbean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_presence_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponsePresenceArgs * this_object = I_TIM_TIM_RESPONSE_PRESENCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponsePresenceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pbean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->pbean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_presence_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  ITimTimResponsePresenceArgs *self = I_TIM_TIM_RESPONSE_PRESENCE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_PBEAN:
      if (self->pbean != NULL)
        g_object_unref (self->pbean);
      self->pbean = g_value_dup_object (value);
      self->__isset_pbean = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_presence_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  ITimTimResponsePresenceArgs *self = I_TIM_TIM_RESPONSE_PRESENCE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_PBEAN:
      g_value_set_object (value, self->pbean);
      break;

    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_presence_args_instance_init (ITimTimResponsePresenceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pbean = g_object_new (TYPE_TIM_P_BEAN, NULL);
  object->__isset_pbean = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_response_presence_args_finalize (GObject *object)
{
  ITimTimResponsePresenceArgs *tobject = I_TIM_TIM_RESPONSE_PRESENCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pbean != NULL)
  {
    g_object_unref(tobject->pbean);
    tobject->pbean = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_response_presence_args_class_init (ITimTimResponsePresenceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_presence_args_read;
  struct_class->write = i_tim_tim_response_presence_args_write;

  gobject_class->finalize = i_tim_tim_response_presence_args_finalize;
  gobject_class->get_property = i_tim_tim_response_presence_args_get_property;
  gobject_class->set_property = i_tim_tim_response_presence_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_PBEAN,
     g_param_spec_object ("pbean",
                         NULL,
                         NULL,
                         TYPE_TIM_P_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_presence_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponsePresenceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_presence_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponsePresenceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_presence_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponsePresenceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponsePresenceResultProperties
{
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_RESULT_0,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_RESULT_SUCCESS
};

/* reads a i_tim_tim_response_presence_result object */
static gint32
i_tim_tim_response_presence_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponsePresenceResult * this_object = I_TIM_TIM_RESPONSE_PRESENCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_presence_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponsePresenceResult * this_object = I_TIM_TIM_RESPONSE_PRESENCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponsePresenceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_presence_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  ITimTimResponsePresenceResult *self = I_TIM_TIM_RESPONSE_PRESENCE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_presence_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  ITimTimResponsePresenceResult *self = I_TIM_TIM_RESPONSE_PRESENCE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_presence_result_instance_init (ITimTimResponsePresenceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_RESPONSE_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_response_presence_result_finalize (GObject *object)
{
  ITimTimResponsePresenceResult *tobject = I_TIM_TIM_RESPONSE_PRESENCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_response_presence_result_class_init (ITimTimResponsePresenceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_presence_result_read;
  struct_class->write = i_tim_tim_response_presence_result_write;

  gobject_class->finalize = i_tim_tim_response_presence_result_finalize;
  gobject_class->get_property = i_tim_tim_response_presence_result_get_property;
  gobject_class->set_property = i_tim_tim_response_presence_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_RESPONSE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_presence_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponsePresenceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_presence_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponsePresenceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_presence_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponsePresenceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageArgsProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_MBEAN,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_AUTH
};

/* reads a i_tim_tim_response_message_args object */
static gint32
i_tim_tim_response_message_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mbean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mbean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mbean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimResponseMessageArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_MBEAN:
      if (self->mbean != NULL)
        g_object_unref (self->mbean);
      self->mbean = g_value_dup_object (value);
      self->__isset_mbean = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ITimTimResponseMessageArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_MBEAN:
      g_value_set_object (value, self->mbean);
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_args_instance_init (ITimTimResponseMessageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mbean = g_object_new (TYPE_TIM_M_BEAN, NULL);
  object->__isset_mbean = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_response_message_args_finalize (GObject *object)
{
  ITimTimResponseMessageArgs *tobject = I_TIM_TIM_RESPONSE_MESSAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mbean != NULL)
  {
    g_object_unref(tobject->mbean);
    tobject->mbean = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_response_message_args_class_init (ITimTimResponseMessageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_args_read;
  struct_class->write = i_tim_tim_response_message_args_write;

  gobject_class->finalize = i_tim_tim_response_message_args_finalize;
  gobject_class->get_property = i_tim_tim_response_message_args_get_property;
  gobject_class->set_property = i_tim_tim_response_message_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_MBEAN,
     g_param_spec_object ("mbean",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageResultProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_RESULT_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_RESULT_SUCCESS
};

/* reads a i_tim_tim_response_message_result object */
static gint32
i_tim_tim_response_message_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimResponseMessageResult *self = I_TIM_TIM_RESPONSE_MESSAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ITimTimResponseMessageResult *self = I_TIM_TIM_RESPONSE_MESSAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_result_instance_init (ITimTimResponseMessageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_RESPONSE_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_response_message_result_finalize (GObject *object)
{
  ITimTimResponseMessageResult *tobject = I_TIM_TIM_RESPONSE_MESSAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_response_message_result_class_init (ITimTimResponseMessageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_result_read;
  struct_class->write = i_tim_tim_response_message_result_write;

  gobject_class->finalize = i_tim_tim_response_message_result_finalize;
  gobject_class->get_property = i_tim_tim_response_message_result_get_property;
  gobject_class->set_property = i_tim_tim_response_message_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_RESPONSE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageIqArgsProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_TIM_MSG_IQ,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_IQ_TYPE,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_AUTH
};

/* reads a i_tim_tim_response_message_iq_args object */
static gint32
i_tim_tim_response_message_iq_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageIqArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timMsgIq), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_timMsgIq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->iqType != NULL)
          {
            g_free(this_object->iqType);
            this_object->iqType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->iqType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_iqType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_iq_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageIqArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageIqArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timMsgIq", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timMsgIq), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "iqType", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->iqType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_iq_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  ITimTimResponseMessageIqArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_TIM_MSG_IQ:
      if (self->timMsgIq != NULL)
        g_object_unref (self->timMsgIq);
      self->timMsgIq = g_value_dup_object (value);
      self->__isset_timMsgIq = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_IQ_TYPE:
      if (self->iqType != NULL)
        g_free (self->iqType);
      self->iqType = g_value_dup_string (value);
      self->__isset_iqType = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_iq_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  ITimTimResponseMessageIqArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_TIM_MSG_IQ:
      g_value_set_object (value, self->timMsgIq);
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_IQ_TYPE:
      g_value_set_string (value, self->iqType);
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_iq_args_instance_init (ITimTimResponseMessageIqArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timMsgIq = g_object_new (TYPE_TIM_MESSAGE_IQ, NULL);
  object->__isset_timMsgIq = FALSE;
  object->iqType = NULL;
  object->__isset_iqType = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_response_message_iq_args_finalize (GObject *object)
{
  ITimTimResponseMessageIqArgs *tobject = I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timMsgIq != NULL)
  {
    g_object_unref(tobject->timMsgIq);
    tobject->timMsgIq = NULL;
  }
  if (tobject->iqType != NULL)
  {
    g_free(tobject->iqType);
    tobject->iqType = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_response_message_iq_args_class_init (ITimTimResponseMessageIqArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_iq_args_read;
  struct_class->write = i_tim_tim_response_message_iq_args_write;

  gobject_class->finalize = i_tim_tim_response_message_iq_args_finalize;
  gobject_class->get_property = i_tim_tim_response_message_iq_args_get_property;
  gobject_class->set_property = i_tim_tim_response_message_iq_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_TIM_MSG_IQ,
     g_param_spec_object ("timMsgIq",
                         NULL,
                         NULL,
                         TYPE_TIM_MESSAGE_IQ,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_IQ_TYPE,
     g_param_spec_string ("iqType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_iq_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageIqArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_iq_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageIqArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_iq_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageIqArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageIqResultProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT_SUCCESS
};

/* reads a i_tim_tim_response_message_iq_result object */
static gint32
i_tim_tim_response_message_iq_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageIqResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_iq_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageIqResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageIqResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_iq_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  ITimTimResponseMessageIqResult *self = I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_iq_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  ITimTimResponseMessageIqResult *self = I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_iq_result_instance_init (ITimTimResponseMessageIqResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_M_BEAN_LIST, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_response_message_iq_result_finalize (GObject *object)
{
  ITimTimResponseMessageIqResult *tobject = I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_response_message_iq_result_class_init (ITimTimResponseMessageIqResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_iq_result_read;
  struct_class->write = i_tim_tim_response_message_iq_result_write;

  gobject_class->finalize = i_tim_tim_response_message_iq_result_finalize;
  gobject_class->get_property = i_tim_tim_response_message_iq_result_get_property;
  gobject_class->set_property = i_tim_tim_response_message_iq_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_IQ_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN_LIST,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_iq_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageIqResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_iq_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageIqResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_iq_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageIqResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponsePresenceListArgsProperties
{
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_0,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_PBEAN_LIST,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_AUTH
};

/* reads a i_tim_tim_response_presence_list_args object */
static gint32
i_tim_tim_response_presence_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponsePresenceListArgs * this_object = I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->pbeanList), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_pbeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_presence_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponsePresenceListArgs * this_object = I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponsePresenceListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pbeanList", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->pbeanList), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_presence_list_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  ITimTimResponsePresenceListArgs *self = I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_PBEAN_LIST:
      if (self->pbeanList != NULL)
        g_object_unref (self->pbeanList);
      self->pbeanList = g_value_dup_object (value);
      self->__isset_pbeanList = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_presence_list_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  ITimTimResponsePresenceListArgs *self = I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_PBEAN_LIST:
      g_value_set_object (value, self->pbeanList);
      break;

    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_presence_list_args_instance_init (ITimTimResponsePresenceListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pbeanList = g_object_new (TYPE_TIM_P_BEAN_LIST, NULL);
  object->__isset_pbeanList = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_response_presence_list_args_finalize (GObject *object)
{
  ITimTimResponsePresenceListArgs *tobject = I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pbeanList != NULL)
  {
    g_object_unref(tobject->pbeanList);
    tobject->pbeanList = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_response_presence_list_args_class_init (ITimTimResponsePresenceListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_presence_list_args_read;
  struct_class->write = i_tim_tim_response_presence_list_args_write;

  gobject_class->finalize = i_tim_tim_response_presence_list_args_finalize;
  gobject_class->get_property = i_tim_tim_response_presence_list_args_get_property;
  gobject_class->set_property = i_tim_tim_response_presence_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_PBEAN_LIST,
     g_param_spec_object ("pbeanList",
                         NULL,
                         NULL,
                         TYPE_TIM_P_BEAN_LIST,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_presence_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponsePresenceListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_presence_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponsePresenceListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_presence_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponsePresenceListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponsePresenceListResultProperties
{
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT_0,
  PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT_SUCCESS
};

/* reads a i_tim_tim_response_presence_list_result object */
static gint32
i_tim_tim_response_presence_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponsePresenceListResult * this_object = I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_presence_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponsePresenceListResult * this_object = I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponsePresenceListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_presence_list_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  ITimTimResponsePresenceListResult *self = I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_presence_list_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  ITimTimResponsePresenceListResult *self = I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_presence_list_result_instance_init (ITimTimResponsePresenceListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_RESPONSE_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_response_presence_list_result_finalize (GObject *object)
{
  ITimTimResponsePresenceListResult *tobject = I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_response_presence_list_result_class_init (ITimTimResponsePresenceListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_presence_list_result_read;
  struct_class->write = i_tim_tim_response_presence_list_result_write;

  gobject_class->finalize = i_tim_tim_response_presence_list_result_finalize;
  gobject_class->get_property = i_tim_tim_response_presence_list_result_get_property;
  gobject_class->set_property = i_tim_tim_response_presence_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_PRESENCE_LIST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_RESPONSE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_presence_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponsePresenceListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_presence_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponsePresenceListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_presence_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponsePresenceListResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageListArgsProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_MBEAN_LIST,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_AUTH
};

/* reads a i_tim_tim_response_message_list_args object */
static gint32
i_tim_tim_response_message_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageListArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mbeanList), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mbeanList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageListArgs * this_object = I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mbeanList", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mbeanList), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_list_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  ITimTimResponseMessageListArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_MBEAN_LIST:
      if (self->mbeanList != NULL)
        g_object_unref (self->mbeanList);
      self->mbeanList = g_value_dup_object (value);
      self->__isset_mbeanList = TRUE;
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_list_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  ITimTimResponseMessageListArgs *self = I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_MBEAN_LIST:
      g_value_set_object (value, self->mbeanList);
      break;

    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_list_args_instance_init (ITimTimResponseMessageListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mbeanList = g_object_new (TYPE_TIM_M_BEAN_LIST, NULL);
  object->__isset_mbeanList = FALSE;
  object->auth = g_object_new (TYPE_TIM_AUTH, NULL);
  object->__isset_auth = FALSE;
}

static void 
i_tim_tim_response_message_list_args_finalize (GObject *object)
{
  ITimTimResponseMessageListArgs *tobject = I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mbeanList != NULL)
  {
    g_object_unref(tobject->mbeanList);
    tobject->mbeanList = NULL;
  }
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
}

static void
i_tim_tim_response_message_list_args_class_init (ITimTimResponseMessageListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_list_args_read;
  struct_class->write = i_tim_tim_response_message_list_args_write;

  gobject_class->finalize = i_tim_tim_response_message_list_args_finalize;
  gobject_class->get_property = i_tim_tim_response_message_list_args_get_property;
  gobject_class->set_property = i_tim_tim_response_message_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_MBEAN_LIST,
     g_param_spec_object ("mbeanList",
                         NULL,
                         NULL,
                         TYPE_TIM_M_BEAN_LIST,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         TYPE_TIM_AUTH,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ITimTimResponseMessageListResultProperties
{
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT_0,
  PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT_SUCCESS
};

/* reads a i_tim_tim_response_message_list_result object */
static gint32
i_tim_tim_response_message_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ITimTimResponseMessageListResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_tim_tim_response_message_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ITimTimResponseMessageListResult * this_object = I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ITimTimResponseMessageListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_tim_tim_response_message_list_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  ITimTimResponseMessageListResult *self = I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_tim_tim_response_message_list_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  ITimTimResponseMessageListResult *self = I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_tim_tim_response_message_list_result_instance_init (ITimTimResponseMessageListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TIM_RESPONSE_BEAN, NULL);
  object->__isset_success = FALSE;
}

static void 
i_tim_tim_response_message_list_result_finalize (GObject *object)
{
  ITimTimResponseMessageListResult *tobject = I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_tim_tim_response_message_list_result_class_init (ITimTimResponseMessageListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_tim_tim_response_message_list_result_read;
  struct_class->write = i_tim_tim_response_message_list_result_write;

  gobject_class->finalize = i_tim_tim_response_message_list_result_finalize;
  gobject_class->get_property = i_tim_tim_response_message_list_result_get_property;
  gobject_class->set_property = i_tim_tim_response_message_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_TIM_TIM_RESPONSE_MESSAGE_LIST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TIM_RESPONSE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_tim_tim_response_message_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ITimTimResponseMessageListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_tim_tim_response_message_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ITimTimResponseMessageListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_tim_tim_response_message_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ITimTimResponseMessageListResultType",
                                   &type_info, 0);
  }

  return type;
}

