/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "tim_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




TimError::~TimError() noexcept {
}


void TimError::__set_errCode(const int32_t val) {
  this->errCode = val;
__isset.errCode = true;
}

void TimError::__set_errMsg(const std::string& val) {
  this->errMsg = val;
__isset.errMsg = true;
}
std::ostream& operator<<(std::ostream& out, const TimError& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimError::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errCode);
          this->__isset.errCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimError");

  if (this->__isset.errCode) {
    xfer += oprot->writeFieldBegin("errCode", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->errCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errMsg) {
    xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->errMsg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimError &a, TimError &b) {
  using ::std::swap;
  swap(a.errCode, b.errCode);
  swap(a.errMsg, b.errMsg);
  swap(a.__isset, b.__isset);
}

TimError::TimError(const TimError& other0) {
  errCode = other0.errCode;
  errMsg = other0.errMsg;
  __isset = other0.__isset;
}
TimError& TimError::operator=(const TimError& other1) {
  errCode = other1.errCode;
  errMsg = other1.errMsg;
  __isset = other1.__isset;
  return *this;
}
void TimError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimError(";
  out << "errCode="; (__isset.errCode ? (out << to_string(errCode)) : (out << "<null>"));
  out << ", " << "errMsg="; (__isset.errMsg ? (out << to_string(errMsg)) : (out << "<null>"));
  out << ")";
}


TimNode::~TimNode() noexcept {
}


void TimNode::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void TimNode::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TimNode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimNode");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimNode &a, TimNode &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TimNode::TimNode(const TimNode& other2) {
  key = other2.key;
  value = other2.value;
  __isset = other2.__isset;
}
TimNode& TimNode::operator=(const TimNode& other3) {
  key = other3.key;
  value = other3.value;
  __isset = other3.__isset;
  return *this;
}
void TimNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimNode(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TimAckBean::~TimAckBean() noexcept {
}


void TimAckBean::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void TimAckBean::__set_ackType(const std::string& val) {
  this->ackType = val;
__isset.ackType = true;
}

void TimAckBean::__set_ackStatus(const std::string& val) {
  this->ackStatus = val;
__isset.ackStatus = true;
}

void TimAckBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimAckBean::__set_err(const TimError& val) {
  this->err = val;
__isset.err = true;
}

void TimAckBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimAckBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimAckBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ackType);
          this->__isset.ackType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ackStatus);
          this->__isset.ackStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->extraList.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->extraList[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              std::string _key14;
              xfer += iprot->readString(_key14);
              std::string& _val15 = this->extraMap[_key14];
              xfer += iprot->readString(_val15);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimAckBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimAckBean");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ackType) {
    xfer += oprot->writeFieldBegin("ackType", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ackType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ackStatus) {
    xfer += oprot->writeFieldBegin("ackStatus", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ackStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter16;
      for (_iter16 = this->extraList.begin(); _iter16 != this->extraList.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.err) {
    xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->err.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter17;
      for (_iter17 = this->extraMap.begin(); _iter17 != this->extraMap.end(); ++_iter17)
      {
        xfer += oprot->writeString(_iter17->first);
        xfer += oprot->writeString(_iter17->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimAckBean &a, TimAckBean &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.ackType, b.ackType);
  swap(a.ackStatus, b.ackStatus);
  swap(a.extraList, b.extraList);
  swap(a.err, b.err);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimAckBean::TimAckBean(const TimAckBean& other18) {
  id = other18.id;
  ackType = other18.ackType;
  ackStatus = other18.ackStatus;
  extraList = other18.extraList;
  err = other18.err;
  extraMap = other18.extraMap;
  __isset = other18.__isset;
}
TimAckBean& TimAckBean::operator=(const TimAckBean& other19) {
  id = other19.id;
  ackType = other19.ackType;
  ackStatus = other19.ackStatus;
  extraList = other19.extraList;
  err = other19.err;
  extraMap = other19.extraMap;
  __isset = other19.__isset;
  return *this;
}
void TimAckBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimAckBean(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "ackType="; (__isset.ackType ? (out << to_string(ackType)) : (out << "<null>"));
  out << ", " << "ackStatus="; (__isset.ackStatus ? (out << to_string(ackStatus)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "err="; (__isset.err ? (out << to_string(err)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimHBean::~TimHBean() noexcept {
}


void TimHBean::__set_chl(const int32_t val) {
  this->chl = val;
}

void TimHBean::__set_platform(const int32_t val) {
  this->platform = val;
__isset.platform = true;
}

void TimHBean::__set_version(const int16_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const TimHBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimHBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_chl = false;
  bool isset_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chl);
          isset_chl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform);
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_chl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimHBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimHBean");

  xfer += oprot->writeFieldBegin("chl", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->chl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->platform);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimHBean &a, TimHBean &b) {
  using ::std::swap;
  swap(a.chl, b.chl);
  swap(a.platform, b.platform);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

TimHBean::TimHBean(const TimHBean& other20) noexcept {
  chl = other20.chl;
  platform = other20.platform;
  version = other20.version;
  __isset = other20.__isset;
}
TimHBean& TimHBean::operator=(const TimHBean& other21) noexcept {
  chl = other21.chl;
  platform = other21.platform;
  version = other21.version;
  __isset = other21.__isset;
  return *this;
}
void TimHBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimHBean(";
  out << "chl=" << to_string(chl);
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "version=" << to_string(version);
  out << ")";
}


TimParam::~TimParam() noexcept {
}


void TimParam::__set_timestamp(const std::string& val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TimParam::__set_version(const int16_t val) {
  this->version = val;
__isset.version = true;
}

void TimParam::__set_lang(const std::string& val) {
  this->lang = val;
__isset.lang = true;
}

void TimParam::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimParam::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}

void TimParam::__set_interflow(const std::string& val) {
  this->interflow = val;
__isset.interflow = true;
}

void TimParam::__set_tls(const std::string& val) {
  this->tls = val;
__isset.tls = true;
}
std::ostream& operator<<(std::ostream& out, const TimParam& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lang);
          this->__isset.lang = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->extraList.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->extraList[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _ktype28;
            ::apache::thrift::protocol::TType _vtype29;
            xfer += iprot->readMapBegin(_ktype28, _vtype29, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              std::string _key32;
              xfer += iprot->readString(_key32);
              std::string& _val33 = this->extraMap[_key32];
              xfer += iprot->readString(_val33);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->interflow);
          this->__isset.interflow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tls);
          this->__isset.tls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimParam");

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lang) {
    xfer += oprot->writeFieldBegin("lang", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->lang);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter34;
      for (_iter34 = this->extraList.begin(); _iter34 != this->extraList.end(); ++_iter34)
      {
        xfer += (*_iter34).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter35;
      for (_iter35 = this->extraMap.begin(); _iter35 != this->extraMap.end(); ++_iter35)
      {
        xfer += oprot->writeString(_iter35->first);
        xfer += oprot->writeString(_iter35->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interflow) {
    xfer += oprot->writeFieldBegin("interflow", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->interflow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tls) {
    xfer += oprot->writeFieldBegin("tls", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->tls);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimParam &a, TimParam &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.version, b.version);
  swap(a.lang, b.lang);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.interflow, b.interflow);
  swap(a.tls, b.tls);
  swap(a.__isset, b.__isset);
}

TimParam::TimParam(const TimParam& other36) {
  timestamp = other36.timestamp;
  version = other36.version;
  lang = other36.lang;
  extraList = other36.extraList;
  extraMap = other36.extraMap;
  interflow = other36.interflow;
  tls = other36.tls;
  __isset = other36.__isset;
}
TimParam& TimParam::operator=(const TimParam& other37) {
  timestamp = other37.timestamp;
  version = other37.version;
  lang = other37.lang;
  extraList = other37.extraList;
  extraMap = other37.extraMap;
  interflow = other37.interflow;
  tls = other37.tls;
  __isset = other37.__isset;
  return *this;
}
void TimParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimParam(";
  out << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "lang="; (__isset.lang ? (out << to_string(lang)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ", " << "interflow="; (__isset.interflow ? (out << to_string(interflow)) : (out << "<null>"));
  out << ", " << "tls="; (__isset.tls ? (out << to_string(tls)) : (out << "<null>"));
  out << ")";
}


TimTime::~TimTime() noexcept {
}


void TimTime::__set_timestamp(const std::string& val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TimTime::__set_formattime(const std::string& val) {
  this->formattime = val;
__isset.formattime = true;
}
std::ostream& operator<<(std::ostream& out, const TimTime& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->formattime);
          this->__isset.formattime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimTime");

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.formattime) {
    xfer += oprot->writeFieldBegin("formattime", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->formattime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimTime &a, TimTime &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.formattime, b.formattime);
  swap(a.__isset, b.__isset);
}

TimTime::TimTime(const TimTime& other38) {
  timestamp = other38.timestamp;
  formattime = other38.formattime;
  __isset = other38.__isset;
}
TimTime& TimTime::operator=(const TimTime& other39) {
  timestamp = other39.timestamp;
  formattime = other39.formattime;
  __isset = other39.__isset;
  return *this;
}
void TimTime::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimTime(";
  out << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "formattime="; (__isset.formattime ? (out << to_string(formattime)) : (out << "<null>"));
  out << ")";
}


TimArea::~TimArea() noexcept {
}


void TimArea::__set_country(const std::string& val) {
  this->country = val;
__isset.country = true;
}

void TimArea::__set_province(const std::string& val) {
  this->province = val;
__isset.province = true;
}

void TimArea::__set_city(const std::string& val) {
  this->city = val;
__isset.city = true;
}

void TimArea::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimArea::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimArea& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimArea::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->province);
          this->__isset.province = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->city);
          this->__isset.city = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->extraList.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->extraList[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _ktype46;
            ::apache::thrift::protocol::TType _vtype47;
            xfer += iprot->readMapBegin(_ktype46, _vtype47, _size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              std::string _key50;
              xfer += iprot->readString(_key50);
              std::string& _val51 = this->extraMap[_key50];
              xfer += iprot->readString(_val51);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimArea::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimArea");

  if (this->__isset.country) {
    xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->country);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.province) {
    xfer += oprot->writeFieldBegin("province", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->province);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.city) {
    xfer += oprot->writeFieldBegin("city", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->city);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter52;
      for (_iter52 = this->extraList.begin(); _iter52 != this->extraList.end(); ++_iter52)
      {
        xfer += (*_iter52).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter53;
      for (_iter53 = this->extraMap.begin(); _iter53 != this->extraMap.end(); ++_iter53)
      {
        xfer += oprot->writeString(_iter53->first);
        xfer += oprot->writeString(_iter53->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimArea &a, TimArea &b) {
  using ::std::swap;
  swap(a.country, b.country);
  swap(a.province, b.province);
  swap(a.city, b.city);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimArea::TimArea(const TimArea& other54) {
  country = other54.country;
  province = other54.province;
  city = other54.city;
  extraList = other54.extraList;
  extraMap = other54.extraMap;
  __isset = other54.__isset;
}
TimArea& TimArea::operator=(const TimArea& other55) {
  country = other55.country;
  province = other55.province;
  city = other55.city;
  extraList = other55.extraList;
  extraMap = other55.extraMap;
  __isset = other55.__isset;
  return *this;
}
void TimArea::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimArea(";
  out << "country="; (__isset.country ? (out << to_string(country)) : (out << "<null>"));
  out << ", " << "province="; (__isset.province ? (out << to_string(province)) : (out << "<null>"));
  out << ", " << "city="; (__isset.city ? (out << to_string(city)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


Tid::~Tid() noexcept {
}


void Tid::__set_name(const std::string& val) {
  this->name = val;
}

void Tid::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void Tid::__set_resource(const std::string& val) {
  this->resource = val;
__isset.resource = true;
}

void Tid::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void Tid::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void Tid::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const Tid& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Tid::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->extraList.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->extraList[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->extraMap[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Tid::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Tid");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource) {
    xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->resource);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter68;
      for (_iter68 = this->extraList.begin(); _iter68 != this->extraList.end(); ++_iter68)
      {
        xfer += (*_iter68).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter69;
      for (_iter69 = this->extraMap.begin(); _iter69 != this->extraMap.end(); ++_iter69)
      {
        xfer += oprot->writeString(_iter69->first);
        xfer += oprot->writeString(_iter69->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tid &a, Tid &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.domain, b.domain);
  swap(a.resource, b.resource);
  swap(a.type, b.type);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

Tid::Tid(const Tid& other70) {
  name = other70.name;
  domain = other70.domain;
  resource = other70.resource;
  type = other70.type;
  extraList = other70.extraList;
  extraMap = other70.extraMap;
  __isset = other70.__isset;
}
Tid& Tid::operator=(const Tid& other71) {
  name = other71.name;
  domain = other71.domain;
  resource = other71.resource;
  type = other71.type;
  extraList = other71.extraList;
  extraMap = other71.extraMap;
  __isset = other71.__isset;
  return *this;
}
void Tid::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Tid(";
  out << "name=" << to_string(name);
  out << ", " << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "resource="; (__isset.resource ? (out << to_string(resource)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimUserBean::~TimUserBean() noexcept {
}


void TimUserBean::__set_tid(const Tid& val) {
  this->tid = val;
__isset.tid = true;
}

void TimUserBean::__set_nickname(const std::string& val) {
  this->nickname = val;
__isset.nickname = true;
}

void TimUserBean::__set_remarkname(const std::string& val) {
  this->remarkname = val;
__isset.remarkname = true;
}

void TimUserBean::__set_brithday(const std::string& val) {
  this->brithday = val;
__isset.brithday = true;
}

void TimUserBean::__set_gender(const int16_t val) {
  this->gender = val;
__isset.gender = true;
}

void TimUserBean::__set_headurl(const std::string& val) {
  this->headurl = val;
__isset.headurl = true;
}

void TimUserBean::__set_area(const TimArea& val) {
  this->area = val;
__isset.area = true;
}

void TimUserBean::__set_headbyte(const std::string& val) {
  this->headbyte = val;
__isset.headbyte = true;
}

void TimUserBean::__set_photoBytes(const std::vector<std::string> & val) {
  this->photoBytes = val;
__isset.photoBytes = true;
}

void TimUserBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimUserBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimUserBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimUserBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tid.read(iprot);
          this->__isset.tid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remarkname);
          this->__isset.remarkname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->brithday);
          this->__isset.brithday = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->headurl);
          this->__isset.headurl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->area.read(iprot);
          this->__isset.area = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->headbyte);
          this->__isset.headbyte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->photoBytes.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->photoBytes.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readBinary(this->photoBytes[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.photoBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->extraList.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->extraList[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readString(_key87);
              std::string& _val88 = this->extraMap[_key87];
              xfer += iprot->readString(_val88);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimUserBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimUserBean");

  if (this->__isset.tid) {
    xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->tid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nickname) {
    xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->nickname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remarkname) {
    xfer += oprot->writeFieldBegin("remarkname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->remarkname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brithday) {
    xfer += oprot->writeFieldBegin("brithday", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->brithday);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gender) {
    xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->gender);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.headurl) {
    xfer += oprot->writeFieldBegin("headurl", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->headurl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.area) {
    xfer += oprot->writeFieldBegin("area", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->area.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.headbyte) {
    xfer += oprot->writeFieldBegin("headbyte", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeBinary(this->headbyte);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.photoBytes) {
    xfer += oprot->writeFieldBegin("photoBytes", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->photoBytes.size()));
      std::vector<std::string> ::const_iterator _iter89;
      for (_iter89 = this->photoBytes.begin(); _iter89 != this->photoBytes.end(); ++_iter89)
      {
        xfer += oprot->writeBinary((*_iter89));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter90;
      for (_iter90 = this->extraList.begin(); _iter90 != this->extraList.end(); ++_iter90)
      {
        xfer += (*_iter90).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter91;
      for (_iter91 = this->extraMap.begin(); _iter91 != this->extraMap.end(); ++_iter91)
      {
        xfer += oprot->writeString(_iter91->first);
        xfer += oprot->writeString(_iter91->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimUserBean &a, TimUserBean &b) {
  using ::std::swap;
  swap(a.tid, b.tid);
  swap(a.nickname, b.nickname);
  swap(a.remarkname, b.remarkname);
  swap(a.brithday, b.brithday);
  swap(a.gender, b.gender);
  swap(a.headurl, b.headurl);
  swap(a.area, b.area);
  swap(a.headbyte, b.headbyte);
  swap(a.photoBytes, b.photoBytes);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimUserBean::TimUserBean(const TimUserBean& other92) {
  tid = other92.tid;
  nickname = other92.nickname;
  remarkname = other92.remarkname;
  brithday = other92.brithday;
  gender = other92.gender;
  headurl = other92.headurl;
  area = other92.area;
  headbyte = other92.headbyte;
  photoBytes = other92.photoBytes;
  extraList = other92.extraList;
  extraMap = other92.extraMap;
  __isset = other92.__isset;
}
TimUserBean& TimUserBean::operator=(const TimUserBean& other93) {
  tid = other93.tid;
  nickname = other93.nickname;
  remarkname = other93.remarkname;
  brithday = other93.brithday;
  gender = other93.gender;
  headurl = other93.headurl;
  area = other93.area;
  headbyte = other93.headbyte;
  photoBytes = other93.photoBytes;
  extraList = other93.extraList;
  extraMap = other93.extraMap;
  __isset = other93.__isset;
  return *this;
}
void TimUserBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimUserBean(";
  out << "tid="; (__isset.tid ? (out << to_string(tid)) : (out << "<null>"));
  out << ", " << "nickname="; (__isset.nickname ? (out << to_string(nickname)) : (out << "<null>"));
  out << ", " << "remarkname="; (__isset.remarkname ? (out << to_string(remarkname)) : (out << "<null>"));
  out << ", " << "brithday="; (__isset.brithday ? (out << to_string(brithday)) : (out << "<null>"));
  out << ", " << "gender="; (__isset.gender ? (out << to_string(gender)) : (out << "<null>"));
  out << ", " << "headurl="; (__isset.headurl ? (out << to_string(headurl)) : (out << "<null>"));
  out << ", " << "area="; (__isset.area ? (out << to_string(area)) : (out << "<null>"));
  out << ", " << "headbyte="; (__isset.headbyte ? (out << to_string(headbyte)) : (out << "<null>"));
  out << ", " << "photoBytes="; (__isset.photoBytes ? (out << to_string(photoBytes)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimRoom::~TimRoom() noexcept {
}


void TimRoom::__set_tid(const Tid& val) {
  this->tid = val;
__isset.tid = true;
}

void TimRoom::__set_founderTid(const Tid& val) {
  this->founderTid = val;
__isset.founderTid = true;
}

void TimRoom::__set_HostsTid(const std::vector<Tid> & val) {
  this->HostsTid = val;
__isset.HostsTid = true;
}

void TimRoom::__set_membersTid(const std::vector<Tid> & val) {
  this->membersTid = val;
__isset.membersTid = true;
}

void TimRoom::__set_headurl(const std::string& val) {
  this->headurl = val;
__isset.headurl = true;
}

void TimRoom::__set_roomName(const std::string& val) {
  this->roomName = val;
__isset.roomName = true;
}

void TimRoom::__set_desc(const std::string& val) {
  this->desc = val;
__isset.desc = true;
}

void TimRoom::__set_createTime(const TimTime& val) {
  this->createTime = val;
__isset.createTime = true;
}

void TimRoom::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimRoom::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimRoom& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tid.read(iprot);
          this->__isset.tid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->founderTid.read(iprot);
          this->__isset.founderTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->HostsTid.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->HostsTid.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->HostsTid[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.HostsTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->membersTid.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->membersTid.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += this->membersTid[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.membersTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->headurl);
          this->__isset.headurl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roomName);
          this->__isset.roomName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          this->__isset.desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->createTime.read(iprot);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->extraList.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->extraList[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _ktype110;
            ::apache::thrift::protocol::TType _vtype111;
            xfer += iprot->readMapBegin(_ktype110, _vtype111, _size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              std::string _key114;
              xfer += iprot->readString(_key114);
              std::string& _val115 = this->extraMap[_key114];
              xfer += iprot->readString(_val115);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimRoom");

  if (this->__isset.tid) {
    xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->tid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.founderTid) {
    xfer += oprot->writeFieldBegin("founderTid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->founderTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.HostsTid) {
    xfer += oprot->writeFieldBegin("HostsTid", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->HostsTid.size()));
      std::vector<Tid> ::const_iterator _iter116;
      for (_iter116 = this->HostsTid.begin(); _iter116 != this->HostsTid.end(); ++_iter116)
      {
        xfer += (*_iter116).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.membersTid) {
    xfer += oprot->writeFieldBegin("membersTid", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->membersTid.size()));
      std::vector<Tid> ::const_iterator _iter117;
      for (_iter117 = this->membersTid.begin(); _iter117 != this->membersTid.end(); ++_iter117)
      {
        xfer += (*_iter117).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.headurl) {
    xfer += oprot->writeFieldBegin("headurl", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->headurl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.roomName) {
    xfer += oprot->writeFieldBegin("roomName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->roomName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.desc) {
    xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->desc);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createTime) {
    xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->createTime.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter118;
      for (_iter118 = this->extraList.begin(); _iter118 != this->extraList.end(); ++_iter118)
      {
        xfer += (*_iter118).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter119;
      for (_iter119 = this->extraMap.begin(); _iter119 != this->extraMap.end(); ++_iter119)
      {
        xfer += oprot->writeString(_iter119->first);
        xfer += oprot->writeString(_iter119->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimRoom &a, TimRoom &b) {
  using ::std::swap;
  swap(a.tid, b.tid);
  swap(a.founderTid, b.founderTid);
  swap(a.HostsTid, b.HostsTid);
  swap(a.membersTid, b.membersTid);
  swap(a.headurl, b.headurl);
  swap(a.roomName, b.roomName);
  swap(a.desc, b.desc);
  swap(a.createTime, b.createTime);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimRoom::TimRoom(const TimRoom& other120) {
  tid = other120.tid;
  founderTid = other120.founderTid;
  HostsTid = other120.HostsTid;
  membersTid = other120.membersTid;
  headurl = other120.headurl;
  roomName = other120.roomName;
  desc = other120.desc;
  createTime = other120.createTime;
  extraList = other120.extraList;
  extraMap = other120.extraMap;
  __isset = other120.__isset;
}
TimRoom& TimRoom::operator=(const TimRoom& other121) {
  tid = other121.tid;
  founderTid = other121.founderTid;
  HostsTid = other121.HostsTid;
  membersTid = other121.membersTid;
  headurl = other121.headurl;
  roomName = other121.roomName;
  desc = other121.desc;
  createTime = other121.createTime;
  extraList = other121.extraList;
  extraMap = other121.extraMap;
  __isset = other121.__isset;
  return *this;
}
void TimRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimRoom(";
  out << "tid="; (__isset.tid ? (out << to_string(tid)) : (out << "<null>"));
  out << ", " << "founderTid="; (__isset.founderTid ? (out << to_string(founderTid)) : (out << "<null>"));
  out << ", " << "HostsTid="; (__isset.HostsTid ? (out << to_string(HostsTid)) : (out << "<null>"));
  out << ", " << "membersTid="; (__isset.membersTid ? (out << to_string(membersTid)) : (out << "<null>"));
  out << ", " << "headurl="; (__isset.headurl ? (out << to_string(headurl)) : (out << "<null>"));
  out << ", " << "roomName="; (__isset.roomName ? (out << to_string(roomName)) : (out << "<null>"));
  out << ", " << "desc="; (__isset.desc ? (out << to_string(desc)) : (out << "<null>"));
  out << ", " << "createTime="; (__isset.createTime ? (out << to_string(createTime)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimPBean::~TimPBean() noexcept {
}


void TimPBean::__set_threadId(const std::string& val) {
  this->threadId = val;
}

void TimPBean::__set_fromTid(const Tid& val) {
  this->fromTid = val;
__isset.fromTid = true;
}

void TimPBean::__set_toTid(const Tid& val) {
  this->toTid = val;
__isset.toTid = true;
}

void TimPBean::__set_status(const std::string& val) {
  this->status = val;
__isset.status = true;
}

void TimPBean::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void TimPBean::__set_priority(const int32_t val) {
  this->priority = val;
__isset.priority = true;
}

void TimPBean::__set_show(const std::string& val) {
  this->show = val;
__isset.show = true;
}

void TimPBean::__set_leaguerTid(const Tid& val) {
  this->leaguerTid = val;
__isset.leaguerTid = true;
}

void TimPBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimPBean::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimPBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimPBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimPBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fromTid.read(iprot);
          this->__isset.fromTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->toTid.read(iprot);
          this->__isset.toTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show);
          this->__isset.show = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leaguerTid.read(iprot);
          this->__isset.leaguerTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->extraList.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->extraList[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _ktype128;
            ::apache::thrift::protocol::TType _vtype129;
            xfer += iprot->readMapBegin(_ktype128, _vtype129, _size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              std::string _key132;
              xfer += iprot->readString(_key132);
              std::string& _val133 = this->extraMap[_key132];
              xfer += iprot->readString(_val133);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimPBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimPBean");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fromTid) {
    xfer += oprot->writeFieldBegin("fromTid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fromTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toTid) {
    xfer += oprot->writeFieldBegin("toTid", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->toTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority) {
    xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->priority);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show) {
    xfer += oprot->writeFieldBegin("show", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->show);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.leaguerTid) {
    xfer += oprot->writeFieldBegin("leaguerTid", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->leaguerTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter134;
      for (_iter134 = this->extraList.begin(); _iter134 != this->extraList.end(); ++_iter134)
      {
        xfer += (*_iter134).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter135;
      for (_iter135 = this->extraMap.begin(); _iter135 != this->extraMap.end(); ++_iter135)
      {
        xfer += oprot->writeString(_iter135->first);
        xfer += oprot->writeString(_iter135->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimPBean &a, TimPBean &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.fromTid, b.fromTid);
  swap(a.toTid, b.toTid);
  swap(a.status, b.status);
  swap(a.type, b.type);
  swap(a.priority, b.priority);
  swap(a.show, b.show);
  swap(a.leaguerTid, b.leaguerTid);
  swap(a.extraList, b.extraList);
  swap(a.error, b.error);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimPBean::TimPBean(const TimPBean& other136) {
  threadId = other136.threadId;
  fromTid = other136.fromTid;
  toTid = other136.toTid;
  status = other136.status;
  type = other136.type;
  priority = other136.priority;
  show = other136.show;
  leaguerTid = other136.leaguerTid;
  extraList = other136.extraList;
  error = other136.error;
  extraMap = other136.extraMap;
  __isset = other136.__isset;
}
TimPBean& TimPBean::operator=(const TimPBean& other137) {
  threadId = other137.threadId;
  fromTid = other137.fromTid;
  toTid = other137.toTid;
  status = other137.status;
  type = other137.type;
  priority = other137.priority;
  show = other137.show;
  leaguerTid = other137.leaguerTid;
  extraList = other137.extraList;
  error = other137.error;
  extraMap = other137.extraMap;
  __isset = other137.__isset;
  return *this;
}
void TimPBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimPBean(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "fromTid="; (__isset.fromTid ? (out << to_string(fromTid)) : (out << "<null>"));
  out << ", " << "toTid="; (__isset.toTid ? (out << to_string(toTid)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "priority="; (__isset.priority ? (out << to_string(priority)) : (out << "<null>"));
  out << ", " << "show="; (__isset.show ? (out << to_string(show)) : (out << "<null>"));
  out << ", " << "leaguerTid="; (__isset.leaguerTid ? (out << to_string(leaguerTid)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimMBean::~TimMBean() noexcept {
}


void TimMBean::__set_threadId(const std::string& val) {
  this->threadId = val;
}

void TimMBean::__set_mid(const std::string& val) {
  this->mid = val;
__isset.mid = true;
}

void TimMBean::__set_fromTid(const Tid& val) {
  this->fromTid = val;
__isset.fromTid = true;
}

void TimMBean::__set_toTid(const Tid& val) {
  this->toTid = val;
__isset.toTid = true;
}

void TimMBean::__set_body(const std::string& val) {
  this->body = val;
__isset.body = true;
}

void TimMBean::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void TimMBean::__set_msgType(const int16_t val) {
  this->msgType = val;
__isset.msgType = true;
}

void TimMBean::__set_offline(const TimTime& val) {
  this->offline = val;
__isset.offline = true;
}

void TimMBean::__set_leaguerTid(const Tid& val) {
  this->leaguerTid = val;
__isset.leaguerTid = true;
}

void TimMBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimMBean::__set_timestamp(const std::string& val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TimMBean::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimMBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}

void TimMBean::__set_readstatus(const int16_t val) {
  this->readstatus = val;
__isset.readstatus = true;
}
std::ostream& operator<<(std::ostream& out, const TimMBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimMBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fromTid.read(iprot);
          this->__isset.fromTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->toTid.read(iprot);
          this->__isset.toTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offline.read(iprot);
          this->__isset.offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leaguerTid.read(iprot);
          this->__isset.leaguerTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->extraList.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += this->extraList[_i142].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _ktype144;
            ::apache::thrift::protocol::TType _vtype145;
            xfer += iprot->readMapBegin(_ktype144, _vtype145, _size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              std::string _key148;
              xfer += iprot->readString(_key148);
              std::string& _val149 = this->extraMap[_key148];
              xfer += iprot->readString(_val149);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->readstatus);
          this->__isset.readstatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimMBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimMBean");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mid) {
    xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->mid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fromTid) {
    xfer += oprot->writeFieldBegin("fromTid", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->fromTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toTid) {
    xfer += oprot->writeFieldBegin("toTid", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->toTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->body);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.msgType) {
    xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->msgType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline) {
    xfer += oprot->writeFieldBegin("offline", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->offline.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.leaguerTid) {
    xfer += oprot->writeFieldBegin("leaguerTid", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->leaguerTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter150;
      for (_iter150 = this->extraList.begin(); _iter150 != this->extraList.end(); ++_iter150)
      {
        xfer += (*_iter150).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter151;
      for (_iter151 = this->extraMap.begin(); _iter151 != this->extraMap.end(); ++_iter151)
      {
        xfer += oprot->writeString(_iter151->first);
        xfer += oprot->writeString(_iter151->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readstatus) {
    xfer += oprot->writeFieldBegin("readstatus", ::apache::thrift::protocol::T_I16, 14);
    xfer += oprot->writeI16(this->readstatus);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimMBean &a, TimMBean &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.mid, b.mid);
  swap(a.fromTid, b.fromTid);
  swap(a.toTid, b.toTid);
  swap(a.body, b.body);
  swap(a.type, b.type);
  swap(a.msgType, b.msgType);
  swap(a.offline, b.offline);
  swap(a.leaguerTid, b.leaguerTid);
  swap(a.extraList, b.extraList);
  swap(a.timestamp, b.timestamp);
  swap(a.error, b.error);
  swap(a.extraMap, b.extraMap);
  swap(a.readstatus, b.readstatus);
  swap(a.__isset, b.__isset);
}

TimMBean::TimMBean(const TimMBean& other152) {
  threadId = other152.threadId;
  mid = other152.mid;
  fromTid = other152.fromTid;
  toTid = other152.toTid;
  body = other152.body;
  type = other152.type;
  msgType = other152.msgType;
  offline = other152.offline;
  leaguerTid = other152.leaguerTid;
  extraList = other152.extraList;
  timestamp = other152.timestamp;
  error = other152.error;
  extraMap = other152.extraMap;
  readstatus = other152.readstatus;
  __isset = other152.__isset;
}
TimMBean& TimMBean::operator=(const TimMBean& other153) {
  threadId = other153.threadId;
  mid = other153.mid;
  fromTid = other153.fromTid;
  toTid = other153.toTid;
  body = other153.body;
  type = other153.type;
  msgType = other153.msgType;
  offline = other153.offline;
  leaguerTid = other153.leaguerTid;
  extraList = other153.extraList;
  timestamp = other153.timestamp;
  error = other153.error;
  extraMap = other153.extraMap;
  readstatus = other153.readstatus;
  __isset = other153.__isset;
  return *this;
}
void TimMBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimMBean(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "mid="; (__isset.mid ? (out << to_string(mid)) : (out << "<null>"));
  out << ", " << "fromTid="; (__isset.fromTid ? (out << to_string(fromTid)) : (out << "<null>"));
  out << ", " << "toTid="; (__isset.toTid ? (out << to_string(toTid)) : (out << "<null>"));
  out << ", " << "body="; (__isset.body ? (out << to_string(body)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "msgType="; (__isset.msgType ? (out << to_string(msgType)) : (out << "<null>"));
  out << ", " << "offline="; (__isset.offline ? (out << to_string(offline)) : (out << "<null>"));
  out << ", " << "leaguerTid="; (__isset.leaguerTid ? (out << to_string(leaguerTid)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ", " << "readstatus="; (__isset.readstatus ? (out << to_string(readstatus)) : (out << "<null>"));
  out << ")";
}


TimIqBean::~TimIqBean() noexcept {
}


void TimIqBean::__set_threadId(const std::string& val) {
  this->threadId = val;
}

void TimIqBean::__set_fromTid(const Tid& val) {
  this->fromTid = val;
__isset.fromTid = true;
}

void TimIqBean::__set_toTid(const Tid& val) {
  this->toTid = val;
__isset.toTid = true;
}

void TimIqBean::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void TimIqBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimIqBean::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimIqBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimIqBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimIqBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fromTid.read(iprot);
          this->__isset.fromTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->toTid.read(iprot);
          this->__isset.toTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->extraList.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += this->extraList[_i158].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _ktype160;
            ::apache::thrift::protocol::TType _vtype161;
            xfer += iprot->readMapBegin(_ktype160, _vtype161, _size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              std::string _key164;
              xfer += iprot->readString(_key164);
              std::string& _val165 = this->extraMap[_key164];
              xfer += iprot->readString(_val165);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimIqBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimIqBean");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fromTid) {
    xfer += oprot->writeFieldBegin("fromTid", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fromTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toTid) {
    xfer += oprot->writeFieldBegin("toTid", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->toTid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter166;
      for (_iter166 = this->extraList.begin(); _iter166 != this->extraList.end(); ++_iter166)
      {
        xfer += (*_iter166).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter167;
      for (_iter167 = this->extraMap.begin(); _iter167 != this->extraMap.end(); ++_iter167)
      {
        xfer += oprot->writeString(_iter167->first);
        xfer += oprot->writeString(_iter167->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimIqBean &a, TimIqBean &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.fromTid, b.fromTid);
  swap(a.toTid, b.toTid);
  swap(a.type, b.type);
  swap(a.extraList, b.extraList);
  swap(a.error, b.error);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimIqBean::TimIqBean(const TimIqBean& other168) {
  threadId = other168.threadId;
  fromTid = other168.fromTid;
  toTid = other168.toTid;
  type = other168.type;
  extraList = other168.extraList;
  error = other168.error;
  extraMap = other168.extraMap;
  __isset = other168.__isset;
}
TimIqBean& TimIqBean::operator=(const TimIqBean& other169) {
  threadId = other169.threadId;
  fromTid = other169.fromTid;
  toTid = other169.toTid;
  type = other169.type;
  extraList = other169.extraList;
  error = other169.error;
  extraMap = other169.extraMap;
  __isset = other169.__isset;
  return *this;
}
void TimIqBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimIqBean(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "fromTid="; (__isset.fromTid ? (out << to_string(fromTid)) : (out << "<null>"));
  out << ", " << "toTid="; (__isset.toTid ? (out << to_string(toTid)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimRoster::~TimRoster() noexcept {
}


void TimRoster::__set_subscription(const std::string& val) {
  this->subscription = val;
}

void TimRoster::__set_tid(const Tid& val) {
  this->tid = val;
}

void TimRoster::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void TimRoster::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimRoster& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimRoster::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_subscription = false;
  bool isset_tid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subscription);
          isset_subscription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tid.read(iprot);
          isset_tid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size170;
            ::apache::thrift::protocol::TType _ktype171;
            ::apache::thrift::protocol::TType _vtype172;
            xfer += iprot->readMapBegin(_ktype171, _vtype172, _size170);
            uint32_t _i174;
            for (_i174 = 0; _i174 < _size170; ++_i174)
            {
              std::string _key175;
              xfer += iprot->readString(_key175);
              std::string& _val176 = this->extraMap[_key175];
              xfer += iprot->readString(_val176);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_subscription)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimRoster::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimRoster");

  xfer += oprot->writeFieldBegin("subscription", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->subscription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tid.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter177;
      for (_iter177 = this->extraMap.begin(); _iter177 != this->extraMap.end(); ++_iter177)
      {
        xfer += oprot->writeString(_iter177->first);
        xfer += oprot->writeString(_iter177->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimRoster &a, TimRoster &b) {
  using ::std::swap;
  swap(a.subscription, b.subscription);
  swap(a.tid, b.tid);
  swap(a.name, b.name);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimRoster::TimRoster(const TimRoster& other178) {
  subscription = other178.subscription;
  tid = other178.tid;
  name = other178.name;
  extraMap = other178.extraMap;
  __isset = other178.__isset;
}
TimRoster& TimRoster::operator=(const TimRoster& other179) {
  subscription = other179.subscription;
  tid = other179.tid;
  name = other179.name;
  extraMap = other179.extraMap;
  __isset = other179.__isset;
  return *this;
}
void TimRoster::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimRoster(";
  out << "subscription=" << to_string(subscription);
  out << ", " << "tid=" << to_string(tid);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimRemoteUserBean::~TimRemoteUserBean() noexcept {
}


void TimRemoteUserBean::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimRemoteUserBean::__set_ub(const TimUserBean& val) {
  this->ub = val;
__isset.ub = true;
}

void TimRemoteUserBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimRemoteUserBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimRemoteUserBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ub.read(iprot);
          this->__isset.ub = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _ktype181;
            ::apache::thrift::protocol::TType _vtype182;
            xfer += iprot->readMapBegin(_ktype181, _vtype182, _size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              std::string _key185;
              xfer += iprot->readString(_key185);
              std::string& _val186 = this->extraMap[_key185];
              xfer += iprot->readString(_val186);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimRemoteUserBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimRemoteUserBean");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ub) {
    xfer += oprot->writeFieldBegin("ub", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ub.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter187;
      for (_iter187 = this->extraMap.begin(); _iter187 != this->extraMap.end(); ++_iter187)
      {
        xfer += oprot->writeString(_iter187->first);
        xfer += oprot->writeString(_iter187->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimRemoteUserBean &a, TimRemoteUserBean &b) {
  using ::std::swap;
  swap(a.error, b.error);
  swap(a.ub, b.ub);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimRemoteUserBean::TimRemoteUserBean(const TimRemoteUserBean& other188) {
  error = other188.error;
  ub = other188.ub;
  extraMap = other188.extraMap;
  __isset = other188.__isset;
}
TimRemoteUserBean& TimRemoteUserBean::operator=(const TimRemoteUserBean& other189) {
  error = other189.error;
  ub = other189.ub;
  extraMap = other189.extraMap;
  __isset = other189.__isset;
  return *this;
}
void TimRemoteUserBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimRemoteUserBean(";
  out << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "ub="; (__isset.ub ? (out << to_string(ub)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimRemoteRoom::~TimRemoteRoom() noexcept {
}


void TimRemoteRoom::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimRemoteRoom::__set_room(const TimRoom& val) {
  this->room = val;
__isset.room = true;
}

void TimRemoteRoom::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimRemoteRoom& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimRemoteRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->room.read(iprot);
          this->__isset.room = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _ktype191;
            ::apache::thrift::protocol::TType _vtype192;
            xfer += iprot->readMapBegin(_ktype191, _vtype192, _size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              std::string _key195;
              xfer += iprot->readString(_key195);
              std::string& _val196 = this->extraMap[_key195];
              xfer += iprot->readString(_val196);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimRemoteRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimRemoteRoom");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.room) {
    xfer += oprot->writeFieldBegin("room", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->room.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter197;
      for (_iter197 = this->extraMap.begin(); _iter197 != this->extraMap.end(); ++_iter197)
      {
        xfer += oprot->writeString(_iter197->first);
        xfer += oprot->writeString(_iter197->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimRemoteRoom &a, TimRemoteRoom &b) {
  using ::std::swap;
  swap(a.error, b.error);
  swap(a.room, b.room);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimRemoteRoom::TimRemoteRoom(const TimRemoteRoom& other198) {
  error = other198.error;
  room = other198.room;
  extraMap = other198.extraMap;
  __isset = other198.__isset;
}
TimRemoteRoom& TimRemoteRoom::operator=(const TimRemoteRoom& other199) {
  error = other199.error;
  room = other199.room;
  extraMap = other199.extraMap;
  __isset = other199.__isset;
  return *this;
}
void TimRemoteRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimRemoteRoom(";
  out << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "room="; (__isset.room ? (out << to_string(room)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimResponseBean::~TimResponseBean() noexcept {
}


void TimResponseBean::__set_threadId(const std::string& val) {
  this->threadId = val;
__isset.threadId = true;
}

void TimResponseBean::__set_error(const TimError& val) {
  this->error = val;
__isset.error = true;
}

void TimResponseBean::__set_extraList(const std::vector<TimNode> & val) {
  this->extraList = val;
__isset.extraList = true;
}

void TimResponseBean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimResponseBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimResponseBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          this->__isset.threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extraList.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->extraList.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->extraList[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extraList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _ktype206;
            ::apache::thrift::protocol::TType _vtype207;
            xfer += iprot->readMapBegin(_ktype206, _vtype207, _size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              std::string _key210;
              xfer += iprot->readString(_key210);
              std::string& _val211 = this->extraMap[_key210];
              xfer += iprot->readString(_val211);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimResponseBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimResponseBean");

  if (this->__isset.threadId) {
    xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->threadId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraList) {
    xfer += oprot->writeFieldBegin("extraList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extraList.size()));
      std::vector<TimNode> ::const_iterator _iter212;
      for (_iter212 = this->extraList.begin(); _iter212 != this->extraList.end(); ++_iter212)
      {
        xfer += (*_iter212).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter213;
      for (_iter213 = this->extraMap.begin(); _iter213 != this->extraMap.end(); ++_iter213)
      {
        xfer += oprot->writeString(_iter213->first);
        xfer += oprot->writeString(_iter213->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimResponseBean &a, TimResponseBean &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.error, b.error);
  swap(a.extraList, b.extraList);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimResponseBean::TimResponseBean(const TimResponseBean& other214) {
  threadId = other214.threadId;
  error = other214.error;
  extraList = other214.extraList;
  extraMap = other214.extraMap;
  __isset = other214.__isset;
}
TimResponseBean& TimResponseBean::operator=(const TimResponseBean& other215) {
  threadId = other215.threadId;
  error = other215.error;
  extraList = other215.extraList;
  extraMap = other215.extraMap;
  __isset = other215.__isset;
  return *this;
}
void TimResponseBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimResponseBean(";
  out << "threadId="; (__isset.threadId ? (out << to_string(threadId)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "extraList="; (__isset.extraList ? (out << to_string(extraList)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimSock5Bean::~TimSock5Bean() noexcept {
}


void TimSock5Bean::__set_fromTid(const Tid& val) {
  this->fromTid = val;
}

void TimSock5Bean::__set_toTid(const Tid& val) {
  this->toTid = val;
}

void TimSock5Bean::__set_addr(const std::string& val) {
  this->addr = val;
}

void TimSock5Bean::__set_port(const int32_t val) {
  this->port = val;
}

void TimSock5Bean::__set_transport(const int16_t val) {
  this->transport = val;
}

void TimSock5Bean::__set_pubId(const std::string& val) {
  this->pubId = val;
}

void TimSock5Bean::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimSock5Bean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimSock5Bean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fromTid = false;
  bool isset_toTid = false;
  bool isset_addr = false;
  bool isset_port = false;
  bool isset_transport = false;
  bool isset_pubId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fromTid.read(iprot);
          isset_fromTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->toTid.read(iprot);
          isset_toTid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->transport);
          isset_transport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pubId);
          isset_pubId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _ktype217;
            ::apache::thrift::protocol::TType _vtype218;
            xfer += iprot->readMapBegin(_ktype217, _vtype218, _size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              std::string _key221;
              xfer += iprot->readString(_key221);
              std::string& _val222 = this->extraMap[_key221];
              xfer += iprot->readString(_val222);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fromTid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_toTid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transport)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pubId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimSock5Bean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimSock5Bean");

  xfer += oprot->writeFieldBegin("fromTid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fromTid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toTid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->toTid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transport", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->transport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pubId", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->pubId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter223;
      for (_iter223 = this->extraMap.begin(); _iter223 != this->extraMap.end(); ++_iter223)
      {
        xfer += oprot->writeString(_iter223->first);
        xfer += oprot->writeString(_iter223->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimSock5Bean &a, TimSock5Bean &b) {
  using ::std::swap;
  swap(a.fromTid, b.fromTid);
  swap(a.toTid, b.toTid);
  swap(a.addr, b.addr);
  swap(a.port, b.port);
  swap(a.transport, b.transport);
  swap(a.pubId, b.pubId);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimSock5Bean::TimSock5Bean(const TimSock5Bean& other224) {
  fromTid = other224.fromTid;
  toTid = other224.toTid;
  addr = other224.addr;
  port = other224.port;
  transport = other224.transport;
  pubId = other224.pubId;
  extraMap = other224.extraMap;
  __isset = other224.__isset;
}
TimSock5Bean& TimSock5Bean::operator=(const TimSock5Bean& other225) {
  fromTid = other225.fromTid;
  toTid = other225.toTid;
  addr = other225.addr;
  port = other225.port;
  transport = other225.transport;
  pubId = other225.pubId;
  extraMap = other225.extraMap;
  __isset = other225.__isset;
  return *this;
}
void TimSock5Bean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimSock5Bean(";
  out << "fromTid=" << to_string(fromTid);
  out << ", " << "toTid=" << to_string(toTid);
  out << ", " << "addr=" << to_string(addr);
  out << ", " << "port=" << to_string(port);
  out << ", " << "transport=" << to_string(transport);
  out << ", " << "pubId=" << to_string(pubId);
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimSock5Bytes::~TimSock5Bytes() noexcept {
}


void TimSock5Bytes::__set_pubId(const std::string& val) {
  this->pubId = val;
}

void TimSock5Bytes::__set_index(const int32_t val) {
  this->index = val;
}

void TimSock5Bytes::__set_bytes(const std::vector<std::string> & val) {
  this->bytes = val;
}

void TimSock5Bytes::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimSock5Bytes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimSock5Bytes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pubId = false;
  bool isset_index = false;
  bool isset_bytes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pubId);
          isset_pubId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          isset_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bytes.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->bytes.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += iprot->readBinary(this->bytes[_i230]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size231;
            ::apache::thrift::protocol::TType _ktype232;
            ::apache::thrift::protocol::TType _vtype233;
            xfer += iprot->readMapBegin(_ktype232, _vtype233, _size231);
            uint32_t _i235;
            for (_i235 = 0; _i235 < _size231; ++_i235)
            {
              std::string _key236;
              xfer += iprot->readString(_key236);
              std::string& _val237 = this->extraMap[_key236];
              xfer += iprot->readString(_val237);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pubId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimSock5Bytes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimSock5Bytes");

  xfer += oprot->writeFieldBegin("pubId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pubId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bytes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bytes.size()));
    std::vector<std::string> ::const_iterator _iter238;
    for (_iter238 = this->bytes.begin(); _iter238 != this->bytes.end(); ++_iter238)
    {
      xfer += oprot->writeBinary((*_iter238));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter239;
      for (_iter239 = this->extraMap.begin(); _iter239 != this->extraMap.end(); ++_iter239)
      {
        xfer += oprot->writeString(_iter239->first);
        xfer += oprot->writeString(_iter239->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimSock5Bytes &a, TimSock5Bytes &b) {
  using ::std::swap;
  swap(a.pubId, b.pubId);
  swap(a.index, b.index);
  swap(a.bytes, b.bytes);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimSock5Bytes::TimSock5Bytes(const TimSock5Bytes& other240) {
  pubId = other240.pubId;
  index = other240.index;
  bytes = other240.bytes;
  extraMap = other240.extraMap;
  __isset = other240.__isset;
}
TimSock5Bytes& TimSock5Bytes::operator=(const TimSock5Bytes& other241) {
  pubId = other241.pubId;
  index = other241.index;
  bytes = other241.bytes;
  extraMap = other241.extraMap;
  __isset = other241.__isset;
  return *this;
}
void TimSock5Bytes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimSock5Bytes(";
  out << "pubId=" << to_string(pubId);
  out << ", " << "index=" << to_string(index);
  out << ", " << "bytes=" << to_string(bytes);
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimPage::~TimPage() noexcept {
}


void TimPage::__set_fromTimeStamp(const std::string& val) {
  this->fromTimeStamp = val;
__isset.fromTimeStamp = true;
}

void TimPage::__set_toTimeStamp(const std::string& val) {
  this->toTimeStamp = val;
__isset.toTimeStamp = true;
}

void TimPage::__set_limitCount(const int32_t val) {
  this->limitCount = val;
__isset.limitCount = true;
}

void TimPage::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimPage& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimPage::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fromTimeStamp);
          this->__isset.fromTimeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toTimeStamp);
          this->__isset.toTimeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limitCount);
          this->__isset.limitCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _ktype243;
            ::apache::thrift::protocol::TType _vtype244;
            xfer += iprot->readMapBegin(_ktype243, _vtype244, _size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              std::string _key247;
              xfer += iprot->readString(_key247);
              std::string& _val248 = this->extraMap[_key247];
              xfer += iprot->readString(_val248);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimPage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimPage");

  if (this->__isset.fromTimeStamp) {
    xfer += oprot->writeFieldBegin("fromTimeStamp", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->fromTimeStamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.toTimeStamp) {
    xfer += oprot->writeFieldBegin("toTimeStamp", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->toTimeStamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limitCount) {
    xfer += oprot->writeFieldBegin("limitCount", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->limitCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter249;
      for (_iter249 = this->extraMap.begin(); _iter249 != this->extraMap.end(); ++_iter249)
      {
        xfer += oprot->writeString(_iter249->first);
        xfer += oprot->writeString(_iter249->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimPage &a, TimPage &b) {
  using ::std::swap;
  swap(a.fromTimeStamp, b.fromTimeStamp);
  swap(a.toTimeStamp, b.toTimeStamp);
  swap(a.limitCount, b.limitCount);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimPage::TimPage(const TimPage& other250) {
  fromTimeStamp = other250.fromTimeStamp;
  toTimeStamp = other250.toTimeStamp;
  limitCount = other250.limitCount;
  extraMap = other250.extraMap;
  __isset = other250.__isset;
}
TimPage& TimPage::operator=(const TimPage& other251) {
  fromTimeStamp = other251.fromTimeStamp;
  toTimeStamp = other251.toTimeStamp;
  limitCount = other251.limitCount;
  extraMap = other251.extraMap;
  __isset = other251.__isset;
  return *this;
}
void TimPage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimPage(";
  out << "fromTimeStamp="; (__isset.fromTimeStamp ? (out << to_string(fromTimeStamp)) : (out << "<null>"));
  out << ", " << "toTimeStamp="; (__isset.toTimeStamp ? (out << to_string(toTimeStamp)) : (out << "<null>"));
  out << ", " << "limitCount="; (__isset.limitCount ? (out << to_string(limitCount)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimMessageIq::~TimMessageIq() noexcept {
}


void TimMessageIq::__set_tidlist(const std::vector<std::string> & val) {
  this->tidlist = val;
__isset.tidlist = true;
}

void TimMessageIq::__set_timPage(const TimPage& val) {
  this->timPage = val;
__isset.timPage = true;
}

void TimMessageIq::__set_midlist(const std::vector<std::string> & val) {
  this->midlist = val;
__isset.midlist = true;
}

void TimMessageIq::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimMessageIq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimMessageIq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tidlist.clear();
            uint32_t _size252;
            ::apache::thrift::protocol::TType _etype255;
            xfer += iprot->readListBegin(_etype255, _size252);
            this->tidlist.resize(_size252);
            uint32_t _i256;
            for (_i256 = 0; _i256 < _size252; ++_i256)
            {
              xfer += iprot->readString(this->tidlist[_i256]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tidlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timPage.read(iprot);
          this->__isset.timPage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->midlist.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->midlist.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += iprot->readString(this->midlist[_i261]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.midlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _ktype263;
            ::apache::thrift::protocol::TType _vtype264;
            xfer += iprot->readMapBegin(_ktype263, _vtype264, _size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              std::string _key267;
              xfer += iprot->readString(_key267);
              std::string& _val268 = this->extraMap[_key267];
              xfer += iprot->readString(_val268);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimMessageIq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimMessageIq");

  if (this->__isset.tidlist) {
    xfer += oprot->writeFieldBegin("tidlist", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tidlist.size()));
      std::vector<std::string> ::const_iterator _iter269;
      for (_iter269 = this->tidlist.begin(); _iter269 != this->tidlist.end(); ++_iter269)
      {
        xfer += oprot->writeString((*_iter269));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timPage) {
    xfer += oprot->writeFieldBegin("timPage", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->timPage.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.midlist) {
    xfer += oprot->writeFieldBegin("midlist", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->midlist.size()));
      std::vector<std::string> ::const_iterator _iter270;
      for (_iter270 = this->midlist.begin(); _iter270 != this->midlist.end(); ++_iter270)
      {
        xfer += oprot->writeString((*_iter270));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter271;
      for (_iter271 = this->extraMap.begin(); _iter271 != this->extraMap.end(); ++_iter271)
      {
        xfer += oprot->writeString(_iter271->first);
        xfer += oprot->writeString(_iter271->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimMessageIq &a, TimMessageIq &b) {
  using ::std::swap;
  swap(a.tidlist, b.tidlist);
  swap(a.timPage, b.timPage);
  swap(a.midlist, b.midlist);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimMessageIq::TimMessageIq(const TimMessageIq& other272) {
  tidlist = other272.tidlist;
  timPage = other272.timPage;
  midlist = other272.midlist;
  extraMap = other272.extraMap;
  __isset = other272.__isset;
}
TimMessageIq& TimMessageIq::operator=(const TimMessageIq& other273) {
  tidlist = other273.tidlist;
  timPage = other273.timPage;
  midlist = other273.midlist;
  extraMap = other273.extraMap;
  __isset = other273.__isset;
  return *this;
}
void TimMessageIq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimMessageIq(";
  out << "tidlist="; (__isset.tidlist ? (out << to_string(tidlist)) : (out << "<null>"));
  out << ", " << "timPage="; (__isset.timPage ? (out << to_string(timPage)) : (out << "<null>"));
  out << ", " << "midlist="; (__isset.midlist ? (out << to_string(midlist)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimAuth::~TimAuth() noexcept {
}


void TimAuth::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void TimAuth::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void TimAuth::__set_pwd(const std::string& val) {
  this->pwd = val;
__isset.pwd = true;
}
std::ostream& operator<<(std::ostream& out, const TimAuth& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimAuth::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pwd);
          this->__isset.pwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimAuth::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimAuth");

  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pwd) {
    xfer += oprot->writeFieldBegin("pwd", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->pwd);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimAuth &a, TimAuth &b) {
  using ::std::swap;
  swap(a.domain, b.domain);
  swap(a.username, b.username);
  swap(a.pwd, b.pwd);
  swap(a.__isset, b.__isset);
}

TimAuth::TimAuth(const TimAuth& other274) {
  domain = other274.domain;
  username = other274.username;
  pwd = other274.pwd;
  __isset = other274.__isset;
}
TimAuth& TimAuth::operator=(const TimAuth& other275) {
  domain = other275.domain;
  username = other275.username;
  pwd = other275.pwd;
  __isset = other275.__isset;
  return *this;
}
void TimAuth::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimAuth(";
  out << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "pwd="; (__isset.pwd ? (out << to_string(pwd)) : (out << "<null>"));
  out << ")";
}


TimMBeanList::~TimMBeanList() noexcept {
}


void TimMBeanList::__set_threadId(const std::string& val) {
  this->threadId = val;
}

void TimMBeanList::__set_timMBeanList(const std::vector<TimMBean> & val) {
  this->timMBeanList = val;
__isset.timMBeanList = true;
}

void TimMBeanList::__set_reqType(const std::string& val) {
  this->reqType = val;
__isset.reqType = true;
}

void TimMBeanList::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimMBeanList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimMBeanList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timMBeanList.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->timMBeanList.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->timMBeanList[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.timMBeanList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reqType);
          this->__isset.reqType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size281;
            ::apache::thrift::protocol::TType _ktype282;
            ::apache::thrift::protocol::TType _vtype283;
            xfer += iprot->readMapBegin(_ktype282, _vtype283, _size281);
            uint32_t _i285;
            for (_i285 = 0; _i285 < _size281; ++_i285)
            {
              std::string _key286;
              xfer += iprot->readString(_key286);
              std::string& _val287 = this->extraMap[_key286];
              xfer += iprot->readString(_val287);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimMBeanList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimMBeanList");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timMBeanList) {
    xfer += oprot->writeFieldBegin("timMBeanList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->timMBeanList.size()));
      std::vector<TimMBean> ::const_iterator _iter288;
      for (_iter288 = this->timMBeanList.begin(); _iter288 != this->timMBeanList.end(); ++_iter288)
      {
        xfer += (*_iter288).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reqType) {
    xfer += oprot->writeFieldBegin("reqType", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->reqType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter289;
      for (_iter289 = this->extraMap.begin(); _iter289 != this->extraMap.end(); ++_iter289)
      {
        xfer += oprot->writeString(_iter289->first);
        xfer += oprot->writeString(_iter289->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimMBeanList &a, TimMBeanList &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.timMBeanList, b.timMBeanList);
  swap(a.reqType, b.reqType);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimMBeanList::TimMBeanList(const TimMBeanList& other290) {
  threadId = other290.threadId;
  timMBeanList = other290.timMBeanList;
  reqType = other290.reqType;
  extraMap = other290.extraMap;
  __isset = other290.__isset;
}
TimMBeanList& TimMBeanList::operator=(const TimMBeanList& other291) {
  threadId = other291.threadId;
  timMBeanList = other291.timMBeanList;
  reqType = other291.reqType;
  extraMap = other291.extraMap;
  __isset = other291.__isset;
  return *this;
}
void TimMBeanList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimMBeanList(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "timMBeanList="; (__isset.timMBeanList ? (out << to_string(timMBeanList)) : (out << "<null>"));
  out << ", " << "reqType="; (__isset.reqType ? (out << to_string(reqType)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimPBeanList::~TimPBeanList() noexcept {
}


void TimPBeanList::__set_threadId(const std::string& val) {
  this->threadId = val;
}

void TimPBeanList::__set_timPBeanList(const std::vector<TimPBean> & val) {
  this->timPBeanList = val;
__isset.timPBeanList = true;
}

void TimPBeanList::__set_reqType(const std::string& val) {
  this->reqType = val;
__isset.reqType = true;
}

void TimPBeanList::__set_extraMap(const std::map<std::string, std::string> & val) {
  this->extraMap = val;
__isset.extraMap = true;
}
std::ostream& operator<<(std::ostream& out, const TimPBeanList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimPBeanList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_threadId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          isset_threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timPBeanList.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->timPBeanList.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += this->timPBeanList[_i296].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.timPBeanList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reqType);
          this->__isset.reqType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extraMap.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _ktype298;
            ::apache::thrift::protocol::TType _vtype299;
            xfer += iprot->readMapBegin(_ktype298, _vtype299, _size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              std::string _key302;
              xfer += iprot->readString(_key302);
              std::string& _val303 = this->extraMap[_key302];
              xfer += iprot->readString(_val303);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extraMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_threadId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimPBeanList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimPBeanList");

  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->threadId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timPBeanList) {
    xfer += oprot->writeFieldBegin("timPBeanList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->timPBeanList.size()));
      std::vector<TimPBean> ::const_iterator _iter304;
      for (_iter304 = this->timPBeanList.begin(); _iter304 != this->timPBeanList.end(); ++_iter304)
      {
        xfer += (*_iter304).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reqType) {
    xfer += oprot->writeFieldBegin("reqType", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->reqType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.extraMap) {
    xfer += oprot->writeFieldBegin("extraMap", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extraMap.size()));
      std::map<std::string, std::string> ::const_iterator _iter305;
      for (_iter305 = this->extraMap.begin(); _iter305 != this->extraMap.end(); ++_iter305)
      {
        xfer += oprot->writeString(_iter305->first);
        xfer += oprot->writeString(_iter305->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimPBeanList &a, TimPBeanList &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.timPBeanList, b.timPBeanList);
  swap(a.reqType, b.reqType);
  swap(a.extraMap, b.extraMap);
  swap(a.__isset, b.__isset);
}

TimPBeanList::TimPBeanList(const TimPBeanList& other306) {
  threadId = other306.threadId;
  timPBeanList = other306.timPBeanList;
  reqType = other306.reqType;
  extraMap = other306.extraMap;
  __isset = other306.__isset;
}
TimPBeanList& TimPBeanList::operator=(const TimPBeanList& other307) {
  threadId = other307.threadId;
  timPBeanList = other307.timPBeanList;
  reqType = other307.reqType;
  extraMap = other307.extraMap;
  __isset = other307.__isset;
  return *this;
}
void TimPBeanList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimPBeanList(";
  out << "threadId=" << to_string(threadId);
  out << ", " << "timPBeanList="; (__isset.timPBeanList ? (out << to_string(timPBeanList)) : (out << "<null>"));
  out << ", " << "reqType="; (__isset.reqType ? (out << to_string(reqType)) : (out << "<null>"));
  out << ", " << "extraMap="; (__isset.extraMap ? (out << to_string(extraMap)) : (out << "<null>"));
  out << ")";
}


TimPropertyBean::~TimPropertyBean() noexcept {
}


void TimPropertyBean::__set_threadId(const std::string& val) {
  this->threadId = val;
__isset.threadId = true;
}

void TimPropertyBean::__set_interflow(const std::string& val) {
  this->interflow = val;
__isset.interflow = true;
}

void TimPropertyBean::__set_tls(const std::string& val) {
  this->tls = val;
__isset.tls = true;
}
std::ostream& operator<<(std::ostream& out, const TimPropertyBean& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TimPropertyBean::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->threadId);
          this->__isset.threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->interflow);
          this->__isset.interflow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tls);
          this->__isset.tls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimPropertyBean::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimPropertyBean");

  if (this->__isset.threadId) {
    xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->threadId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interflow) {
    xfer += oprot->writeFieldBegin("interflow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->interflow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tls) {
    xfer += oprot->writeFieldBegin("tls", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tls);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimPropertyBean &a, TimPropertyBean &b) {
  using ::std::swap;
  swap(a.threadId, b.threadId);
  swap(a.interflow, b.interflow);
  swap(a.tls, b.tls);
  swap(a.__isset, b.__isset);
}

TimPropertyBean::TimPropertyBean(const TimPropertyBean& other308) {
  threadId = other308.threadId;
  interflow = other308.interflow;
  tls = other308.tls;
  __isset = other308.__isset;
}
TimPropertyBean& TimPropertyBean::operator=(const TimPropertyBean& other309) {
  threadId = other309.threadId;
  interflow = other309.interflow;
  tls = other309.tls;
  __isset = other309.__isset;
  return *this;
}
void TimPropertyBean::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimPropertyBean(";
  out << "threadId="; (__isset.threadId ? (out << to_string(threadId)) : (out << "<null>"));
  out << ", " << "interflow="; (__isset.interflow ? (out << to_string(interflow)) : (out << "<null>"));
  out << ", " << "tls="; (__isset.tls ? (out << to_string(tls)) : (out << "<null>"));
  out << ")";
}


