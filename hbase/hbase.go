// Code generated by Thrift Compiler (0.17.0). DO NOT EDIT.

package hbase

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

//Specify type of delete:
// - DELETE_COLUMN means exactly one version will be removed,
// - DELETE_COLUMNS means previous versions will also be removed.
type TDeleteType int64
const (
  TDeleteType_DELETE_COLUMN TDeleteType = 0
  TDeleteType_DELETE_COLUMNS TDeleteType = 1
  TDeleteType_DELETE_FAMILY TDeleteType = 2
  TDeleteType_DELETE_FAMILY_VERSION TDeleteType = 3
)

func (p TDeleteType) String() string {
  switch p {
  case TDeleteType_DELETE_COLUMN: return "DELETE_COLUMN"
  case TDeleteType_DELETE_COLUMNS: return "DELETE_COLUMNS"
  case TDeleteType_DELETE_FAMILY: return "DELETE_FAMILY"
  case TDeleteType_DELETE_FAMILY_VERSION: return "DELETE_FAMILY_VERSION"
  }
  return "<UNSET>"
}

func TDeleteTypeFromString(s string) (TDeleteType, error) {
  switch s {
  case "DELETE_COLUMN": return TDeleteType_DELETE_COLUMN, nil 
  case "DELETE_COLUMNS": return TDeleteType_DELETE_COLUMNS, nil 
  case "DELETE_FAMILY": return TDeleteType_DELETE_FAMILY, nil 
  case "DELETE_FAMILY_VERSION": return TDeleteType_DELETE_FAMILY_VERSION, nil 
  }
  return TDeleteType(0), fmt.Errorf("not a valid TDeleteType string")
}


func TDeleteTypePtr(v TDeleteType) *TDeleteType { return &v }

func (p TDeleteType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TDeleteType) UnmarshalText(text []byte) error {
q, err := TDeleteTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TDeleteType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TDeleteType(v)
return nil
}

func (p * TDeleteType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Specify Durability:
// - SKIP_WAL means do not write the Mutation to the WAL.
// - ASYNC_WAL means write the Mutation to the WAL asynchronously,
// - SYNC_WAL means write the Mutation to the WAL synchronously,
// - FSYNC_WAL means Write the Mutation to the WAL synchronously and force the entries to disk.
type TDurability int64
const (
  TDurability_USE_DEFAULT TDurability = 0
  TDurability_SKIP_WAL TDurability = 1
  TDurability_ASYNC_WAL TDurability = 2
  TDurability_SYNC_WAL TDurability = 3
  TDurability_FSYNC_WAL TDurability = 4
)

func (p TDurability) String() string {
  switch p {
  case TDurability_USE_DEFAULT: return "USE_DEFAULT"
  case TDurability_SKIP_WAL: return "SKIP_WAL"
  case TDurability_ASYNC_WAL: return "ASYNC_WAL"
  case TDurability_SYNC_WAL: return "SYNC_WAL"
  case TDurability_FSYNC_WAL: return "FSYNC_WAL"
  }
  return "<UNSET>"
}

func TDurabilityFromString(s string) (TDurability, error) {
  switch s {
  case "USE_DEFAULT": return TDurability_USE_DEFAULT, nil 
  case "SKIP_WAL": return TDurability_SKIP_WAL, nil 
  case "ASYNC_WAL": return TDurability_ASYNC_WAL, nil 
  case "SYNC_WAL": return TDurability_SYNC_WAL, nil 
  case "FSYNC_WAL": return TDurability_FSYNC_WAL, nil 
  }
  return TDurability(0), fmt.Errorf("not a valid TDurability string")
}


func TDurabilityPtr(v TDurability) *TDurability { return &v }

func (p TDurability) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TDurability) UnmarshalText(text []byte) error {
q, err := TDurabilityFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TDurability) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TDurability(v)
return nil
}

func (p * TDurability) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Specify Consistency:
// - STRONG means reads only from primary region
// - TIMELINE means reads might return values from secondary region replicas
type TConsistency int64
const (
  TConsistency_STRONG TConsistency = 1
  TConsistency_TIMELINE TConsistency = 2
)

func (p TConsistency) String() string {
  switch p {
  case TConsistency_STRONG: return "STRONG"
  case TConsistency_TIMELINE: return "TIMELINE"
  }
  return "<UNSET>"
}

func TConsistencyFromString(s string) (TConsistency, error) {
  switch s {
  case "STRONG": return TConsistency_STRONG, nil 
  case "TIMELINE": return TConsistency_TIMELINE, nil 
  }
  return TConsistency(0), fmt.Errorf("not a valid TConsistency string")
}


func TConsistencyPtr(v TConsistency) *TConsistency { return &v }

func (p TConsistency) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TConsistency) UnmarshalText(text []byte) error {
q, err := TConsistencyFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TConsistency) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TConsistency(v)
return nil
}

func (p * TConsistency) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TReadType int64
const (
  TReadType_DEFAULT TReadType = 1
  TReadType_STREAM TReadType = 2
  TReadType_PREAD TReadType = 3
)

func (p TReadType) String() string {
  switch p {
  case TReadType_DEFAULT: return "DEFAULT"
  case TReadType_STREAM: return "STREAM"
  case TReadType_PREAD: return "PREAD"
  }
  return "<UNSET>"
}

func TReadTypeFromString(s string) (TReadType, error) {
  switch s {
  case "DEFAULT": return TReadType_DEFAULT, nil 
  case "STREAM": return TReadType_STREAM, nil 
  case "PREAD": return TReadType_PREAD, nil 
  }
  return TReadType(0), fmt.Errorf("not a valid TReadType string")
}


func TReadTypePtr(v TReadType) *TReadType { return &v }

func (p TReadType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TReadType) UnmarshalText(text []byte) error {
q, err := TReadTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TReadType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TReadType(v)
return nil
}

func (p * TReadType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Thrift wrapper around
//org.apache.hadoop.hbase.filter.CompareFilter$CompareOp.
type TCompareOp int64
const (
  TCompareOp_LESS TCompareOp = 0
  TCompareOp_LESS_OR_EQUAL TCompareOp = 1
  TCompareOp_EQUAL TCompareOp = 2
  TCompareOp_NOT_EQUAL TCompareOp = 3
  TCompareOp_GREATER_OR_EQUAL TCompareOp = 4
  TCompareOp_GREATER TCompareOp = 5
  TCompareOp_NO_OP TCompareOp = 6
)

func (p TCompareOp) String() string {
  switch p {
  case TCompareOp_LESS: return "LESS"
  case TCompareOp_LESS_OR_EQUAL: return "LESS_OR_EQUAL"
  case TCompareOp_EQUAL: return "EQUAL"
  case TCompareOp_NOT_EQUAL: return "NOT_EQUAL"
  case TCompareOp_GREATER_OR_EQUAL: return "GREATER_OR_EQUAL"
  case TCompareOp_GREATER: return "GREATER"
  case TCompareOp_NO_OP: return "NO_OP"
  }
  return "<UNSET>"
}

func TCompareOpFromString(s string) (TCompareOp, error) {
  switch s {
  case "LESS": return TCompareOp_LESS, nil 
  case "LESS_OR_EQUAL": return TCompareOp_LESS_OR_EQUAL, nil 
  case "EQUAL": return TCompareOp_EQUAL, nil 
  case "NOT_EQUAL": return TCompareOp_NOT_EQUAL, nil 
  case "GREATER_OR_EQUAL": return TCompareOp_GREATER_OR_EQUAL, nil 
  case "GREATER": return TCompareOp_GREATER, nil 
  case "NO_OP": return TCompareOp_NO_OP, nil 
  }
  return TCompareOp(0), fmt.Errorf("not a valid TCompareOp string")
}


func TCompareOpPtr(v TCompareOp) *TCompareOp { return &v }

func (p TCompareOp) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TCompareOp) UnmarshalText(text []byte) error {
q, err := TCompareOpFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TCompareOp) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TCompareOp(v)
return nil
}

func (p * TCompareOp) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Thrift wrapper around
//org.apache.hadoop.hbase.regionserver.BloomType
type TBloomFilterType int64
const (
  TBloomFilterType_NONE TBloomFilterType = 0
  TBloomFilterType_ROW TBloomFilterType = 1
  TBloomFilterType_ROWCOL TBloomFilterType = 2
  TBloomFilterType_ROWPREFIX_FIXED_LENGTH TBloomFilterType = 3
)

func (p TBloomFilterType) String() string {
  switch p {
  case TBloomFilterType_NONE: return "NONE"
  case TBloomFilterType_ROW: return "ROW"
  case TBloomFilterType_ROWCOL: return "ROWCOL"
  case TBloomFilterType_ROWPREFIX_FIXED_LENGTH: return "ROWPREFIX_FIXED_LENGTH"
  }
  return "<UNSET>"
}

func TBloomFilterTypeFromString(s string) (TBloomFilterType, error) {
  switch s {
  case "NONE": return TBloomFilterType_NONE, nil 
  case "ROW": return TBloomFilterType_ROW, nil 
  case "ROWCOL": return TBloomFilterType_ROWCOL, nil 
  case "ROWPREFIX_FIXED_LENGTH": return TBloomFilterType_ROWPREFIX_FIXED_LENGTH, nil 
  }
  return TBloomFilterType(0), fmt.Errorf("not a valid TBloomFilterType string")
}


func TBloomFilterTypePtr(v TBloomFilterType) *TBloomFilterType { return &v }

func (p TBloomFilterType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TBloomFilterType) UnmarshalText(text []byte) error {
q, err := TBloomFilterTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TBloomFilterType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TBloomFilterType(v)
return nil
}

func (p * TBloomFilterType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Thrift wrapper around
//org.apache.hadoop.hbase.io.compress.Algorithm
type TCompressionAlgorithm int64
const (
  TCompressionAlgorithm_LZO TCompressionAlgorithm = 0
  TCompressionAlgorithm_GZ TCompressionAlgorithm = 1
  TCompressionAlgorithm_NONE TCompressionAlgorithm = 2
  TCompressionAlgorithm_SNAPPY TCompressionAlgorithm = 3
  TCompressionAlgorithm_LZ4 TCompressionAlgorithm = 4
  TCompressionAlgorithm_BZIP2 TCompressionAlgorithm = 5
  TCompressionAlgorithm_ZSTD TCompressionAlgorithm = 6
)

func (p TCompressionAlgorithm) String() string {
  switch p {
  case TCompressionAlgorithm_LZO: return "LZO"
  case TCompressionAlgorithm_GZ: return "GZ"
  case TCompressionAlgorithm_NONE: return "NONE"
  case TCompressionAlgorithm_SNAPPY: return "SNAPPY"
  case TCompressionAlgorithm_LZ4: return "LZ4"
  case TCompressionAlgorithm_BZIP2: return "BZIP2"
  case TCompressionAlgorithm_ZSTD: return "ZSTD"
  }
  return "<UNSET>"
}

func TCompressionAlgorithmFromString(s string) (TCompressionAlgorithm, error) {
  switch s {
  case "LZO": return TCompressionAlgorithm_LZO, nil 
  case "GZ": return TCompressionAlgorithm_GZ, nil 
  case "NONE": return TCompressionAlgorithm_NONE, nil 
  case "SNAPPY": return TCompressionAlgorithm_SNAPPY, nil 
  case "LZ4": return TCompressionAlgorithm_LZ4, nil 
  case "BZIP2": return TCompressionAlgorithm_BZIP2, nil 
  case "ZSTD": return TCompressionAlgorithm_ZSTD, nil 
  }
  return TCompressionAlgorithm(0), fmt.Errorf("not a valid TCompressionAlgorithm string")
}


func TCompressionAlgorithmPtr(v TCompressionAlgorithm) *TCompressionAlgorithm { return &v }

func (p TCompressionAlgorithm) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TCompressionAlgorithm) UnmarshalText(text []byte) error {
q, err := TCompressionAlgorithmFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TCompressionAlgorithm) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TCompressionAlgorithm(v)
return nil
}

func (p * TCompressionAlgorithm) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Thrift wrapper around
//org.apache.hadoop.hbase.io.encoding.DataBlockEncoding
type TDataBlockEncoding int64
const (
  TDataBlockEncoding_NONE TDataBlockEncoding = 0
  TDataBlockEncoding_PREFIX TDataBlockEncoding = 2
  TDataBlockEncoding_DIFF TDataBlockEncoding = 3
  TDataBlockEncoding_FAST_DIFF TDataBlockEncoding = 4
  TDataBlockEncoding_ROW_INDEX_V1 TDataBlockEncoding = 7
)

func (p TDataBlockEncoding) String() string {
  switch p {
  case TDataBlockEncoding_NONE: return "NONE"
  case TDataBlockEncoding_PREFIX: return "PREFIX"
  case TDataBlockEncoding_DIFF: return "DIFF"
  case TDataBlockEncoding_FAST_DIFF: return "FAST_DIFF"
  case TDataBlockEncoding_ROW_INDEX_V1: return "ROW_INDEX_V1"
  }
  return "<UNSET>"
}

func TDataBlockEncodingFromString(s string) (TDataBlockEncoding, error) {
  switch s {
  case "NONE": return TDataBlockEncoding_NONE, nil 
  case "PREFIX": return TDataBlockEncoding_PREFIX, nil 
  case "DIFF": return TDataBlockEncoding_DIFF, nil 
  case "FAST_DIFF": return TDataBlockEncoding_FAST_DIFF, nil 
  case "ROW_INDEX_V1": return TDataBlockEncoding_ROW_INDEX_V1, nil 
  }
  return TDataBlockEncoding(0), fmt.Errorf("not a valid TDataBlockEncoding string")
}


func TDataBlockEncodingPtr(v TDataBlockEncoding) *TDataBlockEncoding { return &v }

func (p TDataBlockEncoding) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TDataBlockEncoding) UnmarshalText(text []byte) error {
q, err := TDataBlockEncodingFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TDataBlockEncoding) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TDataBlockEncoding(v)
return nil
}

func (p * TDataBlockEncoding) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Thrift wrapper around
//org.apache.hadoop.hbase.KeepDeletedCells
type TKeepDeletedCells int64
const (
  TKeepDeletedCells_FALSE TKeepDeletedCells = 0
  TKeepDeletedCells_TRUE TKeepDeletedCells = 1
  TKeepDeletedCells_TTL TKeepDeletedCells = 2
)

func (p TKeepDeletedCells) String() string {
  switch p {
  case TKeepDeletedCells_FALSE: return "FALSE"
  case TKeepDeletedCells_TRUE: return "TRUE"
  case TKeepDeletedCells_TTL: return "TTL"
  }
  return "<UNSET>"
}

func TKeepDeletedCellsFromString(s string) (TKeepDeletedCells, error) {
  switch s {
  case "FALSE": return TKeepDeletedCells_FALSE, nil 
  case "TRUE": return TKeepDeletedCells_TRUE, nil 
  case "TTL": return TKeepDeletedCells_TTL, nil 
  }
  return TKeepDeletedCells(0), fmt.Errorf("not a valid TKeepDeletedCells string")
}


func TKeepDeletedCellsPtr(v TKeepDeletedCells) *TKeepDeletedCells { return &v }

func (p TKeepDeletedCells) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TKeepDeletedCells) UnmarshalText(text []byte) error {
q, err := TKeepDeletedCellsFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TKeepDeletedCells) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TKeepDeletedCells(v)
return nil
}

func (p * TKeepDeletedCells) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TLogType int64
const (
  TLogType_SLOW_LOG TLogType = 1
  TLogType_LARGE_LOG TLogType = 2
)

func (p TLogType) String() string {
  switch p {
  case TLogType_SLOW_LOG: return "SLOW_LOG"
  case TLogType_LARGE_LOG: return "LARGE_LOG"
  }
  return "<UNSET>"
}

func TLogTypeFromString(s string) (TLogType, error) {
  switch s {
  case "SLOW_LOG": return TLogType_SLOW_LOG, nil 
  case "LARGE_LOG": return TLogType_LARGE_LOG, nil 
  }
  return TLogType(0), fmt.Errorf("not a valid TLogType string")
}


func TLogTypePtr(v TLogType) *TLogType { return &v }

func (p TLogType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TLogType) UnmarshalText(text []byte) error {
q, err := TLogTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TLogType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TLogType(v)
return nil
}

func (p * TLogType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TFilterByOperator int64
const (
  TFilterByOperator_AND TFilterByOperator = 0
  TFilterByOperator_OR TFilterByOperator = 1
)

func (p TFilterByOperator) String() string {
  switch p {
  case TFilterByOperator_AND: return "AND"
  case TFilterByOperator_OR: return "OR"
  }
  return "<UNSET>"
}

func TFilterByOperatorFromString(s string) (TFilterByOperator, error) {
  switch s {
  case "AND": return TFilterByOperator_AND, nil 
  case "OR": return TFilterByOperator_OR, nil 
  }
  return TFilterByOperator(0), fmt.Errorf("not a valid TFilterByOperator string")
}


func TFilterByOperatorPtr(v TFilterByOperator) *TFilterByOperator { return &v }

func (p TFilterByOperator) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TFilterByOperator) UnmarshalText(text []byte) error {
q, err := TFilterByOperatorFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TFilterByOperator) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TFilterByOperator(v)
return nil
}

func (p * TFilterByOperator) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Specify type of thrift server: thrift and thrift2
type TThriftServerType int64
const (
  TThriftServerType_ONE TThriftServerType = 1
  TThriftServerType_TWO TThriftServerType = 2
)

func (p TThriftServerType) String() string {
  switch p {
  case TThriftServerType_ONE: return "ONE"
  case TThriftServerType_TWO: return "TWO"
  }
  return "<UNSET>"
}

func TThriftServerTypeFromString(s string) (TThriftServerType, error) {
  switch s {
  case "ONE": return TThriftServerType_ONE, nil 
  case "TWO": return TThriftServerType_TWO, nil 
  }
  return TThriftServerType(0), fmt.Errorf("not a valid TThriftServerType string")
}


func TThriftServerTypePtr(v TThriftServerType) *TThriftServerType { return &v }

func (p TThriftServerType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TThriftServerType) UnmarshalText(text []byte) error {
q, err := TThriftServerTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TThriftServerType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TThriftServerType(v)
return nil
}

func (p * TThriftServerType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - MinStamp
//  - MaxStamp
type TTimeRange struct {
  MinStamp int64 `thrift:"minStamp,1,required" db:"minStamp" json:"minStamp"`
  MaxStamp int64 `thrift:"maxStamp,2,required" db:"maxStamp" json:"maxStamp"`
}

func NewTTimeRange() *TTimeRange {
  return &TTimeRange{}
}


func (p *TTimeRange) GetMinStamp() int64 {
  return p.MinStamp
}

func (p *TTimeRange) GetMaxStamp() int64 {
  return p.MaxStamp
}
func (p *TTimeRange) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetMinStamp bool = false;
  var issetMaxStamp bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetMinStamp = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetMaxStamp = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetMinStamp{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MinStamp is not set"));
  }
  if !issetMaxStamp{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MaxStamp is not set"));
  }
  return nil
}

func (p *TTimeRange)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.MinStamp = v
}
  return nil
}

func (p *TTimeRange)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MaxStamp = v
}
  return nil
}

func (p *TTimeRange) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TTimeRange"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TTimeRange) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minStamp", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:minStamp: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MinStamp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minStamp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:minStamp: ", p), err) }
  return err
}

func (p *TTimeRange) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxStamp", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:maxStamp: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MaxStamp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxStamp (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:maxStamp: ", p), err) }
  return err
}

func (p *TTimeRange) Equals(other *TTimeRange) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.MinStamp != other.MinStamp { return false }
  if p.MaxStamp != other.MaxStamp { return false }
  return true
}

func (p *TTimeRange) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TTimeRange(%+v)", *p)
}

// Addresses a single cell or multiple cells
// in a HBase table by column family and optionally
// a column qualifier and timestamp
// 
// Attributes:
//  - Family
//  - Qualifier
//  - Timestamp
type TColumn struct {
  Family []byte `thrift:"family,1,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,2" db:"qualifier" json:"qualifier,omitempty"`
  Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
}

func NewTColumn() *TColumn {
  return &TColumn{}
}


func (p *TColumn) GetFamily() []byte {
  return p.Family
}
var TColumn_Qualifier_DEFAULT []byte

func (p *TColumn) GetQualifier() []byte {
  return p.Qualifier
}
var TColumn_Timestamp_DEFAULT int64
func (p *TColumn) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return TColumn_Timestamp_DEFAULT
  }
return *p.Timestamp
}
func (p *TColumn) IsSetQualifier() bool {
  return p.Qualifier != nil
}

func (p *TColumn) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *TColumn) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetFamily bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  return nil
}

func (p *TColumn)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *TColumn)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *TColumn)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *TColumn) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TColumn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TColumn) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err) }
  return err
}

func (p *TColumn) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetQualifier() {
    if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err) }
  }
  return err
}

func (p *TColumn) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  }
  return err
}

func (p *TColumn) Equals(other *TColumn) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Family, other.Family) != 0 { return false }
  if bytes.Compare(p.Qualifier, other.Qualifier) != 0 { return false }
  if p.Timestamp != other.Timestamp {
    if p.Timestamp == nil || other.Timestamp == nil {
      return false
    }
    if (*p.Timestamp) != (*other.Timestamp) { return false }
  }
  return true
}

func (p *TColumn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TColumn(%+v)", *p)
}

// Represents a single cell and its value.
// 
// Attributes:
//  - Family
//  - Qualifier
//  - Value
//  - Timestamp
//  - Tags
//  - Type
type TColumnValue struct {
  Family []byte `thrift:"family,1,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
  Value []byte `thrift:"value,3,required" db:"value" json:"value"`
  Timestamp *int64 `thrift:"timestamp,4" db:"timestamp" json:"timestamp,omitempty"`
  Tags []byte `thrift:"tags,5" db:"tags" json:"tags,omitempty"`
  Type *int8 `thrift:"type,6" db:"type" json:"type,omitempty"`
}

func NewTColumnValue() *TColumnValue {
  return &TColumnValue{}
}


func (p *TColumnValue) GetFamily() []byte {
  return p.Family
}

func (p *TColumnValue) GetQualifier() []byte {
  return p.Qualifier
}

func (p *TColumnValue) GetValue() []byte {
  return p.Value
}
var TColumnValue_Timestamp_DEFAULT int64
func (p *TColumnValue) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return TColumnValue_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var TColumnValue_Tags_DEFAULT []byte

func (p *TColumnValue) GetTags() []byte {
  return p.Tags
}
var TColumnValue_Type_DEFAULT int8
func (p *TColumnValue) GetType() int8 {
  if !p.IsSetType() {
    return TColumnValue_Type_DEFAULT
  }
return *p.Type
}
func (p *TColumnValue) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *TColumnValue) IsSetTags() bool {
  return p.Tags != nil
}

func (p *TColumnValue) IsSetType() bool {
  return p.Type != nil
}

func (p *TColumnValue) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetFamily bool = false;
  var issetQualifier bool = false;
  var issetValue bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetValue = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  if !issetValue{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"));
  }
  return nil
}

func (p *TColumnValue)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *TColumnValue)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *TColumnValue)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *TColumnValue)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *TColumnValue)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Tags = v
}
  return nil
}

func (p *TColumnValue)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := int8(v)
  p.Type = &temp
}
  return nil
}

func (p *TColumnValue) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TColumnValue"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TColumnValue) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err) }
  return err
}

func (p *TColumnValue) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err) }
  return err
}

func (p *TColumnValue) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:value: ", p), err) }
  return err
}

func (p *TColumnValue) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timestamp: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timestamp: ", p), err) }
  }
  return err
}

func (p *TColumnValue) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTags() {
    if err := oprot.WriteFieldBegin(ctx, "tags", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:tags: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Tags); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tags (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:tags: ", p), err) }
  }
  return err
}

func (p *TColumnValue) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetType() {
    if err := oprot.WriteFieldBegin(ctx, "type", thrift.BYTE, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:type: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.Type)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.type (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:type: ", p), err) }
  }
  return err
}

func (p *TColumnValue) Equals(other *TColumnValue) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Family, other.Family) != 0 { return false }
  if bytes.Compare(p.Qualifier, other.Qualifier) != 0 { return false }
  if bytes.Compare(p.Value, other.Value) != 0 { return false }
  if p.Timestamp != other.Timestamp {
    if p.Timestamp == nil || other.Timestamp == nil {
      return false
    }
    if (*p.Timestamp) != (*other.Timestamp) { return false }
  }
  if bytes.Compare(p.Tags, other.Tags) != 0 { return false }
  if p.Type != other.Type {
    if p.Type == nil || other.Type == nil {
      return false
    }
    if (*p.Type) != (*other.Type) { return false }
  }
  return true
}

func (p *TColumnValue) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TColumnValue(%+v)", *p)
}

// Represents a single cell and the amount to increment it by
// 
// Attributes:
//  - Family
//  - Qualifier
//  - Amount
type TColumnIncrement struct {
  Family []byte `thrift:"family,1,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
  Amount int64 `thrift:"amount,3" db:"amount" json:"amount"`
}

func NewTColumnIncrement() *TColumnIncrement {
  return &TColumnIncrement{
Amount: 1,
}
}


func (p *TColumnIncrement) GetFamily() []byte {
  return p.Family
}

func (p *TColumnIncrement) GetQualifier() []byte {
  return p.Qualifier
}
var TColumnIncrement_Amount_DEFAULT int64 = 1

func (p *TColumnIncrement) GetAmount() int64 {
  return p.Amount
}
func (p *TColumnIncrement) IsSetAmount() bool {
  return p.Amount != TColumnIncrement_Amount_DEFAULT
}

func (p *TColumnIncrement) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetFamily bool = false;
  var issetQualifier bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  return nil
}

func (p *TColumnIncrement)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *TColumnIncrement)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *TColumnIncrement)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Amount = v
}
  return nil
}

func (p *TColumnIncrement) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TColumnIncrement"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TColumnIncrement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:family: ", p), err) }
  return err
}

func (p *TColumnIncrement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err) }
  return err
}

func (p *TColumnIncrement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAmount() {
    if err := oprot.WriteFieldBegin(ctx, "amount", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:amount: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(p.Amount)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.amount (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:amount: ", p), err) }
  }
  return err
}

func (p *TColumnIncrement) Equals(other *TColumnIncrement) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Family, other.Family) != 0 { return false }
  if bytes.Compare(p.Qualifier, other.Qualifier) != 0 { return false }
  if p.Amount != other.Amount { return false }
  return true
}

func (p *TColumnIncrement) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TColumnIncrement(%+v)", *p)
}

// if no Result is found, row and columnValues will not be set.
// 
// Attributes:
//  - Row
//  - ColumnValues
//  - Stale
//  - Partial
type TResult_ struct {
  Row []byte `thrift:"row,1" db:"row" json:"row,omitempty"`
  ColumnValues []*TColumnValue `thrift:"columnValues,2,required" db:"columnValues" json:"columnValues"`
  Stale bool `thrift:"stale,3" db:"stale" json:"stale"`
  Partial bool `thrift:"partial,4" db:"partial" json:"partial"`
}

func NewTResult_() *TResult_ {
  return &TResult_{}
}

var TResult__Row_DEFAULT []byte

func (p *TResult_) GetRow() []byte {
  return p.Row
}

func (p *TResult_) GetColumnValues() []*TColumnValue {
  return p.ColumnValues
}
var TResult__Stale_DEFAULT bool = false

func (p *TResult_) GetStale() bool {
  return p.Stale
}
var TResult__Partial_DEFAULT bool = false

func (p *TResult_) GetPartial() bool {
  return p.Partial
}
func (p *TResult_) IsSetRow() bool {
  return p.Row != nil
}

func (p *TResult_) IsSetStale() bool {
  return p.Stale != TResult__Stale_DEFAULT
}

func (p *TResult_) IsSetPartial() bool {
  return p.Partial != TResult__Partial_DEFAULT
}

func (p *TResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnValues bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumnValues = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnValues{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnValues is not set"));
  }
  return nil
}

func (p *TResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumnValue, 0, size)
  p.ColumnValues =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &TColumnValue{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.ColumnValues = append(p.ColumnValues, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TResult_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Stale = v
}
  return nil
}

func (p *TResult_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Partial = v
}
  return nil
}

func (p *TResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRow() {
    if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Row); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  }
  return err
}

func (p *TResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columnValues", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columnValues: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnValues)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnValues {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columnValues: ", p), err) }
  return err
}

func (p *TResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStale() {
    if err := oprot.WriteFieldBegin(ctx, "stale", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:stale: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(p.Stale)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.stale (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:stale: ", p), err) }
  }
  return err
}

func (p *TResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPartial() {
    if err := oprot.WriteFieldBegin(ctx, "partial", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:partial: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(p.Partial)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.partial (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:partial: ", p), err) }
  }
  return err
}

func (p *TResult_) Equals(other *TResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.ColumnValues) != len(other.ColumnValues) { return false }
  for i, _tgt := range p.ColumnValues {
    _src1 := other.ColumnValues[i]
    if !_tgt.Equals(_src1) { return false }
  }
  if p.Stale != other.Stale { return false }
  if p.Partial != other.Partial { return false }
  return true
}

func (p *TResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TResult_(%+v)", *p)
}

// Attributes:
//  - Labels
type TAuthorization struct {
  Labels []string `thrift:"labels,1" db:"labels" json:"labels,omitempty"`
}

func NewTAuthorization() *TAuthorization {
  return &TAuthorization{}
}

var TAuthorization_Labels_DEFAULT []string

func (p *TAuthorization) GetLabels() []string {
  return p.Labels
}
func (p *TAuthorization) IsSetLabels() bool {
  return p.Labels != nil
}

func (p *TAuthorization) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TAuthorization)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Labels =  tSlice
  for i := 0; i < size; i ++ {
var _elem2 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem2 = v
}
    p.Labels = append(p.Labels, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TAuthorization) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TAuthorization"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TAuthorization) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLabels() {
    if err := oprot.WriteFieldBegin(ctx, "labels", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:labels: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Labels)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Labels {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:labels: ", p), err) }
  }
  return err
}

func (p *TAuthorization) Equals(other *TAuthorization) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Labels) != len(other.Labels) { return false }
  for i, _tgt := range p.Labels {
    _src3 := other.Labels[i]
    if _tgt != _src3 { return false }
  }
  return true
}

func (p *TAuthorization) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TAuthorization(%+v)", *p)
}

// Attributes:
//  - Expression
type TCellVisibility struct {
  Expression *string `thrift:"expression,1" db:"expression" json:"expression,omitempty"`
}

func NewTCellVisibility() *TCellVisibility {
  return &TCellVisibility{}
}

var TCellVisibility_Expression_DEFAULT string
func (p *TCellVisibility) GetExpression() string {
  if !p.IsSetExpression() {
    return TCellVisibility_Expression_DEFAULT
  }
return *p.Expression
}
func (p *TCellVisibility) IsSetExpression() bool {
  return p.Expression != nil
}

func (p *TCellVisibility) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TCellVisibility)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Expression = &v
}
  return nil
}

func (p *TCellVisibility) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TCellVisibility"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TCellVisibility) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpression() {
    if err := oprot.WriteFieldBegin(ctx, "expression", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:expression: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Expression)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.expression (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:expression: ", p), err) }
  }
  return err
}

func (p *TCellVisibility) Equals(other *TCellVisibility) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Expression != other.Expression {
    if p.Expression == nil || other.Expression == nil {
      return false
    }
    if (*p.Expression) != (*other.Expression) { return false }
  }
  return true
}

func (p *TCellVisibility) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TCellVisibility(%+v)", *p)
}

// Used to perform Get operations on a single row.
// 
// The scope can be further narrowed down by specifying a list of
// columns or column families.
// 
// To get everything for a row, instantiate a Get object with just the row to get.
// To further define the scope of what to get you can add a timestamp or time range
// with an optional maximum number of versions to return.
// 
// If you specify a time range and a timestamp the range is ignored.
// Timestamps on TColumns are ignored.
// 
// Attributes:
//  - Row
//  - Columns
//  - Timestamp
//  - TimeRange
//  - MaxVersions
//  - FilterString
//  - Attributes
//  - Authorizations
//  - Consistency
//  - TargetReplicaId
//  - CacheBlocks
//  - StoreLimit
//  - StoreOffset
//  - ExistenceOnly
//  - FilterBytes
type TGet struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  Columns []*TColumn `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
  Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
  TimeRange *TTimeRange `thrift:"timeRange,4" db:"timeRange" json:"timeRange,omitempty"`
  MaxVersions *int32 `thrift:"maxVersions,5" db:"maxVersions" json:"maxVersions,omitempty"`
  FilterString []byte `thrift:"filterString,6" db:"filterString" json:"filterString,omitempty"`
  Attributes map[string][]byte `thrift:"attributes,7" db:"attributes" json:"attributes,omitempty"`
  Authorizations *TAuthorization `thrift:"authorizations,8" db:"authorizations" json:"authorizations,omitempty"`
  Consistency *TConsistency `thrift:"consistency,9" db:"consistency" json:"consistency,omitempty"`
  TargetReplicaId *int32 `thrift:"targetReplicaId,10" db:"targetReplicaId" json:"targetReplicaId,omitempty"`
  CacheBlocks *bool `thrift:"cacheBlocks,11" db:"cacheBlocks" json:"cacheBlocks,omitempty"`
  StoreLimit *int32 `thrift:"storeLimit,12" db:"storeLimit" json:"storeLimit,omitempty"`
  StoreOffset *int32 `thrift:"storeOffset,13" db:"storeOffset" json:"storeOffset,omitempty"`
  ExistenceOnly *bool `thrift:"existence_only,14" db:"existence_only" json:"existence_only,omitempty"`
  FilterBytes []byte `thrift:"filterBytes,15" db:"filterBytes" json:"filterBytes,omitempty"`
}

func NewTGet() *TGet {
  return &TGet{}
}


func (p *TGet) GetRow() []byte {
  return p.Row
}
var TGet_Columns_DEFAULT []*TColumn

func (p *TGet) GetColumns() []*TColumn {
  return p.Columns
}
var TGet_Timestamp_DEFAULT int64
func (p *TGet) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return TGet_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var TGet_TimeRange_DEFAULT *TTimeRange
func (p *TGet) GetTimeRange() *TTimeRange {
  if !p.IsSetTimeRange() {
    return TGet_TimeRange_DEFAULT
  }
return p.TimeRange
}
var TGet_MaxVersions_DEFAULT int32
func (p *TGet) GetMaxVersions() int32 {
  if !p.IsSetMaxVersions() {
    return TGet_MaxVersions_DEFAULT
  }
return *p.MaxVersions
}
var TGet_FilterString_DEFAULT []byte

func (p *TGet) GetFilterString() []byte {
  return p.FilterString
}
var TGet_Attributes_DEFAULT map[string][]byte

func (p *TGet) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TGet_Authorizations_DEFAULT *TAuthorization
func (p *TGet) GetAuthorizations() *TAuthorization {
  if !p.IsSetAuthorizations() {
    return TGet_Authorizations_DEFAULT
  }
return p.Authorizations
}
var TGet_Consistency_DEFAULT TConsistency
func (p *TGet) GetConsistency() TConsistency {
  if !p.IsSetConsistency() {
    return TGet_Consistency_DEFAULT
  }
return *p.Consistency
}
var TGet_TargetReplicaId_DEFAULT int32
func (p *TGet) GetTargetReplicaId() int32 {
  if !p.IsSetTargetReplicaId() {
    return TGet_TargetReplicaId_DEFAULT
  }
return *p.TargetReplicaId
}
var TGet_CacheBlocks_DEFAULT bool
func (p *TGet) GetCacheBlocks() bool {
  if !p.IsSetCacheBlocks() {
    return TGet_CacheBlocks_DEFAULT
  }
return *p.CacheBlocks
}
var TGet_StoreLimit_DEFAULT int32
func (p *TGet) GetStoreLimit() int32 {
  if !p.IsSetStoreLimit() {
    return TGet_StoreLimit_DEFAULT
  }
return *p.StoreLimit
}
var TGet_StoreOffset_DEFAULT int32
func (p *TGet) GetStoreOffset() int32 {
  if !p.IsSetStoreOffset() {
    return TGet_StoreOffset_DEFAULT
  }
return *p.StoreOffset
}
var TGet_ExistenceOnly_DEFAULT bool
func (p *TGet) GetExistenceOnly() bool {
  if !p.IsSetExistenceOnly() {
    return TGet_ExistenceOnly_DEFAULT
  }
return *p.ExistenceOnly
}
var TGet_FilterBytes_DEFAULT []byte

func (p *TGet) GetFilterBytes() []byte {
  return p.FilterBytes
}
func (p *TGet) IsSetColumns() bool {
  return p.Columns != nil
}

func (p *TGet) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *TGet) IsSetTimeRange() bool {
  return p.TimeRange != nil
}

func (p *TGet) IsSetMaxVersions() bool {
  return p.MaxVersions != nil
}

func (p *TGet) IsSetFilterString() bool {
  return p.FilterString != nil
}

func (p *TGet) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TGet) IsSetAuthorizations() bool {
  return p.Authorizations != nil
}

func (p *TGet) IsSetConsistency() bool {
  return p.Consistency != nil
}

func (p *TGet) IsSetTargetReplicaId() bool {
  return p.TargetReplicaId != nil
}

func (p *TGet) IsSetCacheBlocks() bool {
  return p.CacheBlocks != nil
}

func (p *TGet) IsSetStoreLimit() bool {
  return p.StoreLimit != nil
}

func (p *TGet) IsSetStoreOffset() bool {
  return p.StoreOffset != nil
}

func (p *TGet) IsSetExistenceOnly() bool {
  return p.ExistenceOnly != nil
}

func (p *TGet) IsSetFilterBytes() bool {
  return p.FilterBytes != nil
}

func (p *TGet) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  return nil
}

func (p *TGet)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TGet)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumn, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &TColumn{}
    if err := _elem4.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.Columns = append(p.Columns, _elem4)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TGet)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *TGet)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.TimeRange = &TTimeRange{}
  if err := p.TimeRange.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TimeRange), err)
  }
  return nil
}

func (p *TGet)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.MaxVersions = &v
}
  return nil
}

func (p *TGet)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.FilterString = v
}
  return nil
}

func (p *TGet)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key5 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key5 = v
}
var _val6 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val6 = v
}
    p.Attributes[_key5] = _val6
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TGet)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.Authorizations = &TAuthorization{}
  if err := p.Authorizations.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authorizations), err)
  }
  return nil
}

func (p *TGet)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  temp := TConsistency(v)
  p.Consistency = &temp
}
  return nil
}

func (p *TGet)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.TargetReplicaId = &v
}
  return nil
}

func (p *TGet)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.CacheBlocks = &v
}
  return nil
}

func (p *TGet)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.StoreLimit = &v
}
  return nil
}

func (p *TGet)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.StoreOffset = &v
}
  return nil
}

func (p *TGet)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.ExistenceOnly = &v
}
  return nil
}

func (p *TGet)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  p.FilterBytes = v
}
  return nil
}

func (p *TGet) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TGet"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TGet) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TGet) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColumns() {
    if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Columns {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  }
  return err
}

func (p *TGet) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  }
  return err
}

func (p *TGet) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimeRange() {
    if err := oprot.WriteFieldBegin(ctx, "timeRange", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timeRange: ", p), err) }
    if err := p.TimeRange.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TimeRange), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timeRange: ", p), err) }
  }
  return err
}

func (p *TGet) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxVersions() {
    if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:maxVersions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxVersions (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:maxVersions: ", p), err) }
  }
  return err
}

func (p *TGet) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilterString() {
    if err := oprot.WriteFieldBegin(ctx, "filterString", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:filterString: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.FilterString); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.filterString (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:filterString: ", p), err) }
  }
  return err
}

func (p *TGet) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:attributes: ", p), err) }
  }
  return err
}

func (p *TGet) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAuthorizations() {
    if err := oprot.WriteFieldBegin(ctx, "authorizations", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:authorizations: ", p), err) }
    if err := p.Authorizations.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authorizations), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:authorizations: ", p), err) }
  }
  return err
}

func (p *TGet) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetConsistency() {
    if err := oprot.WriteFieldBegin(ctx, "consistency", thrift.I32, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:consistency: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Consistency)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.consistency (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:consistency: ", p), err) }
  }
  return err
}

func (p *TGet) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTargetReplicaId() {
    if err := oprot.WriteFieldBegin(ctx, "targetReplicaId", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:targetReplicaId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.TargetReplicaId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.targetReplicaId (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:targetReplicaId: ", p), err) }
  }
  return err
}

func (p *TGet) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheBlocks() {
    if err := oprot.WriteFieldBegin(ctx, "cacheBlocks", thrift.BOOL, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:cacheBlocks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CacheBlocks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheBlocks (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:cacheBlocks: ", p), err) }
  }
  return err
}

func (p *TGet) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStoreLimit() {
    if err := oprot.WriteFieldBegin(ctx, "storeLimit", thrift.I32, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:storeLimit: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.StoreLimit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.storeLimit (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:storeLimit: ", p), err) }
  }
  return err
}

func (p *TGet) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStoreOffset() {
    if err := oprot.WriteFieldBegin(ctx, "storeOffset", thrift.I32, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:storeOffset: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.StoreOffset)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.storeOffset (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:storeOffset: ", p), err) }
  }
  return err
}

func (p *TGet) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExistenceOnly() {
    if err := oprot.WriteFieldBegin(ctx, "existence_only", thrift.BOOL, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:existence_only: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.ExistenceOnly)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.existence_only (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:existence_only: ", p), err) }
  }
  return err
}

func (p *TGet) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilterBytes() {
    if err := oprot.WriteFieldBegin(ctx, "filterBytes", thrift.STRING, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:filterBytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.FilterBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.filterBytes (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:filterBytes: ", p), err) }
  }
  return err
}

func (p *TGet) Equals(other *TGet) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src7 := other.Columns[i]
    if !_tgt.Equals(_src7) { return false }
  }
  if p.Timestamp != other.Timestamp {
    if p.Timestamp == nil || other.Timestamp == nil {
      return false
    }
    if (*p.Timestamp) != (*other.Timestamp) { return false }
  }
  if !p.TimeRange.Equals(other.TimeRange) { return false }
  if p.MaxVersions != other.MaxVersions {
    if p.MaxVersions == nil || other.MaxVersions == nil {
      return false
    }
    if (*p.MaxVersions) != (*other.MaxVersions) { return false }
  }
  if bytes.Compare(p.FilterString, other.FilterString) != 0 { return false }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src8 := other.Attributes[k]
    if bytes.Compare(_tgt, _src8) != 0 { return false }
  }
  if !p.Authorizations.Equals(other.Authorizations) { return false }
  if p.Consistency != other.Consistency {
    if p.Consistency == nil || other.Consistency == nil {
      return false
    }
    if (*p.Consistency) != (*other.Consistency) { return false }
  }
  if p.TargetReplicaId != other.TargetReplicaId {
    if p.TargetReplicaId == nil || other.TargetReplicaId == nil {
      return false
    }
    if (*p.TargetReplicaId) != (*other.TargetReplicaId) { return false }
  }
  if p.CacheBlocks != other.CacheBlocks {
    if p.CacheBlocks == nil || other.CacheBlocks == nil {
      return false
    }
    if (*p.CacheBlocks) != (*other.CacheBlocks) { return false }
  }
  if p.StoreLimit != other.StoreLimit {
    if p.StoreLimit == nil || other.StoreLimit == nil {
      return false
    }
    if (*p.StoreLimit) != (*other.StoreLimit) { return false }
  }
  if p.StoreOffset != other.StoreOffset {
    if p.StoreOffset == nil || other.StoreOffset == nil {
      return false
    }
    if (*p.StoreOffset) != (*other.StoreOffset) { return false }
  }
  if p.ExistenceOnly != other.ExistenceOnly {
    if p.ExistenceOnly == nil || other.ExistenceOnly == nil {
      return false
    }
    if (*p.ExistenceOnly) != (*other.ExistenceOnly) { return false }
  }
  if bytes.Compare(p.FilterBytes, other.FilterBytes) != 0 { return false }
  return true
}

func (p *TGet) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TGet(%+v)", *p)
}

// Used to perform Put operations for a single row.
// 
// Add column values to this object and they'll be added.
// You can provide a default timestamp if the column values
// don't have one. If you don't provide a default timestamp
// the current time is inserted.
// 
// You can specify how this Put should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
// 
// Attributes:
//  - Row
//  - ColumnValues
//  - Timestamp
//  - Attributes
//  - Durability
//  - CellVisibility
type TPut struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  ColumnValues []*TColumnValue `thrift:"columnValues,2,required" db:"columnValues" json:"columnValues"`
  Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
  // unused field # 4
  Attributes map[string][]byte `thrift:"attributes,5" db:"attributes" json:"attributes,omitempty"`
  Durability *TDurability `thrift:"durability,6" db:"durability" json:"durability,omitempty"`
  CellVisibility *TCellVisibility `thrift:"cellVisibility,7" db:"cellVisibility" json:"cellVisibility,omitempty"`
}

func NewTPut() *TPut {
  return &TPut{}
}


func (p *TPut) GetRow() []byte {
  return p.Row
}

func (p *TPut) GetColumnValues() []*TColumnValue {
  return p.ColumnValues
}
var TPut_Timestamp_DEFAULT int64
func (p *TPut) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return TPut_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var TPut_Attributes_DEFAULT map[string][]byte

func (p *TPut) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TPut_Durability_DEFAULT TDurability
func (p *TPut) GetDurability() TDurability {
  if !p.IsSetDurability() {
    return TPut_Durability_DEFAULT
  }
return *p.Durability
}
var TPut_CellVisibility_DEFAULT *TCellVisibility
func (p *TPut) GetCellVisibility() *TCellVisibility {
  if !p.IsSetCellVisibility() {
    return TPut_CellVisibility_DEFAULT
  }
return p.CellVisibility
}
func (p *TPut) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *TPut) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TPut) IsSetDurability() bool {
  return p.Durability != nil
}

func (p *TPut) IsSetCellVisibility() bool {
  return p.CellVisibility != nil
}

func (p *TPut) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;
  var issetColumnValues bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumnValues = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetColumnValues{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnValues is not set"));
  }
  return nil
}

func (p *TPut)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TPut)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumnValue, 0, size)
  p.ColumnValues =  tSlice
  for i := 0; i < size; i ++ {
    _elem9 := &TColumnValue{}
    if err := _elem9.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
    }
    p.ColumnValues = append(p.ColumnValues, _elem9)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TPut)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *TPut)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key10 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key10 = v
}
var _val11 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val11 = v
}
    p.Attributes[_key10] = _val11
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TPut)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := TDurability(v)
  p.Durability = &temp
}
  return nil
}

func (p *TPut)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.CellVisibility = &TCellVisibility{}
  if err := p.CellVisibility.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
  }
  return nil
}

func (p *TPut) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TPut"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TPut) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TPut) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columnValues", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columnValues: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnValues)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnValues {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columnValues: ", p), err) }
  return err
}

func (p *TPut) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  }
  return err
}

func (p *TPut) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:attributes: ", p), err) }
  }
  return err
}

func (p *TPut) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDurability() {
    if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:durability: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durability (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:durability: ", p), err) }
  }
  return err
}

func (p *TPut) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCellVisibility() {
    if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:cellVisibility: ", p), err) }
    if err := p.CellVisibility.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:cellVisibility: ", p), err) }
  }
  return err
}

func (p *TPut) Equals(other *TPut) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.ColumnValues) != len(other.ColumnValues) { return false }
  for i, _tgt := range p.ColumnValues {
    _src12 := other.ColumnValues[i]
    if !_tgt.Equals(_src12) { return false }
  }
  if p.Timestamp != other.Timestamp {
    if p.Timestamp == nil || other.Timestamp == nil {
      return false
    }
    if (*p.Timestamp) != (*other.Timestamp) { return false }
  }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src13 := other.Attributes[k]
    if bytes.Compare(_tgt, _src13) != 0 { return false }
  }
  if p.Durability != other.Durability {
    if p.Durability == nil || other.Durability == nil {
      return false
    }
    if (*p.Durability) != (*other.Durability) { return false }
  }
  if !p.CellVisibility.Equals(other.CellVisibility) { return false }
  return true
}

func (p *TPut) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TPut(%+v)", *p)
}

// Used to perform Delete operations on a single row.
// 
// The scope can be further narrowed down by specifying a list of
// columns or column families as TColumns.
// 
// Specifying only a family in a TColumn will delete the whole family.
// If a timestamp is specified all versions with a timestamp less than
// or equal to this will be deleted. If no timestamp is specified the
// current time will be used.
// 
// Specifying a family and a column qualifier in a TColumn will delete only
// this qualifier. If a timestamp is specified only versions equal
// to this timestamp will be deleted. If no timestamp is specified the
// most recent version will be deleted.  To delete all previous versions,
// specify the DELETE_COLUMNS TDeleteType.
// 
// The top level timestamp is only used if a complete row should be deleted
// (i.e. no columns are passed) and if it is specified it works the same way
// as if you had added a TColumn for every column family and this timestamp
// (i.e. all versions older than or equal in all column families will be deleted)
// 
// You can specify how this Delete should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
// 
// Attributes:
//  - Row
//  - Columns
//  - Timestamp
//  - DeleteType
//  - Attributes
//  - Durability
type TDelete struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  Columns []*TColumn `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
  Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
  DeleteType TDeleteType `thrift:"deleteType,4" db:"deleteType" json:"deleteType"`
  // unused field # 5
  Attributes map[string][]byte `thrift:"attributes,6" db:"attributes" json:"attributes,omitempty"`
  Durability *TDurability `thrift:"durability,7" db:"durability" json:"durability,omitempty"`
}

func NewTDelete() *TDelete {
  return &TDelete{
DeleteType: 1,
}
}


func (p *TDelete) GetRow() []byte {
  return p.Row
}
var TDelete_Columns_DEFAULT []*TColumn

func (p *TDelete) GetColumns() []*TColumn {
  return p.Columns
}
var TDelete_Timestamp_DEFAULT int64
func (p *TDelete) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return TDelete_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var TDelete_DeleteType_DEFAULT TDeleteType = 1

func (p *TDelete) GetDeleteType() TDeleteType {
  return p.DeleteType
}
var TDelete_Attributes_DEFAULT map[string][]byte

func (p *TDelete) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TDelete_Durability_DEFAULT TDurability
func (p *TDelete) GetDurability() TDurability {
  if !p.IsSetDurability() {
    return TDelete_Durability_DEFAULT
  }
return *p.Durability
}
func (p *TDelete) IsSetColumns() bool {
  return p.Columns != nil
}

func (p *TDelete) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *TDelete) IsSetDeleteType() bool {
  return p.DeleteType != TDelete_DeleteType_DEFAULT
}

func (p *TDelete) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TDelete) IsSetDurability() bool {
  return p.Durability != nil
}

func (p *TDelete) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  return nil
}

func (p *TDelete)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TDelete)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumn, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem14 := &TColumn{}
    if err := _elem14.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
    }
    p.Columns = append(p.Columns, _elem14)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TDelete)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *TDelete)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := TDeleteType(v)
  p.DeleteType = temp
}
  return nil
}

func (p *TDelete)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key15 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key15 = v
}
var _val16 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val16 = v
}
    p.Attributes[_key15] = _val16
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TDelete)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  temp := TDurability(v)
  p.Durability = &temp
}
  return nil
}

func (p *TDelete) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TDelete"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TDelete) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TDelete) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColumns() {
    if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Columns {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  }
  return err
}

func (p *TDelete) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  }
  return err
}

func (p *TDelete) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDeleteType() {
    if err := oprot.WriteFieldBegin(ctx, "deleteType", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:deleteType: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(p.DeleteType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.deleteType (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:deleteType: ", p), err) }
  }
  return err
}

func (p *TDelete) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:attributes: ", p), err) }
  }
  return err
}

func (p *TDelete) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDurability() {
    if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:durability: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durability (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:durability: ", p), err) }
  }
  return err
}

func (p *TDelete) Equals(other *TDelete) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src17 := other.Columns[i]
    if !_tgt.Equals(_src17) { return false }
  }
  if p.Timestamp != other.Timestamp {
    if p.Timestamp == nil || other.Timestamp == nil {
      return false
    }
    if (*p.Timestamp) != (*other.Timestamp) { return false }
  }
  if p.DeleteType != other.DeleteType { return false }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src18 := other.Attributes[k]
    if bytes.Compare(_tgt, _src18) != 0 { return false }
  }
  if p.Durability != other.Durability {
    if p.Durability == nil || other.Durability == nil {
      return false
    }
    if (*p.Durability) != (*other.Durability) { return false }
  }
  return true
}

func (p *TDelete) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TDelete(%+v)", *p)
}

// Used to perform Increment operations for a single row.
// 
// You can specify how this Increment should be written to the write-ahead Log (WAL)
// by changing the durability. If you don't provide durability, it defaults to
// column family's default setting for durability.
// 
// Attributes:
//  - Row
//  - Columns
//  - Attributes
//  - Durability
//  - CellVisibility
//  - ReturnResults
type TIncrement struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  Columns []*TColumnIncrement `thrift:"columns,2,required" db:"columns" json:"columns"`
  // unused field # 3
  Attributes map[string][]byte `thrift:"attributes,4" db:"attributes" json:"attributes,omitempty"`
  Durability *TDurability `thrift:"durability,5" db:"durability" json:"durability,omitempty"`
  CellVisibility *TCellVisibility `thrift:"cellVisibility,6" db:"cellVisibility" json:"cellVisibility,omitempty"`
  ReturnResults *bool `thrift:"returnResults,7" db:"returnResults" json:"returnResults,omitempty"`
}

func NewTIncrement() *TIncrement {
  return &TIncrement{}
}


func (p *TIncrement) GetRow() []byte {
  return p.Row
}

func (p *TIncrement) GetColumns() []*TColumnIncrement {
  return p.Columns
}
var TIncrement_Attributes_DEFAULT map[string][]byte

func (p *TIncrement) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TIncrement_Durability_DEFAULT TDurability
func (p *TIncrement) GetDurability() TDurability {
  if !p.IsSetDurability() {
    return TIncrement_Durability_DEFAULT
  }
return *p.Durability
}
var TIncrement_CellVisibility_DEFAULT *TCellVisibility
func (p *TIncrement) GetCellVisibility() *TCellVisibility {
  if !p.IsSetCellVisibility() {
    return TIncrement_CellVisibility_DEFAULT
  }
return p.CellVisibility
}
var TIncrement_ReturnResults_DEFAULT bool
func (p *TIncrement) GetReturnResults() bool {
  if !p.IsSetReturnResults() {
    return TIncrement_ReturnResults_DEFAULT
  }
return *p.ReturnResults
}
func (p *TIncrement) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TIncrement) IsSetDurability() bool {
  return p.Durability != nil
}

func (p *TIncrement) IsSetCellVisibility() bool {
  return p.CellVisibility != nil
}

func (p *TIncrement) IsSetReturnResults() bool {
  return p.ReturnResults != nil
}

func (p *TIncrement) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumns = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *TIncrement)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TIncrement)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumnIncrement, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem19 := &TColumnIncrement{
    Amount: 1,
}
    if err := _elem19.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem19), err)
    }
    p.Columns = append(p.Columns, _elem19)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TIncrement)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key20 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key20 = v
}
var _val21 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val21 = v
}
    p.Attributes[_key20] = _val21
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TIncrement)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := TDurability(v)
  p.Durability = &temp
}
  return nil
}

func (p *TIncrement)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.CellVisibility = &TCellVisibility{}
  if err := p.CellVisibility.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
  }
  return nil
}

func (p *TIncrement)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.ReturnResults = &v
}
  return nil
}

func (p *TIncrement) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TIncrement"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TIncrement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TIncrement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *TIncrement) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:attributes: ", p), err) }
  }
  return err
}

func (p *TIncrement) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDurability() {
    if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:durability: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durability (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:durability: ", p), err) }
  }
  return err
}

func (p *TIncrement) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCellVisibility() {
    if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:cellVisibility: ", p), err) }
    if err := p.CellVisibility.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:cellVisibility: ", p), err) }
  }
  return err
}

func (p *TIncrement) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReturnResults() {
    if err := oprot.WriteFieldBegin(ctx, "returnResults", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:returnResults: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.ReturnResults)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.returnResults (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:returnResults: ", p), err) }
  }
  return err
}

func (p *TIncrement) Equals(other *TIncrement) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src22 := other.Columns[i]
    if !_tgt.Equals(_src22) { return false }
  }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src23 := other.Attributes[k]
    if bytes.Compare(_tgt, _src23) != 0 { return false }
  }
  if p.Durability != other.Durability {
    if p.Durability == nil || other.Durability == nil {
      return false
    }
    if (*p.Durability) != (*other.Durability) { return false }
  }
  if !p.CellVisibility.Equals(other.CellVisibility) { return false }
  if p.ReturnResults != other.ReturnResults {
    if p.ReturnResults == nil || other.ReturnResults == nil {
      return false
    }
    if (*p.ReturnResults) != (*other.ReturnResults) { return false }
  }
  return true
}

func (p *TIncrement) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TIncrement(%+v)", *p)
}

// Attributes:
//  - Row
//  - Columns
//  - Attributes
//  - Durability
//  - CellVisibility
//  - ReturnResults
type TAppend struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  Columns []*TColumnValue `thrift:"columns,2,required" db:"columns" json:"columns"`
  Attributes map[string][]byte `thrift:"attributes,3" db:"attributes" json:"attributes,omitempty"`
  Durability *TDurability `thrift:"durability,4" db:"durability" json:"durability,omitempty"`
  CellVisibility *TCellVisibility `thrift:"cellVisibility,5" db:"cellVisibility" json:"cellVisibility,omitempty"`
  ReturnResults *bool `thrift:"returnResults,6" db:"returnResults" json:"returnResults,omitempty"`
}

func NewTAppend() *TAppend {
  return &TAppend{}
}


func (p *TAppend) GetRow() []byte {
  return p.Row
}

func (p *TAppend) GetColumns() []*TColumnValue {
  return p.Columns
}
var TAppend_Attributes_DEFAULT map[string][]byte

func (p *TAppend) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TAppend_Durability_DEFAULT TDurability
func (p *TAppend) GetDurability() TDurability {
  if !p.IsSetDurability() {
    return TAppend_Durability_DEFAULT
  }
return *p.Durability
}
var TAppend_CellVisibility_DEFAULT *TCellVisibility
func (p *TAppend) GetCellVisibility() *TCellVisibility {
  if !p.IsSetCellVisibility() {
    return TAppend_CellVisibility_DEFAULT
  }
return p.CellVisibility
}
var TAppend_ReturnResults_DEFAULT bool
func (p *TAppend) GetReturnResults() bool {
  if !p.IsSetReturnResults() {
    return TAppend_ReturnResults_DEFAULT
  }
return *p.ReturnResults
}
func (p *TAppend) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TAppend) IsSetDurability() bool {
  return p.Durability != nil
}

func (p *TAppend) IsSetCellVisibility() bool {
  return p.CellVisibility != nil
}

func (p *TAppend) IsSetReturnResults() bool {
  return p.ReturnResults != nil
}

func (p *TAppend) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumns = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *TAppend)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TAppend)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumnValue, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem24 := &TColumnValue{}
    if err := _elem24.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem24), err)
    }
    p.Columns = append(p.Columns, _elem24)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TAppend)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key25 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key25 = v
}
var _val26 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val26 = v
}
    p.Attributes[_key25] = _val26
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TAppend)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := TDurability(v)
  p.Durability = &temp
}
  return nil
}

func (p *TAppend)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.CellVisibility = &TCellVisibility{}
  if err := p.CellVisibility.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CellVisibility), err)
  }
  return nil
}

func (p *TAppend)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.ReturnResults = &v
}
  return nil
}

func (p *TAppend) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TAppend"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TAppend) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TAppend) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *TAppend) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:attributes: ", p), err) }
  }
  return err
}

func (p *TAppend) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDurability() {
    if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:durability: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durability (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:durability: ", p), err) }
  }
  return err
}

func (p *TAppend) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCellVisibility() {
    if err := oprot.WriteFieldBegin(ctx, "cellVisibility", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:cellVisibility: ", p), err) }
    if err := p.CellVisibility.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CellVisibility), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:cellVisibility: ", p), err) }
  }
  return err
}

func (p *TAppend) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReturnResults() {
    if err := oprot.WriteFieldBegin(ctx, "returnResults", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:returnResults: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.ReturnResults)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.returnResults (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:returnResults: ", p), err) }
  }
  return err
}

func (p *TAppend) Equals(other *TAppend) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src27 := other.Columns[i]
    if !_tgt.Equals(_src27) { return false }
  }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src28 := other.Attributes[k]
    if bytes.Compare(_tgt, _src28) != 0 { return false }
  }
  if p.Durability != other.Durability {
    if p.Durability == nil || other.Durability == nil {
      return false
    }
    if (*p.Durability) != (*other.Durability) { return false }
  }
  if !p.CellVisibility.Equals(other.CellVisibility) { return false }
  if p.ReturnResults != other.ReturnResults {
    if p.ReturnResults == nil || other.ReturnResults == nil {
      return false
    }
    if (*p.ReturnResults) != (*other.ReturnResults) { return false }
  }
  return true
}

func (p *TAppend) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TAppend(%+v)", *p)
}

// Any timestamps in the columns are ignored but the colFamTimeRangeMap included, use timeRange to select by timestamp.
// Max versions defaults to 1.
// 
// Attributes:
//  - StartRow
//  - StopRow
//  - Columns
//  - Caching
//  - MaxVersions
//  - TimeRange
//  - FilterString
//  - BatchSize
//  - Attributes
//  - Authorizations
//  - Reversed
//  - CacheBlocks
//  - ColFamTimeRangeMap
//  - ReadType
//  - Limit
//  - Consistency
//  - TargetReplicaId
//  - FilterBytes
type TScan struct {
  StartRow []byte `thrift:"startRow,1" db:"startRow" json:"startRow,omitempty"`
  StopRow []byte `thrift:"stopRow,2" db:"stopRow" json:"stopRow,omitempty"`
  Columns []*TColumn `thrift:"columns,3" db:"columns" json:"columns,omitempty"`
  Caching *int32 `thrift:"caching,4" db:"caching" json:"caching,omitempty"`
  MaxVersions int32 `thrift:"maxVersions,5" db:"maxVersions" json:"maxVersions"`
  TimeRange *TTimeRange `thrift:"timeRange,6" db:"timeRange" json:"timeRange,omitempty"`
  FilterString []byte `thrift:"filterString,7" db:"filterString" json:"filterString,omitempty"`
  BatchSize *int32 `thrift:"batchSize,8" db:"batchSize" json:"batchSize,omitempty"`
  Attributes map[string][]byte `thrift:"attributes,9" db:"attributes" json:"attributes,omitempty"`
  Authorizations *TAuthorization `thrift:"authorizations,10" db:"authorizations" json:"authorizations,omitempty"`
  Reversed *bool `thrift:"reversed,11" db:"reversed" json:"reversed,omitempty"`
  CacheBlocks *bool `thrift:"cacheBlocks,12" db:"cacheBlocks" json:"cacheBlocks,omitempty"`
  ColFamTimeRangeMap map[string]*TTimeRange `thrift:"colFamTimeRangeMap,13" db:"colFamTimeRangeMap" json:"colFamTimeRangeMap,omitempty"`
  ReadType *TReadType `thrift:"readType,14" db:"readType" json:"readType,omitempty"`
  Limit *int32 `thrift:"limit,15" db:"limit" json:"limit,omitempty"`
  Consistency *TConsistency `thrift:"consistency,16" db:"consistency" json:"consistency,omitempty"`
  TargetReplicaId *int32 `thrift:"targetReplicaId,17" db:"targetReplicaId" json:"targetReplicaId,omitempty"`
  FilterBytes []byte `thrift:"filterBytes,18" db:"filterBytes" json:"filterBytes,omitempty"`
}

func NewTScan() *TScan {
  return &TScan{
MaxVersions: 1,
}
}

var TScan_StartRow_DEFAULT []byte

func (p *TScan) GetStartRow() []byte {
  return p.StartRow
}
var TScan_StopRow_DEFAULT []byte

func (p *TScan) GetStopRow() []byte {
  return p.StopRow
}
var TScan_Columns_DEFAULT []*TColumn

func (p *TScan) GetColumns() []*TColumn {
  return p.Columns
}
var TScan_Caching_DEFAULT int32
func (p *TScan) GetCaching() int32 {
  if !p.IsSetCaching() {
    return TScan_Caching_DEFAULT
  }
return *p.Caching
}
var TScan_MaxVersions_DEFAULT int32 = 1

func (p *TScan) GetMaxVersions() int32 {
  return p.MaxVersions
}
var TScan_TimeRange_DEFAULT *TTimeRange
func (p *TScan) GetTimeRange() *TTimeRange {
  if !p.IsSetTimeRange() {
    return TScan_TimeRange_DEFAULT
  }
return p.TimeRange
}
var TScan_FilterString_DEFAULT []byte

func (p *TScan) GetFilterString() []byte {
  return p.FilterString
}
var TScan_BatchSize_DEFAULT int32
func (p *TScan) GetBatchSize() int32 {
  if !p.IsSetBatchSize() {
    return TScan_BatchSize_DEFAULT
  }
return *p.BatchSize
}
var TScan_Attributes_DEFAULT map[string][]byte

func (p *TScan) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TScan_Authorizations_DEFAULT *TAuthorization
func (p *TScan) GetAuthorizations() *TAuthorization {
  if !p.IsSetAuthorizations() {
    return TScan_Authorizations_DEFAULT
  }
return p.Authorizations
}
var TScan_Reversed_DEFAULT bool
func (p *TScan) GetReversed() bool {
  if !p.IsSetReversed() {
    return TScan_Reversed_DEFAULT
  }
return *p.Reversed
}
var TScan_CacheBlocks_DEFAULT bool
func (p *TScan) GetCacheBlocks() bool {
  if !p.IsSetCacheBlocks() {
    return TScan_CacheBlocks_DEFAULT
  }
return *p.CacheBlocks
}
var TScan_ColFamTimeRangeMap_DEFAULT map[string]*TTimeRange

func (p *TScan) GetColFamTimeRangeMap() map[string]*TTimeRange {
  return p.ColFamTimeRangeMap
}
var TScan_ReadType_DEFAULT TReadType
func (p *TScan) GetReadType() TReadType {
  if !p.IsSetReadType() {
    return TScan_ReadType_DEFAULT
  }
return *p.ReadType
}
var TScan_Limit_DEFAULT int32
func (p *TScan) GetLimit() int32 {
  if !p.IsSetLimit() {
    return TScan_Limit_DEFAULT
  }
return *p.Limit
}
var TScan_Consistency_DEFAULT TConsistency
func (p *TScan) GetConsistency() TConsistency {
  if !p.IsSetConsistency() {
    return TScan_Consistency_DEFAULT
  }
return *p.Consistency
}
var TScan_TargetReplicaId_DEFAULT int32
func (p *TScan) GetTargetReplicaId() int32 {
  if !p.IsSetTargetReplicaId() {
    return TScan_TargetReplicaId_DEFAULT
  }
return *p.TargetReplicaId
}
var TScan_FilterBytes_DEFAULT []byte

func (p *TScan) GetFilterBytes() []byte {
  return p.FilterBytes
}
func (p *TScan) IsSetStartRow() bool {
  return p.StartRow != nil
}

func (p *TScan) IsSetStopRow() bool {
  return p.StopRow != nil
}

func (p *TScan) IsSetColumns() bool {
  return p.Columns != nil
}

func (p *TScan) IsSetCaching() bool {
  return p.Caching != nil
}

func (p *TScan) IsSetMaxVersions() bool {
  return p.MaxVersions != TScan_MaxVersions_DEFAULT
}

func (p *TScan) IsSetTimeRange() bool {
  return p.TimeRange != nil
}

func (p *TScan) IsSetFilterString() bool {
  return p.FilterString != nil
}

func (p *TScan) IsSetBatchSize() bool {
  return p.BatchSize != nil
}

func (p *TScan) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TScan) IsSetAuthorizations() bool {
  return p.Authorizations != nil
}

func (p *TScan) IsSetReversed() bool {
  return p.Reversed != nil
}

func (p *TScan) IsSetCacheBlocks() bool {
  return p.CacheBlocks != nil
}

func (p *TScan) IsSetColFamTimeRangeMap() bool {
  return p.ColFamTimeRangeMap != nil
}

func (p *TScan) IsSetReadType() bool {
  return p.ReadType != nil
}

func (p *TScan) IsSetLimit() bool {
  return p.Limit != nil
}

func (p *TScan) IsSetConsistency() bool {
  return p.Consistency != nil
}

func (p *TScan) IsSetTargetReplicaId() bool {
  return p.TargetReplicaId != nil
}

func (p *TScan) IsSetFilterBytes() bool {
  return p.FilterBytes != nil
}

func (p *TScan) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField18(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TScan)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartRow = v
}
  return nil
}

func (p *TScan)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StopRow = v
}
  return nil
}

func (p *TScan)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumn, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem29 := &TColumn{}
    if err := _elem29.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem29), err)
    }
    p.Columns = append(p.Columns, _elem29)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TScan)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Caching = &v
}
  return nil
}

func (p *TScan)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.MaxVersions = v
}
  return nil
}

func (p *TScan)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.TimeRange = &TTimeRange{}
  if err := p.TimeRange.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TimeRange), err)
  }
  return nil
}

func (p *TScan)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.FilterString = v
}
  return nil
}

func (p *TScan)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.BatchSize = &v
}
  return nil
}

func (p *TScan)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key30 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key30 = v
}
var _val31 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val31 = v
}
    p.Attributes[_key30] = _val31
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TScan)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  p.Authorizations = &TAuthorization{}
  if err := p.Authorizations.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authorizations), err)
  }
  return nil
}

func (p *TScan)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.Reversed = &v
}
  return nil
}

func (p *TScan)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.CacheBlocks = &v
}
  return nil
}

func (p *TScan)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*TTimeRange, size)
  p.ColFamTimeRangeMap =  tMap
  for i := 0; i < size; i ++ {
var _key32 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key32 = v
}
    _val33 := &TTimeRange{}
    if err := _val33.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val33), err)
    }
    p.ColFamTimeRangeMap[_key32] = _val33
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TScan)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  temp := TReadType(v)
  p.ReadType = &temp
}
  return nil
}

func (p *TScan)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  p.Limit = &v
}
  return nil
}

func (p *TScan)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  temp := TConsistency(v)
  p.Consistency = &temp
}
  return nil
}

func (p *TScan)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 17: ", err)
} else {
  p.TargetReplicaId = &v
}
  return nil
}

func (p *TScan)  ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 18: ", err)
} else {
  p.FilterBytes = v
}
  return nil
}

func (p *TScan) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TScan"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
    if err := p.writeField18(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TScan) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStartRow() {
    if err := oprot.WriteFieldBegin(ctx, "startRow", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startRow: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.StartRow); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.startRow (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startRow: ", p), err) }
  }
  return err
}

func (p *TScan) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStopRow() {
    if err := oprot.WriteFieldBegin(ctx, "stopRow", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:stopRow: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.StopRow); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.stopRow (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:stopRow: ", p), err) }
  }
  return err
}

func (p *TScan) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColumns() {
    if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:columns: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Columns {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:columns: ", p), err) }
  }
  return err
}

func (p *TScan) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCaching() {
    if err := oprot.WriteFieldBegin(ctx, "caching", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:caching: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Caching)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.caching (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:caching: ", p), err) }
  }
  return err
}

func (p *TScan) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxVersions() {
    if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:maxVersions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(p.MaxVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxVersions (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:maxVersions: ", p), err) }
  }
  return err
}

func (p *TScan) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimeRange() {
    if err := oprot.WriteFieldBegin(ctx, "timeRange", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:timeRange: ", p), err) }
    if err := p.TimeRange.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TimeRange), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:timeRange: ", p), err) }
  }
  return err
}

func (p *TScan) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilterString() {
    if err := oprot.WriteFieldBegin(ctx, "filterString", thrift.STRING, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:filterString: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.FilterString); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.filterString (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:filterString: ", p), err) }
  }
  return err
}

func (p *TScan) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBatchSize() {
    if err := oprot.WriteFieldBegin(ctx, "batchSize", thrift.I32, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:batchSize: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BatchSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.batchSize (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:batchSize: ", p), err) }
  }
  return err
}

func (p *TScan) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:attributes: ", p), err) }
  }
  return err
}

func (p *TScan) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAuthorizations() {
    if err := oprot.WriteFieldBegin(ctx, "authorizations", thrift.STRUCT, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:authorizations: ", p), err) }
    if err := p.Authorizations.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authorizations), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:authorizations: ", p), err) }
  }
  return err
}

func (p *TScan) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReversed() {
    if err := oprot.WriteFieldBegin(ctx, "reversed", thrift.BOOL, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:reversed: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Reversed)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.reversed (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:reversed: ", p), err) }
  }
  return err
}

func (p *TScan) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheBlocks() {
    if err := oprot.WriteFieldBegin(ctx, "cacheBlocks", thrift.BOOL, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:cacheBlocks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CacheBlocks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheBlocks (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:cacheBlocks: ", p), err) }
  }
  return err
}

func (p *TScan) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColFamTimeRangeMap() {
    if err := oprot.WriteFieldBegin(ctx, "colFamTimeRangeMap", thrift.MAP, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:colFamTimeRangeMap: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.ColFamTimeRangeMap)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.ColFamTimeRangeMap {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:colFamTimeRangeMap: ", p), err) }
  }
  return err
}

func (p *TScan) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReadType() {
    if err := oprot.WriteFieldBegin(ctx, "readType", thrift.I32, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:readType: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ReadType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.readType (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:readType: ", p), err) }
  }
  return err
}

func (p *TScan) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLimit() {
    if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:limit: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Limit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.limit (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:limit: ", p), err) }
  }
  return err
}

func (p *TScan) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetConsistency() {
    if err := oprot.WriteFieldBegin(ctx, "consistency", thrift.I32, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:consistency: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Consistency)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.consistency (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:consistency: ", p), err) }
  }
  return err
}

func (p *TScan) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTargetReplicaId() {
    if err := oprot.WriteFieldBegin(ctx, "targetReplicaId", thrift.I32, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:targetReplicaId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.TargetReplicaId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.targetReplicaId (17) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:targetReplicaId: ", p), err) }
  }
  return err
}

func (p *TScan) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilterBytes() {
    if err := oprot.WriteFieldBegin(ctx, "filterBytes", thrift.STRING, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:filterBytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.FilterBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.filterBytes (18) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:filterBytes: ", p), err) }
  }
  return err
}

func (p *TScan) Equals(other *TScan) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.StartRow, other.StartRow) != 0 { return false }
  if bytes.Compare(p.StopRow, other.StopRow) != 0 { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src34 := other.Columns[i]
    if !_tgt.Equals(_src34) { return false }
  }
  if p.Caching != other.Caching {
    if p.Caching == nil || other.Caching == nil {
      return false
    }
    if (*p.Caching) != (*other.Caching) { return false }
  }
  if p.MaxVersions != other.MaxVersions { return false }
  if !p.TimeRange.Equals(other.TimeRange) { return false }
  if bytes.Compare(p.FilterString, other.FilterString) != 0 { return false }
  if p.BatchSize != other.BatchSize {
    if p.BatchSize == nil || other.BatchSize == nil {
      return false
    }
    if (*p.BatchSize) != (*other.BatchSize) { return false }
  }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src35 := other.Attributes[k]
    if bytes.Compare(_tgt, _src35) != 0 { return false }
  }
  if !p.Authorizations.Equals(other.Authorizations) { return false }
  if p.Reversed != other.Reversed {
    if p.Reversed == nil || other.Reversed == nil {
      return false
    }
    if (*p.Reversed) != (*other.Reversed) { return false }
  }
  if p.CacheBlocks != other.CacheBlocks {
    if p.CacheBlocks == nil || other.CacheBlocks == nil {
      return false
    }
    if (*p.CacheBlocks) != (*other.CacheBlocks) { return false }
  }
  if len(p.ColFamTimeRangeMap) != len(other.ColFamTimeRangeMap) { return false }
  for k, _tgt := range p.ColFamTimeRangeMap {
    _src36 := other.ColFamTimeRangeMap[k]
    if !_tgt.Equals(_src36) { return false }
  }
  if p.ReadType != other.ReadType {
    if p.ReadType == nil || other.ReadType == nil {
      return false
    }
    if (*p.ReadType) != (*other.ReadType) { return false }
  }
  if p.Limit != other.Limit {
    if p.Limit == nil || other.Limit == nil {
      return false
    }
    if (*p.Limit) != (*other.Limit) { return false }
  }
  if p.Consistency != other.Consistency {
    if p.Consistency == nil || other.Consistency == nil {
      return false
    }
    if (*p.Consistency) != (*other.Consistency) { return false }
  }
  if p.TargetReplicaId != other.TargetReplicaId {
    if p.TargetReplicaId == nil || other.TargetReplicaId == nil {
      return false
    }
    if (*p.TargetReplicaId) != (*other.TargetReplicaId) { return false }
  }
  if bytes.Compare(p.FilterBytes, other.FilterBytes) != 0 { return false }
  return true
}

func (p *TScan) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TScan(%+v)", *p)
}

// Atomic mutation for the specified row. It can be either Put or Delete.
// 
// Attributes:
//  - Put
//  - DeleteSingle
type TMutation struct {
  Put *TPut `thrift:"put,1" db:"put" json:"put,omitempty"`
  DeleteSingle *TDelete `thrift:"deleteSingle,2" db:"deleteSingle" json:"deleteSingle,omitempty"`
}

func NewTMutation() *TMutation {
  return &TMutation{}
}

var TMutation_Put_DEFAULT *TPut
func (p *TMutation) GetPut() *TPut {
  if !p.IsSetPut() {
    return TMutation_Put_DEFAULT
  }
return p.Put
}
var TMutation_DeleteSingle_DEFAULT *TDelete
func (p *TMutation) GetDeleteSingle() *TDelete {
  if !p.IsSetDeleteSingle() {
    return TMutation_DeleteSingle_DEFAULT
  }
return p.DeleteSingle
}
func (p *TMutation) CountSetFieldsTMutation() int {
  count := 0
  if (p.IsSetPut()) {
    count++
  }
  if (p.IsSetDeleteSingle()) {
    count++
  }
  return count

}

func (p *TMutation) IsSetPut() bool {
  return p.Put != nil
}

func (p *TMutation) IsSetDeleteSingle() bool {
  return p.DeleteSingle != nil
}

func (p *TMutation) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TMutation)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Put = &TPut{}
  if err := p.Put.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Put), err)
  }
  return nil
}

func (p *TMutation)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.DeleteSingle = &TDelete{
  DeleteType: 1,
}
  if err := p.DeleteSingle.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DeleteSingle), err)
  }
  return nil
}

func (p *TMutation) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsTMutation(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "TMutation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TMutation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPut() {
    if err := oprot.WriteFieldBegin(ctx, "put", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:put: ", p), err) }
    if err := p.Put.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Put), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:put: ", p), err) }
  }
  return err
}

func (p *TMutation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDeleteSingle() {
    if err := oprot.WriteFieldBegin(ctx, "deleteSingle", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:deleteSingle: ", p), err) }
    if err := p.DeleteSingle.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DeleteSingle), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:deleteSingle: ", p), err) }
  }
  return err
}

func (p *TMutation) Equals(other *TMutation) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Put.Equals(other.Put) { return false }
  if !p.DeleteSingle.Equals(other.DeleteSingle) { return false }
  return true
}

func (p *TMutation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TMutation(%+v)", *p)
}

// A TRowMutations object is used to apply a number of Mutations to a single row.
// 
// Attributes:
//  - Row
//  - Mutations
type TRowMutations struct {
  Row []byte `thrift:"row,1,required" db:"row" json:"row"`
  Mutations []*TMutation `thrift:"mutations,2,required" db:"mutations" json:"mutations"`
}

func NewTRowMutations() *TRowMutations {
  return &TRowMutations{}
}


func (p *TRowMutations) GetRow() []byte {
  return p.Row
}

func (p *TRowMutations) GetMutations() []*TMutation {
  return p.Mutations
}
func (p *TRowMutations) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRow bool = false;
  var issetMutations bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetMutations = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetMutations{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Mutations is not set"));
  }
  return nil
}

func (p *TRowMutations)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *TRowMutations)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TMutation, 0, size)
  p.Mutations =  tSlice
  for i := 0; i < size; i ++ {
    _elem37 := &TMutation{}
    if err := _elem37.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem37), err)
    }
    p.Mutations = append(p.Mutations, _elem37)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TRowMutations) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TRowMutations"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TRowMutations) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:row: ", p), err) }
  return err
}

func (p *TRowMutations) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "mutations", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:mutations: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Mutations)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Mutations {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:mutations: ", p), err) }
  return err
}

func (p *TRowMutations) Equals(other *TRowMutations) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Row, other.Row) != 0 { return false }
  if len(p.Mutations) != len(other.Mutations) { return false }
  for i, _tgt := range p.Mutations {
    _src38 := other.Mutations[i]
    if !_tgt.Equals(_src38) { return false }
  }
  return true
}

func (p *TRowMutations) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TRowMutations(%+v)", *p)
}

// Attributes:
//  - RegionId
//  - TableName
//  - StartKey
//  - EndKey
//  - Offline
//  - Split
//  - ReplicaId
type THRegionInfo struct {
  RegionId int64 `thrift:"regionId,1,required" db:"regionId" json:"regionId"`
  TableName []byte `thrift:"tableName,2,required" db:"tableName" json:"tableName"`
  StartKey []byte `thrift:"startKey,3" db:"startKey" json:"startKey,omitempty"`
  EndKey []byte `thrift:"endKey,4" db:"endKey" json:"endKey,omitempty"`
  Offline *bool `thrift:"offline,5" db:"offline" json:"offline,omitempty"`
  Split *bool `thrift:"split,6" db:"split" json:"split,omitempty"`
  ReplicaId *int32 `thrift:"replicaId,7" db:"replicaId" json:"replicaId,omitempty"`
}

func NewTHRegionInfo() *THRegionInfo {
  return &THRegionInfo{}
}


func (p *THRegionInfo) GetRegionId() int64 {
  return p.RegionId
}

func (p *THRegionInfo) GetTableName() []byte {
  return p.TableName
}
var THRegionInfo_StartKey_DEFAULT []byte

func (p *THRegionInfo) GetStartKey() []byte {
  return p.StartKey
}
var THRegionInfo_EndKey_DEFAULT []byte

func (p *THRegionInfo) GetEndKey() []byte {
  return p.EndKey
}
var THRegionInfo_Offline_DEFAULT bool
func (p *THRegionInfo) GetOffline() bool {
  if !p.IsSetOffline() {
    return THRegionInfo_Offline_DEFAULT
  }
return *p.Offline
}
var THRegionInfo_Split_DEFAULT bool
func (p *THRegionInfo) GetSplit() bool {
  if !p.IsSetSplit() {
    return THRegionInfo_Split_DEFAULT
  }
return *p.Split
}
var THRegionInfo_ReplicaId_DEFAULT int32
func (p *THRegionInfo) GetReplicaId() int32 {
  if !p.IsSetReplicaId() {
    return THRegionInfo_ReplicaId_DEFAULT
  }
return *p.ReplicaId
}
func (p *THRegionInfo) IsSetStartKey() bool {
  return p.StartKey != nil
}

func (p *THRegionInfo) IsSetEndKey() bool {
  return p.EndKey != nil
}

func (p *THRegionInfo) IsSetOffline() bool {
  return p.Offline != nil
}

func (p *THRegionInfo) IsSetSplit() bool {
  return p.Split != nil
}

func (p *THRegionInfo) IsSetReplicaId() bool {
  return p.ReplicaId != nil
}

func (p *THRegionInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRegionId bool = false;
  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRegionId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRegionId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RegionId is not set"));
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THRegionInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RegionId = v
}
  return nil
}

func (p *THRegionInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TableName = v
}
  return nil
}

func (p *THRegionInfo)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.StartKey = v
}
  return nil
}

func (p *THRegionInfo)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.EndKey = v
}
  return nil
}

func (p *THRegionInfo)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Offline = &v
}
  return nil
}

func (p *THRegionInfo)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Split = &v
}
  return nil
}

func (p *THRegionInfo)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.ReplicaId = &v
}
  return nil
}

func (p *THRegionInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "THRegionInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THRegionInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "regionId", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regionId: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RegionId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.regionId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regionId: ", p), err) }
  return err
}

func (p *THRegionInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tableName: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.TableName); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tableName (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tableName: ", p), err) }
  return err
}

func (p *THRegionInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStartKey() {
    if err := oprot.WriteFieldBegin(ctx, "startKey", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:startKey: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.StartKey); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.startKey (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:startKey: ", p), err) }
  }
  return err
}

func (p *THRegionInfo) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEndKey() {
    if err := oprot.WriteFieldBegin(ctx, "endKey", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:endKey: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.EndKey); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.endKey (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:endKey: ", p), err) }
  }
  return err
}

func (p *THRegionInfo) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffline() {
    if err := oprot.WriteFieldBegin(ctx, "offline", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:offline: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Offline)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offline (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:offline: ", p), err) }
  }
  return err
}

func (p *THRegionInfo) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSplit() {
    if err := oprot.WriteFieldBegin(ctx, "split", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:split: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Split)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.split (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:split: ", p), err) }
  }
  return err
}

func (p *THRegionInfo) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReplicaId() {
    if err := oprot.WriteFieldBegin(ctx, "replicaId", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:replicaId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ReplicaId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.replicaId (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:replicaId: ", p), err) }
  }
  return err
}

func (p *THRegionInfo) Equals(other *THRegionInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.RegionId != other.RegionId { return false }
  if bytes.Compare(p.TableName, other.TableName) != 0 { return false }
  if bytes.Compare(p.StartKey, other.StartKey) != 0 { return false }
  if bytes.Compare(p.EndKey, other.EndKey) != 0 { return false }
  if p.Offline != other.Offline {
    if p.Offline == nil || other.Offline == nil {
      return false
    }
    if (*p.Offline) != (*other.Offline) { return false }
  }
  if p.Split != other.Split {
    if p.Split == nil || other.Split == nil {
      return false
    }
    if (*p.Split) != (*other.Split) { return false }
  }
  if p.ReplicaId != other.ReplicaId {
    if p.ReplicaId == nil || other.ReplicaId == nil {
      return false
    }
    if (*p.ReplicaId) != (*other.ReplicaId) { return false }
  }
  return true
}

func (p *THRegionInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THRegionInfo(%+v)", *p)
}

// Attributes:
//  - HostName
//  - Port
//  - StartCode
type TServerName struct {
  HostName string `thrift:"hostName,1,required" db:"hostName" json:"hostName"`
  Port *int32 `thrift:"port,2" db:"port" json:"port,omitempty"`
  StartCode *int64 `thrift:"startCode,3" db:"startCode" json:"startCode,omitempty"`
}

func NewTServerName() *TServerName {
  return &TServerName{}
}


func (p *TServerName) GetHostName() string {
  return p.HostName
}
var TServerName_Port_DEFAULT int32
func (p *TServerName) GetPort() int32 {
  if !p.IsSetPort() {
    return TServerName_Port_DEFAULT
  }
return *p.Port
}
var TServerName_StartCode_DEFAULT int64
func (p *TServerName) GetStartCode() int64 {
  if !p.IsSetStartCode() {
    return TServerName_StartCode_DEFAULT
  }
return *p.StartCode
}
func (p *TServerName) IsSetPort() bool {
  return p.Port != nil
}

func (p *TServerName) IsSetStartCode() bool {
  return p.StartCode != nil
}

func (p *TServerName) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetHostName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetHostName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetHostName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field HostName is not set"));
  }
  return nil
}

func (p *TServerName)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.HostName = v
}
  return nil
}

func (p *TServerName)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Port = &v
}
  return nil
}

func (p *TServerName)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.StartCode = &v
}
  return nil
}

func (p *TServerName) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TServerName"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TServerName) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hostName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hostName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HostName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hostName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hostName: ", p), err) }
  return err
}

func (p *TServerName) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPort() {
    if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:port: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Port)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.port (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:port: ", p), err) }
  }
  return err
}

func (p *TServerName) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStartCode() {
    if err := oprot.WriteFieldBegin(ctx, "startCode", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:startCode: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.StartCode)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.startCode (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:startCode: ", p), err) }
  }
  return err
}

func (p *TServerName) Equals(other *TServerName) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.HostName != other.HostName { return false }
  if p.Port != other.Port {
    if p.Port == nil || other.Port == nil {
      return false
    }
    if (*p.Port) != (*other.Port) { return false }
  }
  if p.StartCode != other.StartCode {
    if p.StartCode == nil || other.StartCode == nil {
      return false
    }
    if (*p.StartCode) != (*other.StartCode) { return false }
  }
  return true
}

func (p *TServerName) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TServerName(%+v)", *p)
}

// Attributes:
//  - ServerName
//  - RegionInfo
type THRegionLocation struct {
  ServerName *TServerName `thrift:"serverName,1,required" db:"serverName" json:"serverName"`
  RegionInfo *THRegionInfo `thrift:"regionInfo,2,required" db:"regionInfo" json:"regionInfo"`
}

func NewTHRegionLocation() *THRegionLocation {
  return &THRegionLocation{}
}

var THRegionLocation_ServerName_DEFAULT *TServerName
func (p *THRegionLocation) GetServerName() *TServerName {
  if !p.IsSetServerName() {
    return THRegionLocation_ServerName_DEFAULT
  }
return p.ServerName
}
var THRegionLocation_RegionInfo_DEFAULT *THRegionInfo
func (p *THRegionLocation) GetRegionInfo() *THRegionInfo {
  if !p.IsSetRegionInfo() {
    return THRegionLocation_RegionInfo_DEFAULT
  }
return p.RegionInfo
}
func (p *THRegionLocation) IsSetServerName() bool {
  return p.ServerName != nil
}

func (p *THRegionLocation) IsSetRegionInfo() bool {
  return p.RegionInfo != nil
}

func (p *THRegionLocation) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetServerName bool = false;
  var issetRegionInfo bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetServerName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRegionInfo = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetServerName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ServerName is not set"));
  }
  if !issetRegionInfo{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RegionInfo is not set"));
  }
  return nil
}

func (p *THRegionLocation)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.ServerName = &TServerName{}
  if err := p.ServerName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerName), err)
  }
  return nil
}

func (p *THRegionLocation)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.RegionInfo = &THRegionInfo{}
  if err := p.RegionInfo.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RegionInfo), err)
  }
  return nil
}

func (p *THRegionLocation) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "THRegionLocation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THRegionLocation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serverName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverName: ", p), err) }
  if err := p.ServerName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverName: ", p), err) }
  return err
}

func (p *THRegionLocation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "regionInfo", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:regionInfo: ", p), err) }
  if err := p.RegionInfo.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RegionInfo), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:regionInfo: ", p), err) }
  return err
}

func (p *THRegionLocation) Equals(other *THRegionLocation) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.ServerName.Equals(other.ServerName) { return false }
  if !p.RegionInfo.Equals(other.RegionInfo) { return false }
  return true
}

func (p *THRegionLocation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THRegionLocation(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.TableName
// 
// Attributes:
//  - Ns: namespace name
//  - Qualifier: tablename
type TTableName struct {
  Ns []byte `thrift:"ns,1" db:"ns" json:"ns,omitempty"`
  Qualifier []byte `thrift:"qualifier,2,required" db:"qualifier" json:"qualifier"`
}

func NewTTableName() *TTableName {
  return &TTableName{}
}

var TTableName_Ns_DEFAULT []byte

func (p *TTableName) GetNs() []byte {
  return p.Ns
}

func (p *TTableName) GetQualifier() []byte {
  return p.Qualifier
}
func (p *TTableName) IsSetNs() bool {
  return p.Ns != nil
}

func (p *TTableName) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetQualifier bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  return nil
}

func (p *TTableName)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ns = v
}
  return nil
}

func (p *TTableName)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *TTableName) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TTableName"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TTableName) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNs() {
    if err := oprot.WriteFieldBegin(ctx, "ns", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ns: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Ns); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ns (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ns: ", p), err) }
  }
  return err
}

func (p *TTableName) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:qualifier: ", p), err) }
  return err
}

func (p *TTableName) Equals(other *TTableName) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Ns, other.Ns) != 0 { return false }
  if bytes.Compare(p.Qualifier, other.Qualifier) != 0 { return false }
  return true
}

func (p *TTableName) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TTableName(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.ColumnFamilyDescriptor
// 
// Attributes:
//  - Name
//  - Attributes
//  - Configuration
//  - BlockSize
//  - BloomnFilterType
//  - CompressionType
//  - DfsReplication
//  - DataBlockEncoding
//  - KeepDeletedCells
//  - MaxVersions
//  - MinVersions
//  - Scope
//  - TimeToLive
//  - BlockCacheEnabled
//  - CacheBloomsOnWrite
//  - CacheDataOnWrite
//  - CacheIndexesOnWrite
//  - CompressTags
//  - EvictBlocksOnClose
//  - InMemory
type TColumnFamilyDescriptor struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  Attributes map[string][]byte `thrift:"attributes,2" db:"attributes" json:"attributes,omitempty"`
  Configuration map[string]string `thrift:"configuration,3" db:"configuration" json:"configuration,omitempty"`
  BlockSize *int32 `thrift:"blockSize,4" db:"blockSize" json:"blockSize,omitempty"`
  BloomnFilterType *TBloomFilterType `thrift:"bloomnFilterType,5" db:"bloomnFilterType" json:"bloomnFilterType,omitempty"`
  CompressionType *TCompressionAlgorithm `thrift:"compressionType,6" db:"compressionType" json:"compressionType,omitempty"`
  DfsReplication *int16 `thrift:"dfsReplication,7" db:"dfsReplication" json:"dfsReplication,omitempty"`
  DataBlockEncoding *TDataBlockEncoding `thrift:"dataBlockEncoding,8" db:"dataBlockEncoding" json:"dataBlockEncoding,omitempty"`
  KeepDeletedCells *TKeepDeletedCells `thrift:"keepDeletedCells,9" db:"keepDeletedCells" json:"keepDeletedCells,omitempty"`
  MaxVersions *int32 `thrift:"maxVersions,10" db:"maxVersions" json:"maxVersions,omitempty"`
  MinVersions *int32 `thrift:"minVersions,11" db:"minVersions" json:"minVersions,omitempty"`
  Scope *int32 `thrift:"scope,12" db:"scope" json:"scope,omitempty"`
  TimeToLive *int32 `thrift:"timeToLive,13" db:"timeToLive" json:"timeToLive,omitempty"`
  BlockCacheEnabled *bool `thrift:"blockCacheEnabled,14" db:"blockCacheEnabled" json:"blockCacheEnabled,omitempty"`
  CacheBloomsOnWrite *bool `thrift:"cacheBloomsOnWrite,15" db:"cacheBloomsOnWrite" json:"cacheBloomsOnWrite,omitempty"`
  CacheDataOnWrite *bool `thrift:"cacheDataOnWrite,16" db:"cacheDataOnWrite" json:"cacheDataOnWrite,omitempty"`
  CacheIndexesOnWrite *bool `thrift:"cacheIndexesOnWrite,17" db:"cacheIndexesOnWrite" json:"cacheIndexesOnWrite,omitempty"`
  CompressTags *bool `thrift:"compressTags,18" db:"compressTags" json:"compressTags,omitempty"`
  EvictBlocksOnClose *bool `thrift:"evictBlocksOnClose,19" db:"evictBlocksOnClose" json:"evictBlocksOnClose,omitempty"`
  InMemory *bool `thrift:"inMemory,20" db:"inMemory" json:"inMemory,omitempty"`
}

func NewTColumnFamilyDescriptor() *TColumnFamilyDescriptor {
  return &TColumnFamilyDescriptor{}
}


func (p *TColumnFamilyDescriptor) GetName() []byte {
  return p.Name
}
var TColumnFamilyDescriptor_Attributes_DEFAULT map[string][]byte

func (p *TColumnFamilyDescriptor) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TColumnFamilyDescriptor_Configuration_DEFAULT map[string]string

func (p *TColumnFamilyDescriptor) GetConfiguration() map[string]string {
  return p.Configuration
}
var TColumnFamilyDescriptor_BlockSize_DEFAULT int32
func (p *TColumnFamilyDescriptor) GetBlockSize() int32 {
  if !p.IsSetBlockSize() {
    return TColumnFamilyDescriptor_BlockSize_DEFAULT
  }
return *p.BlockSize
}
var TColumnFamilyDescriptor_BloomnFilterType_DEFAULT TBloomFilterType
func (p *TColumnFamilyDescriptor) GetBloomnFilterType() TBloomFilterType {
  if !p.IsSetBloomnFilterType() {
    return TColumnFamilyDescriptor_BloomnFilterType_DEFAULT
  }
return *p.BloomnFilterType
}
var TColumnFamilyDescriptor_CompressionType_DEFAULT TCompressionAlgorithm
func (p *TColumnFamilyDescriptor) GetCompressionType() TCompressionAlgorithm {
  if !p.IsSetCompressionType() {
    return TColumnFamilyDescriptor_CompressionType_DEFAULT
  }
return *p.CompressionType
}
var TColumnFamilyDescriptor_DfsReplication_DEFAULT int16
func (p *TColumnFamilyDescriptor) GetDfsReplication() int16 {
  if !p.IsSetDfsReplication() {
    return TColumnFamilyDescriptor_DfsReplication_DEFAULT
  }
return *p.DfsReplication
}
var TColumnFamilyDescriptor_DataBlockEncoding_DEFAULT TDataBlockEncoding
func (p *TColumnFamilyDescriptor) GetDataBlockEncoding() TDataBlockEncoding {
  if !p.IsSetDataBlockEncoding() {
    return TColumnFamilyDescriptor_DataBlockEncoding_DEFAULT
  }
return *p.DataBlockEncoding
}
var TColumnFamilyDescriptor_KeepDeletedCells_DEFAULT TKeepDeletedCells
func (p *TColumnFamilyDescriptor) GetKeepDeletedCells() TKeepDeletedCells {
  if !p.IsSetKeepDeletedCells() {
    return TColumnFamilyDescriptor_KeepDeletedCells_DEFAULT
  }
return *p.KeepDeletedCells
}
var TColumnFamilyDescriptor_MaxVersions_DEFAULT int32
func (p *TColumnFamilyDescriptor) GetMaxVersions() int32 {
  if !p.IsSetMaxVersions() {
    return TColumnFamilyDescriptor_MaxVersions_DEFAULT
  }
return *p.MaxVersions
}
var TColumnFamilyDescriptor_MinVersions_DEFAULT int32
func (p *TColumnFamilyDescriptor) GetMinVersions() int32 {
  if !p.IsSetMinVersions() {
    return TColumnFamilyDescriptor_MinVersions_DEFAULT
  }
return *p.MinVersions
}
var TColumnFamilyDescriptor_Scope_DEFAULT int32
func (p *TColumnFamilyDescriptor) GetScope() int32 {
  if !p.IsSetScope() {
    return TColumnFamilyDescriptor_Scope_DEFAULT
  }
return *p.Scope
}
var TColumnFamilyDescriptor_TimeToLive_DEFAULT int32
func (p *TColumnFamilyDescriptor) GetTimeToLive() int32 {
  if !p.IsSetTimeToLive() {
    return TColumnFamilyDescriptor_TimeToLive_DEFAULT
  }
return *p.TimeToLive
}
var TColumnFamilyDescriptor_BlockCacheEnabled_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetBlockCacheEnabled() bool {
  if !p.IsSetBlockCacheEnabled() {
    return TColumnFamilyDescriptor_BlockCacheEnabled_DEFAULT
  }
return *p.BlockCacheEnabled
}
var TColumnFamilyDescriptor_CacheBloomsOnWrite_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetCacheBloomsOnWrite() bool {
  if !p.IsSetCacheBloomsOnWrite() {
    return TColumnFamilyDescriptor_CacheBloomsOnWrite_DEFAULT
  }
return *p.CacheBloomsOnWrite
}
var TColumnFamilyDescriptor_CacheDataOnWrite_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetCacheDataOnWrite() bool {
  if !p.IsSetCacheDataOnWrite() {
    return TColumnFamilyDescriptor_CacheDataOnWrite_DEFAULT
  }
return *p.CacheDataOnWrite
}
var TColumnFamilyDescriptor_CacheIndexesOnWrite_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetCacheIndexesOnWrite() bool {
  if !p.IsSetCacheIndexesOnWrite() {
    return TColumnFamilyDescriptor_CacheIndexesOnWrite_DEFAULT
  }
return *p.CacheIndexesOnWrite
}
var TColumnFamilyDescriptor_CompressTags_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetCompressTags() bool {
  if !p.IsSetCompressTags() {
    return TColumnFamilyDescriptor_CompressTags_DEFAULT
  }
return *p.CompressTags
}
var TColumnFamilyDescriptor_EvictBlocksOnClose_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetEvictBlocksOnClose() bool {
  if !p.IsSetEvictBlocksOnClose() {
    return TColumnFamilyDescriptor_EvictBlocksOnClose_DEFAULT
  }
return *p.EvictBlocksOnClose
}
var TColumnFamilyDescriptor_InMemory_DEFAULT bool
func (p *TColumnFamilyDescriptor) GetInMemory() bool {
  if !p.IsSetInMemory() {
    return TColumnFamilyDescriptor_InMemory_DEFAULT
  }
return *p.InMemory
}
func (p *TColumnFamilyDescriptor) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TColumnFamilyDescriptor) IsSetConfiguration() bool {
  return p.Configuration != nil
}

func (p *TColumnFamilyDescriptor) IsSetBlockSize() bool {
  return p.BlockSize != nil
}

func (p *TColumnFamilyDescriptor) IsSetBloomnFilterType() bool {
  return p.BloomnFilterType != nil
}

func (p *TColumnFamilyDescriptor) IsSetCompressionType() bool {
  return p.CompressionType != nil
}

func (p *TColumnFamilyDescriptor) IsSetDfsReplication() bool {
  return p.DfsReplication != nil
}

func (p *TColumnFamilyDescriptor) IsSetDataBlockEncoding() bool {
  return p.DataBlockEncoding != nil
}

func (p *TColumnFamilyDescriptor) IsSetKeepDeletedCells() bool {
  return p.KeepDeletedCells != nil
}

func (p *TColumnFamilyDescriptor) IsSetMaxVersions() bool {
  return p.MaxVersions != nil
}

func (p *TColumnFamilyDescriptor) IsSetMinVersions() bool {
  return p.MinVersions != nil
}

func (p *TColumnFamilyDescriptor) IsSetScope() bool {
  return p.Scope != nil
}

func (p *TColumnFamilyDescriptor) IsSetTimeToLive() bool {
  return p.TimeToLive != nil
}

func (p *TColumnFamilyDescriptor) IsSetBlockCacheEnabled() bool {
  return p.BlockCacheEnabled != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheBloomsOnWrite() bool {
  return p.CacheBloomsOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheDataOnWrite() bool {
  return p.CacheDataOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCacheIndexesOnWrite() bool {
  return p.CacheIndexesOnWrite != nil
}

func (p *TColumnFamilyDescriptor) IsSetCompressTags() bool {
  return p.CompressTags != nil
}

func (p *TColumnFamilyDescriptor) IsSetEvictBlocksOnClose() bool {
  return p.EvictBlocksOnClose != nil
}

func (p *TColumnFamilyDescriptor) IsSetInMemory() bool {
  return p.InMemory != nil
}

func (p *TColumnFamilyDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I16 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField18(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 19:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField19(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField20(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key39 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key39 = v
}
var _val40 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val40 = v
}
    p.Attributes[_key39] = _val40
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Configuration =  tMap
  for i := 0; i < size; i ++ {
var _key41 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key41 = v
}
var _val42 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val42 = v
}
    p.Configuration[_key41] = _val42
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.BlockSize = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := TBloomFilterType(v)
  p.BloomnFilterType = &temp
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := TCompressionAlgorithm(v)
  p.CompressionType = &temp
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI16(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.DfsReplication = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  temp := TDataBlockEncoding(v)
  p.DataBlockEncoding = &temp
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  temp := TKeepDeletedCells(v)
  p.KeepDeletedCells = &temp
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.MaxVersions = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.MinVersions = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.Scope = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.TimeToLive = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.BlockCacheEnabled = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  p.CacheBloomsOnWrite = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  p.CacheDataOnWrite = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 17: ", err)
} else {
  p.CacheIndexesOnWrite = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 18: ", err)
} else {
  p.CompressTags = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField19(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 19: ", err)
} else {
  p.EvictBlocksOnClose = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor)  ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 20: ", err)
} else {
  p.InMemory = &v
}
  return nil
}

func (p *TColumnFamilyDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TColumnFamilyDescriptor"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
    if err := p.writeField18(ctx, oprot); err != nil { return err }
    if err := p.writeField19(ctx, oprot); err != nil { return err }
    if err := p.writeField20(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TColumnFamilyDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *TColumnFamilyDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:attributes: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetConfiguration() {
    if err := oprot.WriteFieldBegin(ctx, "configuration", thrift.MAP, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:configuration: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Configuration)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Configuration {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:configuration: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlockSize() {
    if err := oprot.WriteFieldBegin(ctx, "blockSize", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:blockSize: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BlockSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blockSize (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:blockSize: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBloomnFilterType() {
    if err := oprot.WriteFieldBegin(ctx, "bloomnFilterType", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:bloomnFilterType: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BloomnFilterType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.bloomnFilterType (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:bloomnFilterType: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCompressionType() {
    if err := oprot.WriteFieldBegin(ctx, "compressionType", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:compressionType: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CompressionType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.compressionType (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:compressionType: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDfsReplication() {
    if err := oprot.WriteFieldBegin(ctx, "dfsReplication", thrift.I16, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:dfsReplication: ", p), err) }
    if err := oprot.WriteI16(ctx, int16(*p.DfsReplication)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.dfsReplication (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:dfsReplication: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDataBlockEncoding() {
    if err := oprot.WriteFieldBegin(ctx, "dataBlockEncoding", thrift.I32, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:dataBlockEncoding: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.DataBlockEncoding)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.dataBlockEncoding (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:dataBlockEncoding: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetKeepDeletedCells() {
    if err := oprot.WriteFieldBegin(ctx, "keepDeletedCells", thrift.I32, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:keepDeletedCells: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.KeepDeletedCells)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.keepDeletedCells (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:keepDeletedCells: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxVersions() {
    if err := oprot.WriteFieldBegin(ctx, "maxVersions", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:maxVersions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxVersions (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:maxVersions: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMinVersions() {
    if err := oprot.WriteFieldBegin(ctx, "minVersions", thrift.I32, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:minVersions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MinVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.minVersions (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:minVersions: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetScope() {
    if err := oprot.WriteFieldBegin(ctx, "scope", thrift.I32, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:scope: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Scope)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.scope (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:scope: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimeToLive() {
    if err := oprot.WriteFieldBegin(ctx, "timeToLive", thrift.I32, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:timeToLive: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.TimeToLive)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timeToLive (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:timeToLive: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlockCacheEnabled() {
    if err := oprot.WriteFieldBegin(ctx, "blockCacheEnabled", thrift.BOOL, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:blockCacheEnabled: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.BlockCacheEnabled)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blockCacheEnabled (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:blockCacheEnabled: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheBloomsOnWrite() {
    if err := oprot.WriteFieldBegin(ctx, "cacheBloomsOnWrite", thrift.BOOL, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:cacheBloomsOnWrite: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CacheBloomsOnWrite)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheBloomsOnWrite (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:cacheBloomsOnWrite: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheDataOnWrite() {
    if err := oprot.WriteFieldBegin(ctx, "cacheDataOnWrite", thrift.BOOL, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:cacheDataOnWrite: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CacheDataOnWrite)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheDataOnWrite (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:cacheDataOnWrite: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheIndexesOnWrite() {
    if err := oprot.WriteFieldBegin(ctx, "cacheIndexesOnWrite", thrift.BOOL, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:cacheIndexesOnWrite: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CacheIndexesOnWrite)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheIndexesOnWrite (17) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:cacheIndexesOnWrite: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCompressTags() {
    if err := oprot.WriteFieldBegin(ctx, "compressTags", thrift.BOOL, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:compressTags: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CompressTags)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.compressTags (18) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:compressTags: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField19(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEvictBlocksOnClose() {
    if err := oprot.WriteFieldBegin(ctx, "evictBlocksOnClose", thrift.BOOL, 19); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 19:evictBlocksOnClose: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EvictBlocksOnClose)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.evictBlocksOnClose (19) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 19:evictBlocksOnClose: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInMemory() {
    if err := oprot.WriteFieldBegin(ctx, "inMemory", thrift.BOOL, 20); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:inMemory: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.InMemory)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.inMemory (20) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 20:inMemory: ", p), err) }
  }
  return err
}

func (p *TColumnFamilyDescriptor) Equals(other *TColumnFamilyDescriptor) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Name, other.Name) != 0 { return false }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src43 := other.Attributes[k]
    if bytes.Compare(_tgt, _src43) != 0 { return false }
  }
  if len(p.Configuration) != len(other.Configuration) { return false }
  for k, _tgt := range p.Configuration {
    _src44 := other.Configuration[k]
    if _tgt != _src44 { return false }
  }
  if p.BlockSize != other.BlockSize {
    if p.BlockSize == nil || other.BlockSize == nil {
      return false
    }
    if (*p.BlockSize) != (*other.BlockSize) { return false }
  }
  if p.BloomnFilterType != other.BloomnFilterType {
    if p.BloomnFilterType == nil || other.BloomnFilterType == nil {
      return false
    }
    if (*p.BloomnFilterType) != (*other.BloomnFilterType) { return false }
  }
  if p.CompressionType != other.CompressionType {
    if p.CompressionType == nil || other.CompressionType == nil {
      return false
    }
    if (*p.CompressionType) != (*other.CompressionType) { return false }
  }
  if p.DfsReplication != other.DfsReplication {
    if p.DfsReplication == nil || other.DfsReplication == nil {
      return false
    }
    if (*p.DfsReplication) != (*other.DfsReplication) { return false }
  }
  if p.DataBlockEncoding != other.DataBlockEncoding {
    if p.DataBlockEncoding == nil || other.DataBlockEncoding == nil {
      return false
    }
    if (*p.DataBlockEncoding) != (*other.DataBlockEncoding) { return false }
  }
  if p.KeepDeletedCells != other.KeepDeletedCells {
    if p.KeepDeletedCells == nil || other.KeepDeletedCells == nil {
      return false
    }
    if (*p.KeepDeletedCells) != (*other.KeepDeletedCells) { return false }
  }
  if p.MaxVersions != other.MaxVersions {
    if p.MaxVersions == nil || other.MaxVersions == nil {
      return false
    }
    if (*p.MaxVersions) != (*other.MaxVersions) { return false }
  }
  if p.MinVersions != other.MinVersions {
    if p.MinVersions == nil || other.MinVersions == nil {
      return false
    }
    if (*p.MinVersions) != (*other.MinVersions) { return false }
  }
  if p.Scope != other.Scope {
    if p.Scope == nil || other.Scope == nil {
      return false
    }
    if (*p.Scope) != (*other.Scope) { return false }
  }
  if p.TimeToLive != other.TimeToLive {
    if p.TimeToLive == nil || other.TimeToLive == nil {
      return false
    }
    if (*p.TimeToLive) != (*other.TimeToLive) { return false }
  }
  if p.BlockCacheEnabled != other.BlockCacheEnabled {
    if p.BlockCacheEnabled == nil || other.BlockCacheEnabled == nil {
      return false
    }
    if (*p.BlockCacheEnabled) != (*other.BlockCacheEnabled) { return false }
  }
  if p.CacheBloomsOnWrite != other.CacheBloomsOnWrite {
    if p.CacheBloomsOnWrite == nil || other.CacheBloomsOnWrite == nil {
      return false
    }
    if (*p.CacheBloomsOnWrite) != (*other.CacheBloomsOnWrite) { return false }
  }
  if p.CacheDataOnWrite != other.CacheDataOnWrite {
    if p.CacheDataOnWrite == nil || other.CacheDataOnWrite == nil {
      return false
    }
    if (*p.CacheDataOnWrite) != (*other.CacheDataOnWrite) { return false }
  }
  if p.CacheIndexesOnWrite != other.CacheIndexesOnWrite {
    if p.CacheIndexesOnWrite == nil || other.CacheIndexesOnWrite == nil {
      return false
    }
    if (*p.CacheIndexesOnWrite) != (*other.CacheIndexesOnWrite) { return false }
  }
  if p.CompressTags != other.CompressTags {
    if p.CompressTags == nil || other.CompressTags == nil {
      return false
    }
    if (*p.CompressTags) != (*other.CompressTags) { return false }
  }
  if p.EvictBlocksOnClose != other.EvictBlocksOnClose {
    if p.EvictBlocksOnClose == nil || other.EvictBlocksOnClose == nil {
      return false
    }
    if (*p.EvictBlocksOnClose) != (*other.EvictBlocksOnClose) { return false }
  }
  if p.InMemory != other.InMemory {
    if p.InMemory == nil || other.InMemory == nil {
      return false
    }
    if (*p.InMemory) != (*other.InMemory) { return false }
  }
  return true
}

func (p *TColumnFamilyDescriptor) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TColumnFamilyDescriptor(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.TableDescriptor
// 
// Attributes:
//  - TableName
//  - Columns
//  - Attributes
//  - Durability
type TTableDescriptor struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  Columns []*TColumnFamilyDescriptor `thrift:"columns,2" db:"columns" json:"columns,omitempty"`
  Attributes map[string][]byte `thrift:"attributes,3" db:"attributes" json:"attributes,omitempty"`
  Durability *TDurability `thrift:"durability,4" db:"durability" json:"durability,omitempty"`
}

func NewTTableDescriptor() *TTableDescriptor {
  return &TTableDescriptor{}
}

var TTableDescriptor_TableName_DEFAULT *TTableName
func (p *TTableDescriptor) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return TTableDescriptor_TableName_DEFAULT
  }
return p.TableName
}
var TTableDescriptor_Columns_DEFAULT []*TColumnFamilyDescriptor

func (p *TTableDescriptor) GetColumns() []*TColumnFamilyDescriptor {
  return p.Columns
}
var TTableDescriptor_Attributes_DEFAULT map[string][]byte

func (p *TTableDescriptor) GetAttributes() map[string][]byte {
  return p.Attributes
}
var TTableDescriptor_Durability_DEFAULT TDurability
func (p *TTableDescriptor) GetDurability() TDurability {
  if !p.IsSetDurability() {
    return TTableDescriptor_Durability_DEFAULT
  }
return *p.Durability
}
func (p *TTableDescriptor) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *TTableDescriptor) IsSetColumns() bool {
  return p.Columns != nil
}

func (p *TTableDescriptor) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *TTableDescriptor) IsSetDurability() bool {
  return p.Durability != nil
}

func (p *TTableDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *TTableDescriptor)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *TTableDescriptor)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TColumnFamilyDescriptor, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem45 := &TColumnFamilyDescriptor{}
    if err := _elem45.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem45), err)
    }
    p.Columns = append(p.Columns, _elem45)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TTableDescriptor)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]byte, size)
  p.Attributes =  tMap
  for i := 0; i < size; i ++ {
var _key46 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key46 = v
}
var _val47 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val47 = v
}
    p.Attributes[_key46] = _val47
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TTableDescriptor)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := TDurability(v)
  p.Durability = &temp
}
  return nil
}

func (p *TTableDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TTableDescriptor"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TTableDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *TTableDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColumns() {
    if err := oprot.WriteFieldBegin(ctx, "columns", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Columns)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Columns {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  }
  return err
}

func (p *TTableDescriptor) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.MAP, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:attributes: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Attributes {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:attributes: ", p), err) }
  }
  return err
}

func (p *TTableDescriptor) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDurability() {
    if err := oprot.WriteFieldBegin(ctx, "durability", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:durability: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Durability)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durability (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:durability: ", p), err) }
  }
  return err
}

func (p *TTableDescriptor) Equals(other *TTableDescriptor) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.TableName.Equals(other.TableName) { return false }
  if len(p.Columns) != len(other.Columns) { return false }
  for i, _tgt := range p.Columns {
    _src48 := other.Columns[i]
    if !_tgt.Equals(_src48) { return false }
  }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for k, _tgt := range p.Attributes {
    _src49 := other.Attributes[k]
    if bytes.Compare(_tgt, _src49) != 0 { return false }
  }
  if p.Durability != other.Durability {
    if p.Durability == nil || other.Durability == nil {
      return false
    }
    if (*p.Durability) != (*other.Durability) { return false }
  }
  return true
}

func (p *TTableDescriptor) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TTableDescriptor(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.NamespaceDescriptor
// 
// Attributes:
//  - Name
//  - Configuration
type TNamespaceDescriptor struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
  Configuration map[string]string `thrift:"configuration,2" db:"configuration" json:"configuration,omitempty"`
}

func NewTNamespaceDescriptor() *TNamespaceDescriptor {
  return &TNamespaceDescriptor{}
}


func (p *TNamespaceDescriptor) GetName() string {
  return p.Name
}
var TNamespaceDescriptor_Configuration_DEFAULT map[string]string

func (p *TNamespaceDescriptor) GetConfiguration() map[string]string {
  return p.Configuration
}
func (p *TNamespaceDescriptor) IsSetConfiguration() bool {
  return p.Configuration != nil
}

func (p *TNamespaceDescriptor) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *TNamespaceDescriptor)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *TNamespaceDescriptor)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Configuration =  tMap
  for i := 0; i < size; i ++ {
var _key50 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key50 = v
}
var _val51 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val51 = v
}
    p.Configuration[_key50] = _val51
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TNamespaceDescriptor) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TNamespaceDescriptor"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TNamespaceDescriptor) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *TNamespaceDescriptor) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetConfiguration() {
    if err := oprot.WriteFieldBegin(ctx, "configuration", thrift.MAP, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:configuration: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Configuration)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Configuration {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:configuration: ", p), err) }
  }
  return err
}

func (p *TNamespaceDescriptor) Equals(other *TNamespaceDescriptor) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if len(p.Configuration) != len(other.Configuration) { return false }
  for k, _tgt := range p.Configuration {
    _src52 := other.Configuration[k]
    if _tgt != _src52 { return false }
  }
  return true
}

func (p *TNamespaceDescriptor) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TNamespaceDescriptor(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.LogQueryFilter
// 
// Attributes:
//  - RegionName
//  - ClientAddress
//  - TableName
//  - UserName
//  - Limit
//  - LogType
//  - FilterByOperator
type TLogQueryFilter struct {
  RegionName *string `thrift:"regionName,1" db:"regionName" json:"regionName,omitempty"`
  ClientAddress *string `thrift:"clientAddress,2" db:"clientAddress" json:"clientAddress,omitempty"`
  TableName *string `thrift:"tableName,3" db:"tableName" json:"tableName,omitempty"`
  UserName *string `thrift:"userName,4" db:"userName" json:"userName,omitempty"`
  Limit int32 `thrift:"limit,5" db:"limit" json:"limit"`
  LogType TLogType `thrift:"logType,6" db:"logType" json:"logType"`
  FilterByOperator TFilterByOperator `thrift:"filterByOperator,7" db:"filterByOperator" json:"filterByOperator"`
}

func NewTLogQueryFilter() *TLogQueryFilter {
  return &TLogQueryFilter{
Limit: 10,

LogType: 1,

FilterByOperator: 1,
}
}

var TLogQueryFilter_RegionName_DEFAULT string
func (p *TLogQueryFilter) GetRegionName() string {
  if !p.IsSetRegionName() {
    return TLogQueryFilter_RegionName_DEFAULT
  }
return *p.RegionName
}
var TLogQueryFilter_ClientAddress_DEFAULT string
func (p *TLogQueryFilter) GetClientAddress() string {
  if !p.IsSetClientAddress() {
    return TLogQueryFilter_ClientAddress_DEFAULT
  }
return *p.ClientAddress
}
var TLogQueryFilter_TableName_DEFAULT string
func (p *TLogQueryFilter) GetTableName() string {
  if !p.IsSetTableName() {
    return TLogQueryFilter_TableName_DEFAULT
  }
return *p.TableName
}
var TLogQueryFilter_UserName_DEFAULT string
func (p *TLogQueryFilter) GetUserName() string {
  if !p.IsSetUserName() {
    return TLogQueryFilter_UserName_DEFAULT
  }
return *p.UserName
}
var TLogQueryFilter_Limit_DEFAULT int32 = 10

func (p *TLogQueryFilter) GetLimit() int32 {
  return p.Limit
}
var TLogQueryFilter_LogType_DEFAULT TLogType = 1

func (p *TLogQueryFilter) GetLogType() TLogType {
  return p.LogType
}
var TLogQueryFilter_FilterByOperator_DEFAULT TFilterByOperator = 1

func (p *TLogQueryFilter) GetFilterByOperator() TFilterByOperator {
  return p.FilterByOperator
}
func (p *TLogQueryFilter) IsSetRegionName() bool {
  return p.RegionName != nil
}

func (p *TLogQueryFilter) IsSetClientAddress() bool {
  return p.ClientAddress != nil
}

func (p *TLogQueryFilter) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *TLogQueryFilter) IsSetUserName() bool {
  return p.UserName != nil
}

func (p *TLogQueryFilter) IsSetLimit() bool {
  return p.Limit != TLogQueryFilter_Limit_DEFAULT
}

func (p *TLogQueryFilter) IsSetLogType() bool {
  return p.LogType != TLogQueryFilter_LogType_DEFAULT
}

func (p *TLogQueryFilter) IsSetFilterByOperator() bool {
  return p.FilterByOperator != TLogQueryFilter_FilterByOperator_DEFAULT
}

func (p *TLogQueryFilter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TLogQueryFilter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.RegionName = &v
}
  return nil
}

func (p *TLogQueryFilter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ClientAddress = &v
}
  return nil
}

func (p *TLogQueryFilter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TableName = &v
}
  return nil
}

func (p *TLogQueryFilter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.UserName = &v
}
  return nil
}

func (p *TLogQueryFilter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Limit = v
}
  return nil
}

func (p *TLogQueryFilter)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := TLogType(v)
  p.LogType = temp
}
  return nil
}

func (p *TLogQueryFilter)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  temp := TFilterByOperator(v)
  p.FilterByOperator = temp
}
  return nil
}

func (p *TLogQueryFilter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TLogQueryFilter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TLogQueryFilter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRegionName() {
    if err := oprot.WriteFieldBegin(ctx, "regionName", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regionName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.RegionName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.regionName (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regionName: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetClientAddress() {
    if err := oprot.WriteFieldBegin(ctx, "clientAddress", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:clientAddress: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.ClientAddress)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.clientAddress (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:clientAddress: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTableName() {
    if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tableName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.TableName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tableName (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tableName: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserName() {
    if err := oprot.WriteFieldBegin(ctx, "userName", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:userName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.UserName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userName (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:userName: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLimit() {
    if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:limit: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(p.Limit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.limit (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:limit: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLogType() {
    if err := oprot.WriteFieldBegin(ctx, "logType", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:logType: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(p.LogType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.logType (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:logType: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilterByOperator() {
    if err := oprot.WriteFieldBegin(ctx, "filterByOperator", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:filterByOperator: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(p.FilterByOperator)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.filterByOperator (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:filterByOperator: ", p), err) }
  }
  return err
}

func (p *TLogQueryFilter) Equals(other *TLogQueryFilter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.RegionName != other.RegionName {
    if p.RegionName == nil || other.RegionName == nil {
      return false
    }
    if (*p.RegionName) != (*other.RegionName) { return false }
  }
  if p.ClientAddress != other.ClientAddress {
    if p.ClientAddress == nil || other.ClientAddress == nil {
      return false
    }
    if (*p.ClientAddress) != (*other.ClientAddress) { return false }
  }
  if p.TableName != other.TableName {
    if p.TableName == nil || other.TableName == nil {
      return false
    }
    if (*p.TableName) != (*other.TableName) { return false }
  }
  if p.UserName != other.UserName {
    if p.UserName == nil || other.UserName == nil {
      return false
    }
    if (*p.UserName) != (*other.UserName) { return false }
  }
  if p.Limit != other.Limit { return false }
  if p.LogType != other.LogType { return false }
  if p.FilterByOperator != other.FilterByOperator { return false }
  return true
}

func (p *TLogQueryFilter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TLogQueryFilter(%+v)", *p)
}

// Thrift wrapper around
// org.apache.hadoop.hbase.client.OnlineLogRecordrd
// 
// Attributes:
//  - StartTime
//  - ProcessingTime
//  - QueueTime
//  - ResponseSize
//  - ClientAddress
//  - ServerClass
//  - MethodName
//  - CallDetails
//  - Param
//  - UserName
//  - MultiGetsCount
//  - MultiMutationsCount
//  - MultiServiceCalls
//  - RegionName
type TOnlineLogRecord struct {
  StartTime int64 `thrift:"startTime,1,required" db:"startTime" json:"startTime"`
  ProcessingTime int32 `thrift:"processingTime,2,required" db:"processingTime" json:"processingTime"`
  QueueTime int32 `thrift:"queueTime,3,required" db:"queueTime" json:"queueTime"`
  ResponseSize int64 `thrift:"responseSize,4,required" db:"responseSize" json:"responseSize"`
  ClientAddress string `thrift:"clientAddress,5,required" db:"clientAddress" json:"clientAddress"`
  ServerClass string `thrift:"serverClass,6,required" db:"serverClass" json:"serverClass"`
  MethodName string `thrift:"methodName,7,required" db:"methodName" json:"methodName"`
  CallDetails string `thrift:"callDetails,8,required" db:"callDetails" json:"callDetails"`
  Param string `thrift:"param,9,required" db:"param" json:"param"`
  UserName string `thrift:"userName,10,required" db:"userName" json:"userName"`
  MultiGetsCount int32 `thrift:"multiGetsCount,11,required" db:"multiGetsCount" json:"multiGetsCount"`
  MultiMutationsCount int32 `thrift:"multiMutationsCount,12,required" db:"multiMutationsCount" json:"multiMutationsCount"`
  MultiServiceCalls int32 `thrift:"multiServiceCalls,13,required" db:"multiServiceCalls" json:"multiServiceCalls"`
  RegionName *string `thrift:"regionName,14" db:"regionName" json:"regionName,omitempty"`
}

func NewTOnlineLogRecord() *TOnlineLogRecord {
  return &TOnlineLogRecord{}
}


func (p *TOnlineLogRecord) GetStartTime() int64 {
  return p.StartTime
}

func (p *TOnlineLogRecord) GetProcessingTime() int32 {
  return p.ProcessingTime
}

func (p *TOnlineLogRecord) GetQueueTime() int32 {
  return p.QueueTime
}

func (p *TOnlineLogRecord) GetResponseSize() int64 {
  return p.ResponseSize
}

func (p *TOnlineLogRecord) GetClientAddress() string {
  return p.ClientAddress
}

func (p *TOnlineLogRecord) GetServerClass() string {
  return p.ServerClass
}

func (p *TOnlineLogRecord) GetMethodName() string {
  return p.MethodName
}

func (p *TOnlineLogRecord) GetCallDetails() string {
  return p.CallDetails
}

func (p *TOnlineLogRecord) GetParam() string {
  return p.Param
}

func (p *TOnlineLogRecord) GetUserName() string {
  return p.UserName
}

func (p *TOnlineLogRecord) GetMultiGetsCount() int32 {
  return p.MultiGetsCount
}

func (p *TOnlineLogRecord) GetMultiMutationsCount() int32 {
  return p.MultiMutationsCount
}

func (p *TOnlineLogRecord) GetMultiServiceCalls() int32 {
  return p.MultiServiceCalls
}
var TOnlineLogRecord_RegionName_DEFAULT string
func (p *TOnlineLogRecord) GetRegionName() string {
  if !p.IsSetRegionName() {
    return TOnlineLogRecord_RegionName_DEFAULT
  }
return *p.RegionName
}
func (p *TOnlineLogRecord) IsSetRegionName() bool {
  return p.RegionName != nil
}

func (p *TOnlineLogRecord) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartTime bool = false;
  var issetProcessingTime bool = false;
  var issetQueueTime bool = false;
  var issetResponseSize bool = false;
  var issetClientAddress bool = false;
  var issetServerClass bool = false;
  var issetMethodName bool = false;
  var issetCallDetails bool = false;
  var issetParam bool = false;
  var issetUserName bool = false;
  var issetMultiGetsCount bool = false;
  var issetMultiMutationsCount bool = false;
  var issetMultiServiceCalls bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStartTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetProcessingTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetQueueTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetResponseSize = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
        issetClientAddress = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
        issetServerClass = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
        issetMethodName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
        issetCallDetails = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
        issetParam = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
        issetUserName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
        issetMultiGetsCount = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
        issetMultiMutationsCount = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
        issetMultiServiceCalls = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartTime is not set"));
  }
  if !issetProcessingTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ProcessingTime is not set"));
  }
  if !issetQueueTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field QueueTime is not set"));
  }
  if !issetResponseSize{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ResponseSize is not set"));
  }
  if !issetClientAddress{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ClientAddress is not set"));
  }
  if !issetServerClass{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ServerClass is not set"));
  }
  if !issetMethodName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MethodName is not set"));
  }
  if !issetCallDetails{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CallDetails is not set"));
  }
  if !issetParam{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Param is not set"));
  }
  if !issetUserName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UserName is not set"));
  }
  if !issetMultiGetsCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MultiGetsCount is not set"));
  }
  if !issetMultiMutationsCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MultiMutationsCount is not set"));
  }
  if !issetMultiServiceCalls{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MultiServiceCalls is not set"));
  }
  return nil
}

func (p *TOnlineLogRecord)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartTime = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ProcessingTime = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.QueueTime = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ResponseSize = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.ClientAddress = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.ServerClass = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.MethodName = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.CallDetails = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.Param = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.UserName = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.MultiGetsCount = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.MultiMutationsCount = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.MultiServiceCalls = v
}
  return nil
}

func (p *TOnlineLogRecord)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.RegionName = &v
}
  return nil
}

func (p *TOnlineLogRecord) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TOnlineLogRecord"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TOnlineLogRecord) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "startTime", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startTime: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.StartTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.startTime (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startTime: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "processingTime", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:processingTime: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ProcessingTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.processingTime (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:processingTime: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "queueTime", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:queueTime: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.QueueTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.queueTime (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:queueTime: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "responseSize", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:responseSize: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.ResponseSize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.responseSize (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:responseSize: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clientAddress", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:clientAddress: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClientAddress)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clientAddress (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:clientAddress: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serverClass", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:serverClass: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ServerClass)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serverClass (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:serverClass: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "methodName", thrift.STRING, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:methodName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MethodName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.methodName (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:methodName: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "callDetails", thrift.STRING, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:callDetails: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CallDetails)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.callDetails (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:callDetails: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "param", thrift.STRING, 9); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:param: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Param)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.param (9) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 9:param: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "userName", thrift.STRING, 10); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:userName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.UserName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.userName (10) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 10:userName: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "multiGetsCount", thrift.I32, 11); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:multiGetsCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MultiGetsCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.multiGetsCount (11) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 11:multiGetsCount: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "multiMutationsCount", thrift.I32, 12); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:multiMutationsCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MultiMutationsCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.multiMutationsCount (12) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 12:multiMutationsCount: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "multiServiceCalls", thrift.I32, 13); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:multiServiceCalls: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MultiServiceCalls)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.multiServiceCalls (13) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 13:multiServiceCalls: ", p), err) }
  return err
}

func (p *TOnlineLogRecord) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRegionName() {
    if err := oprot.WriteFieldBegin(ctx, "regionName", thrift.STRING, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:regionName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.RegionName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.regionName (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:regionName: ", p), err) }
  }
  return err
}

func (p *TOnlineLogRecord) Equals(other *TOnlineLogRecord) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.StartTime != other.StartTime { return false }
  if p.ProcessingTime != other.ProcessingTime { return false }
  if p.QueueTime != other.QueueTime { return false }
  if p.ResponseSize != other.ResponseSize { return false }
  if p.ClientAddress != other.ClientAddress { return false }
  if p.ServerClass != other.ServerClass { return false }
  if p.MethodName != other.MethodName { return false }
  if p.CallDetails != other.CallDetails { return false }
  if p.Param != other.Param { return false }
  if p.UserName != other.UserName { return false }
  if p.MultiGetsCount != other.MultiGetsCount { return false }
  if p.MultiMutationsCount != other.MultiMutationsCount { return false }
  if p.MultiServiceCalls != other.MultiServiceCalls { return false }
  if p.RegionName != other.RegionName {
    if p.RegionName == nil || other.RegionName == nil {
      return false
    }
    if (*p.RegionName) != (*other.RegionName) { return false }
  }
  return true
}

func (p *TOnlineLogRecord) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TOnlineLogRecord(%+v)", *p)
}

// A TIOError exception signals that an error occurred communicating
// to the HBase master or a HBase region server. Also used to return
// more general HBase error conditions.
// 
// Attributes:
//  - Message
//  - CanRetry
type TIOError struct {
  Message *string `thrift:"message,1" db:"message" json:"message,omitempty"`
  CanRetry *bool `thrift:"canRetry,2" db:"canRetry" json:"canRetry,omitempty"`
}

func NewTIOError() *TIOError {
  return &TIOError{}
}

var TIOError_Message_DEFAULT string
func (p *TIOError) GetMessage() string {
  if !p.IsSetMessage() {
    return TIOError_Message_DEFAULT
  }
return *p.Message
}
var TIOError_CanRetry_DEFAULT bool
func (p *TIOError) GetCanRetry() bool {
  if !p.IsSetCanRetry() {
    return TIOError_CanRetry_DEFAULT
  }
return *p.CanRetry
}
func (p *TIOError) IsSetMessage() bool {
  return p.Message != nil
}

func (p *TIOError) IsSetCanRetry() bool {
  return p.CanRetry != nil
}

func (p *TIOError) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TIOError)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *TIOError)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.CanRetry = &v
}
  return nil
}

func (p *TIOError) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TIOError"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TIOError) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  }
  return err
}

func (p *TIOError) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCanRetry() {
    if err := oprot.WriteFieldBegin(ctx, "canRetry", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:canRetry: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.CanRetry)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.canRetry (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:canRetry: ", p), err) }
  }
  return err
}

func (p *TIOError) Equals(other *TIOError) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  if p.CanRetry != other.CanRetry {
    if p.CanRetry == nil || other.CanRetry == nil {
      return false
    }
    if (*p.CanRetry) != (*other.CanRetry) { return false }
  }
  return true
}

func (p *TIOError) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TIOError(%+v)", *p)
}

func (p *TIOError) Error() string {
  return p.String()
}

func (TIOError) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TIOError)(nil)

// A TIllegalArgument exception indicates an illegal or invalid
// argument was passed into a procedure.
// 
// Attributes:
//  - Message
type TIllegalArgument struct {
  Message *string `thrift:"message,1" db:"message" json:"message,omitempty"`
}

func NewTIllegalArgument() *TIllegalArgument {
  return &TIllegalArgument{}
}

var TIllegalArgument_Message_DEFAULT string
func (p *TIllegalArgument) GetMessage() string {
  if !p.IsSetMessage() {
    return TIllegalArgument_Message_DEFAULT
  }
return *p.Message
}
func (p *TIllegalArgument) IsSetMessage() bool {
  return p.Message != nil
}

func (p *TIllegalArgument) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TIllegalArgument)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *TIllegalArgument) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TIllegalArgument"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TIllegalArgument) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  }
  return err
}

func (p *TIllegalArgument) Equals(other *TIllegalArgument) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  return true
}

func (p *TIllegalArgument) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TIllegalArgument(%+v)", *p)
}

func (p *TIllegalArgument) Error() string {
  return p.String()
}

func (TIllegalArgument) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*TIllegalArgument)(nil)

type THBaseService interface {
  // Test for the existence of columns in the table, as specified in the TGet.
  // 
  // @return true if the specified TGet matches one or more keys, false if not
  // 
  // Parameters:
  //  - Table: the table to check on
  //  - Tget: the TGet to check for
  Exists(ctx context.Context, table []byte, tget *TGet) (_r bool, _err error)
  // Test for the existence of columns in the table, as specified by the TGets.
  // 
  // This will return an array of booleans. Each value will be true if the related Get matches
  // one or more keys, false if not.
  // 
  // Parameters:
  //  - Table: the table to check on
  //  - Tgets: a list of TGets to check for
  ExistsAll(ctx context.Context, table []byte, tgets []*TGet) (_r []bool, _err error)
  // Method for getting data from a row.
  // 
  // If the row cannot be found an empty Result is returned.
  // This can be checked by the empty field of the TResult
  // 
  // @return the result
  // 
  // Parameters:
  //  - Table: the table to get from
  //  - Tget: the TGet to fetch
  Get(ctx context.Context, table []byte, tget *TGet) (_r *TResult_, _err error)
  // Method for getting multiple rows.
  // 
  // If a row cannot be found there will be a null
  // value in the result list for that TGet at the
  // same position.
  // 
  // So the Results are in the same order as the TGets.
  // 
  // Parameters:
  //  - Table: the table to get from
  //  - Tgets: a list of TGets to fetch, the Result list
  // will have the Results at corresponding positions
  // or null if there was an error
  GetMultiple(ctx context.Context, table []byte, tgets []*TGet) (_r []*TResult_, _err error)
  // Commit a TPut to a table.
  // 
  // Parameters:
  //  - Table: the table to put data in
  //  - Tput: the TPut to put
  Put(ctx context.Context, table []byte, tput *TPut) (_err error)
  // Atomically checks if a row/family/qualifier value matches the expected
  // value. If it does, it adds the TPut.
  // 
  // @return true if the new put was executed, false otherwise
  // 
  // Parameters:
  //  - Table: to check in and put to
  //  - Row: row to check
  //  - Family: column family to check
  //  - Qualifier: column qualifier to check
  //  - Value: the expected value, if not provided the
  // check is for the non-existence of the
  // column in question
  //  - Tput: the TPut to put if the check succeeds
  CheckAndPut(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (_r bool, _err error)
  // Commit a List of Puts to the table.
  // 
  // Parameters:
  //  - Table: the table to put data in
  //  - Tputs: a list of TPuts to commit
  PutMultiple(ctx context.Context, table []byte, tputs []*TPut) (_err error)
  // Deletes as specified by the TDelete.
  // 
  // Note: "delete" is a reserved keyword and cannot be used in Thrift
  // thus the inconsistent naming scheme from the other functions.
  // 
  // Parameters:
  //  - Table: the table to delete from
  //  - Tdelete: the TDelete to delete
  DeleteSingle(ctx context.Context, table []byte, tdelete *TDelete) (_err error)
  // Bulk commit a List of TDeletes to the table.
  // 
  // Throws a TIOError if any of the deletes fail.
  // 
  // Always returns an empty list for backwards compatibility.
  // 
  // Parameters:
  //  - Table: the table to delete from
  //  - Tdeletes: list of TDeletes to delete
  DeleteMultiple(ctx context.Context, table []byte, tdeletes []*TDelete) (_r []*TDelete, _err error)
  // Atomically checks if a row/family/qualifier value matches the expected
  // value. If it does, it adds the delete.
  // 
  // @return true if the new delete was executed, false otherwise
  // 
  // Parameters:
  //  - Table: to check in and delete from
  //  - Row: row to check
  //  - Family: column family to check
  //  - Qualifier: column qualifier to check
  //  - Value: the expected value, if not provided the
  // check is for the non-existence of the
  // column in question
  //  - Tdelete: the TDelete to execute if the check succeeds
  CheckAndDelete(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (_r bool, _err error)
  // Parameters:
  //  - Table: the table to increment the value on
  //  - Tincrement: the TIncrement to increment
  Increment(ctx context.Context, table []byte, tincrement *TIncrement) (_r *TResult_, _err error)
  // Parameters:
  //  - Table: the table to append the value on
  //  - Tappend: the TAppend to append
  Append(ctx context.Context, table []byte, tappend *TAppend) (_r *TResult_, _err error)
  // Get a Scanner for the provided TScan object.
  // 
  // @return Scanner Id to be used with other scanner procedures
  // 
  // Parameters:
  //  - Table: the table to get the Scanner for
  //  - Tscan: the scan object to get a Scanner for
  OpenScanner(ctx context.Context, table []byte, tscan *TScan) (_r int32, _err error)
  // Grabs multiple rows from a Scanner.
  // 
  // @return Between zero and numRows TResults
  // 
  // Parameters:
  //  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
  //  - NumRows: number of rows to return
  GetScannerRows(ctx context.Context, scannerId int32, numRows int32) (_r []*TResult_, _err error)
  // Closes the scanner. Should be called to free server side resources timely.
  // Typically close once the scanner is not needed anymore, i.e. after looping
  // over it to get all the required rows.
  // 
  // Parameters:
  //  - ScannerId: the Id of the Scanner to close *
  CloseScanner(ctx context.Context, scannerId int32) (_err error)
  // mutateRow performs multiple mutations atomically on a single row.
  // 
  // Parameters:
  //  - Table: table to apply the mutations
  //  - TrowMutations: mutations to apply
  MutateRow(ctx context.Context, table []byte, trowMutations *TRowMutations) (_err error)
  // Get results for the provided TScan object.
  // This helper function opens a scanner, get the results and close the scanner.
  // 
  // @return between zero and numRows TResults
  // 
  // Parameters:
  //  - Table: the table to get the Scanner for
  //  - Tscan: the scan object to get a Scanner for
  //  - NumRows: number of rows to return
  GetScannerResults(ctx context.Context, table []byte, tscan *TScan, numRows int32) (_r []*TResult_, _err error)
  // Given a table and a row get the location of the region that
  // would contain the given row key.
  // 
  // reload = true means the cache will be cleared and the location
  // will be fetched from meta.
  // 
  // Parameters:
  //  - Table
  //  - Row
  //  - Reload
  GetRegionLocation(ctx context.Context, table []byte, row []byte, reload bool) (_r *THRegionLocation, _err error)
  // Get all of the region locations for a given table.
  // 
  // 
  // Parameters:
  //  - Table
  GetAllRegionLocations(ctx context.Context, table []byte) (_r []*THRegionLocation, _err error)
  // Atomically checks if a row/family/qualifier value matches the expected
  // value. If it does, it mutates the row.
  // 
  // @return true if the row was mutated, false otherwise
  // 
  // Parameters:
  //  - Table: to check in and delete from
  //  - Row: row to check
  //  - Family: column family to check
  //  - Qualifier: column qualifier to check
  //  - CompareOp: comparison to make on the value
  //  - Value: the expected value to be compared against, if not provided the
  // check is for the non-existence of the column in question
  //  - RowMutations: row mutations to execute if the value matches
  CheckAndMutate(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (_r bool, _err error)
  // Get a table descriptor.
  // @return the TableDescriptor of the giving tablename
  // 
  // 
  // Parameters:
  //  - Table: the tablename of the table to get tableDescriptor
  GetTableDescriptor(ctx context.Context, table *TTableName) (_r *TTableDescriptor, _err error)
  // Get table descriptors of tables.
  // @return the TableDescriptor of the giving tablename
  // 
  // 
  // Parameters:
  //  - Tables: the tablename list of the tables to get tableDescriptor
  GetTableDescriptors(ctx context.Context, tables []*TTableName) (_r []*TTableDescriptor, _err error)
  // 
  // @return true if table exists already, false if not
  // 
  // 
  // Parameters:
  //  - TableName: the tablename of the tables to check
  TableExists(ctx context.Context, tableName *TTableName) (_r bool, _err error)
  // Get table descriptors of tables that match the given pattern
  // @return the tableDescriptors of the matching table
  // 
  // 
  // Parameters:
  //  - Regex: The regular expression to match against
  //  - IncludeSysTables: set to false if match only against userspace tables
  GetTableDescriptorsByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableDescriptor, _err error)
  // Get table descriptors of tables in the given namespace
  // @return the tableDescriptors in the namespce
  // 
  // 
  // Parameters:
  //  - Name: The namesapce's name
  GetTableDescriptorsByNamespace(ctx context.Context, name string) (_r []*TTableDescriptor, _err error)
  // Get table names of tables that match the given pattern
  // @return the table names of the matching table
  // 
  // 
  // Parameters:
  //  - Regex: The regular expression to match against
  //  - IncludeSysTables: set to false if match only against userspace tables
  GetTableNamesByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableName, _err error)
  // Get table names of tables in the given namespace
  // @return the table names of the matching table
  // 
  // 
  // Parameters:
  //  - Name: The namesapce's name
  GetTableNamesByNamespace(ctx context.Context, name string) (_r []*TTableName, _err error)
  // Creates a new table with an initial set of empty regions defined by the specified split keys.
  // The total number of regions created will be the number of split keys plus one. Synchronous
  // operation.
  // 
  // 
  // Parameters:
  //  - Desc: table descriptor for table
  //  - SplitKeys: rray of split keys for the initial regions of the table
  CreateTable(ctx context.Context, desc *TTableDescriptor, splitKeys [][]byte) (_err error)
  // Deletes a table. Synchronous operation.
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to delete
  DeleteTable(ctx context.Context, tableName *TTableName) (_err error)
  // Truncate a table. Synchronous operation.
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to truncate
  //  - PreserveSplits: whether to  preserve previous splits
  TruncateTable(ctx context.Context, tableName *TTableName, preserveSplits bool) (_err error)
  // Enalbe a table
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to enable
  EnableTable(ctx context.Context, tableName *TTableName) (_err error)
  // Disable a table
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to disable
  DisableTable(ctx context.Context, tableName *TTableName) (_err error)
  // 
  // @return true if table is enabled, false if not
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to check
  IsTableEnabled(ctx context.Context, tableName *TTableName) (_r bool, _err error)
  // 
  // @return true if table is disabled, false if not
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to check
  IsTableDisabled(ctx context.Context, tableName *TTableName) (_r bool, _err error)
  // 
  // @return true if table is available, false if not
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to check
  IsTableAvailable(ctx context.Context, tableName *TTableName) (_r bool, _err error)
  //  * Use this api to check if the table has been created with the specified number of splitkeys
  //  * which was used while creating the given table. Note : If this api is used after a table's
  //  * region gets splitted, the api may return false.
  //  *
  //  * @return true if table is available, false if not
  //  *
  //  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
  //  * since 2.0.0, we will remove it in 3.0.0 release.
  //  * Use {@link #isTableAvailable(TTableName tableName)} instead
  // *
  // 
  // Parameters:
  //  - TableName: the tablename to check
  //  - SplitKeys: keys to check if the table has been created with all split keys
  IsTableAvailableWithSplit(ctx context.Context, tableName *TTableName, splitKeys [][]byte) (_r bool, _err error)
  // Add a column family to an existing table. Synchronous operation.
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to add column family to
  //  - Column: column family descriptor of column family to be added
  AddColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error)
  // Delete a column family from a table. Synchronous operation.
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to delete column family from
  //  - Column: name of column family to be deleted
  DeleteColumnFamily(ctx context.Context, tableName *TTableName, column []byte) (_err error)
  // Modify an existing column family on a table. Synchronous operation.
  // 
  // 
  // Parameters:
  //  - TableName: the tablename to modify column family
  //  - Column: column family descriptor of column family to be modified
  ModifyColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error)
  // Modify an existing table
  // 
  // 
  // Parameters:
  //  - Desc: the descriptor of the table to modify
  ModifyTable(ctx context.Context, desc *TTableDescriptor) (_err error)
  // Create a new namespace. Blocks until namespace has been successfully created or an exception is
  // thrown
  // 
  // 
  // Parameters:
  //  - NamespaceDesc: descriptor which describes the new namespace
  CreateNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error)
  // Modify an existing namespace.  Blocks until namespace has been successfully modified or an
  // exception is thrown
  // 
  // 
  // Parameters:
  //  - NamespaceDesc: descriptor which describes the new namespace
  ModifyNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error)
  // Delete an existing namespace. Only empty namespaces (no tables) can be removed.
  // Blocks until namespace has been successfully deleted or an
  // exception is thrown.
  // 
  // 
  // Parameters:
  //  - Name: namespace name
  DeleteNamespace(ctx context.Context, name string) (_err error)
  // Get a namespace descriptor by name.
  // @retrun the descriptor
  // 
  // 
  // Parameters:
  //  - Name: name of namespace descriptor
  GetNamespaceDescriptor(ctx context.Context, name string) (_r *TNamespaceDescriptor, _err error)
  // @return all namespaces
  // 
  ListNamespaceDescriptors(ctx context.Context) (_r []*TNamespaceDescriptor, _err error)
  // @return all namespace names
  // 
  ListNamespaces(ctx context.Context) (_r []string, _err error)
  // Get the type of this thrift server.
  // 
  // @return the type of this thrift server
  GetThriftServerType(ctx context.Context) (_r TThriftServerType, _err error)
  // Retrieves online slow RPC logs from the provided list of
  // RegionServers
  // 
  // @return online slowlog response list
  // @throws TIOError if a remote or network exception occurs
  // 
  // Parameters:
  //  - ServerNames: @param serverNames Server names to get slowlog responses from
  //  - LogQueryFilter: @param logQueryFilter filter to be used if provided
  GetSlowLogResponses(ctx context.Context, serverNames []*TServerName, logQueryFilter *TLogQueryFilter) (_r []*TOnlineLogRecord, _err error)
  // Clears online slow/large RPC logs from the provided list of
  // RegionServers
  // 
  // @return List of booleans representing if online slowlog response buffer is cleaned
  //   from each RegionServer
  // @throws TIOError if a remote or network exception occurs
  // 
  // Parameters:
  //  - ServerNames: @param serverNames Set of Server names to clean slowlog responses from
  ClearSlowLogResponses(ctx context.Context, serverNames []*TServerName) (_r []bool, _err error)
  // Returns the cluster ID for this cluster.
  GetClusterId(ctx context.Context) (_r string, _err error)
}

type THBaseServiceClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
  return &THBaseServiceClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
  return &THBaseServiceClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewTHBaseServiceClient(c thrift.TClient) *THBaseServiceClient {
  return &THBaseServiceClient{
    c: c,
  }
}

func (p *THBaseServiceClient) Client_() thrift.TClient {
  return p.c
}

func (p *THBaseServiceClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *THBaseServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Test for the existence of columns in the table, as specified in the TGet.
// 
// @return true if the specified TGet matches one or more keys, false if not
// 
// Parameters:
//  - Table: the table to check on
//  - Tget: the TGet to check for
func (p *THBaseServiceClient) Exists(ctx context.Context, table []byte, tget *TGet) (_r bool, _err error) {
  var _args53 THBaseServiceExistsArgs
  _args53.Table = table
  _args53.Tget = tget
  var _result55 THBaseServiceExistsResult
  var _meta54 thrift.ResponseMeta
  _meta54, _err = p.Client_().Call(ctx, "exists", &_args53, &_result55)
  p.SetLastResponseMeta_(_meta54)
  if _err != nil {
    return
  }
  switch {
  case _result55.Io!= nil:
    return _r, _result55.Io
  }

  return _result55.GetSuccess(), nil
}

// Test for the existence of columns in the table, as specified by the TGets.
// 
// This will return an array of booleans. Each value will be true if the related Get matches
// one or more keys, false if not.
// 
// Parameters:
//  - Table: the table to check on
//  - Tgets: a list of TGets to check for
func (p *THBaseServiceClient) ExistsAll(ctx context.Context, table []byte, tgets []*TGet) (_r []bool, _err error) {
  var _args56 THBaseServiceExistsAllArgs
  _args56.Table = table
  _args56.Tgets = tgets
  var _result58 THBaseServiceExistsAllResult
  var _meta57 thrift.ResponseMeta
  _meta57, _err = p.Client_().Call(ctx, "existsAll", &_args56, &_result58)
  p.SetLastResponseMeta_(_meta57)
  if _err != nil {
    return
  }
  switch {
  case _result58.Io!= nil:
    return _r, _result58.Io
  }

  return _result58.GetSuccess(), nil
}

// Method for getting data from a row.
// 
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
// 
// @return the result
// 
// Parameters:
//  - Table: the table to get from
//  - Tget: the TGet to fetch
func (p *THBaseServiceClient) Get(ctx context.Context, table []byte, tget *TGet) (_r *TResult_, _err error) {
  var _args59 THBaseServiceGetArgs
  _args59.Table = table
  _args59.Tget = tget
  var _result61 THBaseServiceGetResult
  var _meta60 thrift.ResponseMeta
  _meta60, _err = p.Client_().Call(ctx, "get", &_args59, &_result61)
  p.SetLastResponseMeta_(_meta60)
  if _err != nil {
    return
  }
  switch {
  case _result61.Io!= nil:
    return _r, _result61.Io
  }

  if _ret62 := _result61.GetSuccess(); _ret62 != nil {
    return _ret62, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "get failed: unknown result")
}

// Method for getting multiple rows.
// 
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
// 
// So the Results are in the same order as the TGets.
// 
// Parameters:
//  - Table: the table to get from
//  - Tgets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
func (p *THBaseServiceClient) GetMultiple(ctx context.Context, table []byte, tgets []*TGet) (_r []*TResult_, _err error) {
  var _args63 THBaseServiceGetMultipleArgs
  _args63.Table = table
  _args63.Tgets = tgets
  var _result65 THBaseServiceGetMultipleResult
  var _meta64 thrift.ResponseMeta
  _meta64, _err = p.Client_().Call(ctx, "getMultiple", &_args63, &_result65)
  p.SetLastResponseMeta_(_meta64)
  if _err != nil {
    return
  }
  switch {
  case _result65.Io!= nil:
    return _r, _result65.Io
  }

  return _result65.GetSuccess(), nil
}

// Commit a TPut to a table.
// 
// Parameters:
//  - Table: the table to put data in
//  - Tput: the TPut to put
func (p *THBaseServiceClient) Put(ctx context.Context, table []byte, tput *TPut) (_err error) {
  var _args66 THBaseServicePutArgs
  _args66.Table = table
  _args66.Tput = tput
  var _result68 THBaseServicePutResult
  var _meta67 thrift.ResponseMeta
  _meta67, _err = p.Client_().Call(ctx, "put", &_args66, &_result68)
  p.SetLastResponseMeta_(_meta67)
  if _err != nil {
    return
  }
  switch {
  case _result68.Io!= nil:
    return _result68.Io
  }

  return nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
// 
// @return true if the new put was executed, false otherwise
// 
// Parameters:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tput: the TPut to put if the check succeeds
func (p *THBaseServiceClient) CheckAndPut(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (_r bool, _err error) {
  var _args69 THBaseServiceCheckAndPutArgs
  _args69.Table = table
  _args69.Row = row
  _args69.Family = family
  _args69.Qualifier = qualifier
  _args69.Value = value
  _args69.Tput = tput
  var _result71 THBaseServiceCheckAndPutResult
  var _meta70 thrift.ResponseMeta
  _meta70, _err = p.Client_().Call(ctx, "checkAndPut", &_args69, &_result71)
  p.SetLastResponseMeta_(_meta70)
  if _err != nil {
    return
  }
  switch {
  case _result71.Io!= nil:
    return _r, _result71.Io
  }

  return _result71.GetSuccess(), nil
}

// Commit a List of Puts to the table.
// 
// Parameters:
//  - Table: the table to put data in
//  - Tputs: a list of TPuts to commit
func (p *THBaseServiceClient) PutMultiple(ctx context.Context, table []byte, tputs []*TPut) (_err error) {
  var _args72 THBaseServicePutMultipleArgs
  _args72.Table = table
  _args72.Tputs = tputs
  var _result74 THBaseServicePutMultipleResult
  var _meta73 thrift.ResponseMeta
  _meta73, _err = p.Client_().Call(ctx, "putMultiple", &_args72, &_result74)
  p.SetLastResponseMeta_(_meta73)
  if _err != nil {
    return
  }
  switch {
  case _result74.Io!= nil:
    return _result74.Io
  }

  return nil
}

// Deletes as specified by the TDelete.
// 
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
// 
// Parameters:
//  - Table: the table to delete from
//  - Tdelete: the TDelete to delete
func (p *THBaseServiceClient) DeleteSingle(ctx context.Context, table []byte, tdelete *TDelete) (_err error) {
  var _args75 THBaseServiceDeleteSingleArgs
  _args75.Table = table
  _args75.Tdelete = tdelete
  var _result77 THBaseServiceDeleteSingleResult
  var _meta76 thrift.ResponseMeta
  _meta76, _err = p.Client_().Call(ctx, "deleteSingle", &_args75, &_result77)
  p.SetLastResponseMeta_(_meta76)
  if _err != nil {
    return
  }
  switch {
  case _result77.Io!= nil:
    return _result77.Io
  }

  return nil
}

// Bulk commit a List of TDeletes to the table.
// 
// Throws a TIOError if any of the deletes fail.
// 
// Always returns an empty list for backwards compatibility.
// 
// Parameters:
//  - Table: the table to delete from
//  - Tdeletes: list of TDeletes to delete
func (p *THBaseServiceClient) DeleteMultiple(ctx context.Context, table []byte, tdeletes []*TDelete) (_r []*TDelete, _err error) {
  var _args78 THBaseServiceDeleteMultipleArgs
  _args78.Table = table
  _args78.Tdeletes = tdeletes
  var _result80 THBaseServiceDeleteMultipleResult
  var _meta79 thrift.ResponseMeta
  _meta79, _err = p.Client_().Call(ctx, "deleteMultiple", &_args78, &_result80)
  p.SetLastResponseMeta_(_meta79)
  if _err != nil {
    return
  }
  switch {
  case _result80.Io!= nil:
    return _r, _result80.Io
  }

  return _result80.GetSuccess(), nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
// 
// @return true if the new delete was executed, false otherwise
// 
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tdelete: the TDelete to execute if the check succeeds
func (p *THBaseServiceClient) CheckAndDelete(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (_r bool, _err error) {
  var _args81 THBaseServiceCheckAndDeleteArgs
  _args81.Table = table
  _args81.Row = row
  _args81.Family = family
  _args81.Qualifier = qualifier
  _args81.Value = value
  _args81.Tdelete = tdelete
  var _result83 THBaseServiceCheckAndDeleteResult
  var _meta82 thrift.ResponseMeta
  _meta82, _err = p.Client_().Call(ctx, "checkAndDelete", &_args81, &_result83)
  p.SetLastResponseMeta_(_meta82)
  if _err != nil {
    return
  }
  switch {
  case _result83.Io!= nil:
    return _r, _result83.Io
  }

  return _result83.GetSuccess(), nil
}

// Parameters:
//  - Table: the table to increment the value on
//  - Tincrement: the TIncrement to increment
func (p *THBaseServiceClient) Increment(ctx context.Context, table []byte, tincrement *TIncrement) (_r *TResult_, _err error) {
  var _args84 THBaseServiceIncrementArgs
  _args84.Table = table
  _args84.Tincrement = tincrement
  var _result86 THBaseServiceIncrementResult
  var _meta85 thrift.ResponseMeta
  _meta85, _err = p.Client_().Call(ctx, "increment", &_args84, &_result86)
  p.SetLastResponseMeta_(_meta85)
  if _err != nil {
    return
  }
  switch {
  case _result86.Io!= nil:
    return _r, _result86.Io
  }

  if _ret87 := _result86.GetSuccess(); _ret87 != nil {
    return _ret87, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "increment failed: unknown result")
}

// Parameters:
//  - Table: the table to append the value on
//  - Tappend: the TAppend to append
func (p *THBaseServiceClient) Append(ctx context.Context, table []byte, tappend *TAppend) (_r *TResult_, _err error) {
  var _args88 THBaseServiceAppendArgs
  _args88.Table = table
  _args88.Tappend = tappend
  var _result90 THBaseServiceAppendResult
  var _meta89 thrift.ResponseMeta
  _meta89, _err = p.Client_().Call(ctx, "append", &_args88, &_result90)
  p.SetLastResponseMeta_(_meta89)
  if _err != nil {
    return
  }
  switch {
  case _result90.Io!= nil:
    return _r, _result90.Io
  }

  if _ret91 := _result90.GetSuccess(); _ret91 != nil {
    return _ret91, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "append failed: unknown result")
}

// Get a Scanner for the provided TScan object.
// 
// @return Scanner Id to be used with other scanner procedures
// 
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
func (p *THBaseServiceClient) OpenScanner(ctx context.Context, table []byte, tscan *TScan) (_r int32, _err error) {
  var _args92 THBaseServiceOpenScannerArgs
  _args92.Table = table
  _args92.Tscan = tscan
  var _result94 THBaseServiceOpenScannerResult
  var _meta93 thrift.ResponseMeta
  _meta93, _err = p.Client_().Call(ctx, "openScanner", &_args92, &_result94)
  p.SetLastResponseMeta_(_meta93)
  if _err != nil {
    return
  }
  switch {
  case _result94.Io!= nil:
    return _r, _result94.Io
  }

  return _result94.GetSuccess(), nil
}

// Grabs multiple rows from a Scanner.
// 
// @return Between zero and numRows TResults
// 
// Parameters:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerRows(ctx context.Context, scannerId int32, numRows int32) (_r []*TResult_, _err error) {
  var _args95 THBaseServiceGetScannerRowsArgs
  _args95.ScannerId = scannerId
  _args95.NumRows = numRows
  var _result97 THBaseServiceGetScannerRowsResult
  var _meta96 thrift.ResponseMeta
  _meta96, _err = p.Client_().Call(ctx, "getScannerRows", &_args95, &_result97)
  p.SetLastResponseMeta_(_meta96)
  if _err != nil {
    return
  }
  switch {
  case _result97.Io!= nil:
    return _r, _result97.Io
  case _result97.Ia!= nil:
    return _r, _result97.Ia
  }

  return _result97.GetSuccess(), nil
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
// 
// Parameters:
//  - ScannerId: the Id of the Scanner to close *
func (p *THBaseServiceClient) CloseScanner(ctx context.Context, scannerId int32) (_err error) {
  var _args98 THBaseServiceCloseScannerArgs
  _args98.ScannerId = scannerId
  var _result100 THBaseServiceCloseScannerResult
  var _meta99 thrift.ResponseMeta
  _meta99, _err = p.Client_().Call(ctx, "closeScanner", &_args98, &_result100)
  p.SetLastResponseMeta_(_meta99)
  if _err != nil {
    return
  }
  switch {
  case _result100.Io!= nil:
    return _result100.Io
  case _result100.Ia!= nil:
    return _result100.Ia
  }

  return nil
}

// mutateRow performs multiple mutations atomically on a single row.
// 
// Parameters:
//  - Table: table to apply the mutations
//  - TrowMutations: mutations to apply
func (p *THBaseServiceClient) MutateRow(ctx context.Context, table []byte, trowMutations *TRowMutations) (_err error) {
  var _args101 THBaseServiceMutateRowArgs
  _args101.Table = table
  _args101.TrowMutations = trowMutations
  var _result103 THBaseServiceMutateRowResult
  var _meta102 thrift.ResponseMeta
  _meta102, _err = p.Client_().Call(ctx, "mutateRow", &_args101, &_result103)
  p.SetLastResponseMeta_(_meta102)
  if _err != nil {
    return
  }
  switch {
  case _result103.Io!= nil:
    return _result103.Io
  }

  return nil
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
// 
// @return between zero and numRows TResults
// 
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerResults(ctx context.Context, table []byte, tscan *TScan, numRows int32) (_r []*TResult_, _err error) {
  var _args104 THBaseServiceGetScannerResultsArgs
  _args104.Table = table
  _args104.Tscan = tscan
  _args104.NumRows = numRows
  var _result106 THBaseServiceGetScannerResultsResult
  var _meta105 thrift.ResponseMeta
  _meta105, _err = p.Client_().Call(ctx, "getScannerResults", &_args104, &_result106)
  p.SetLastResponseMeta_(_meta105)
  if _err != nil {
    return
  }
  switch {
  case _result106.Io!= nil:
    return _r, _result106.Io
  }

  return _result106.GetSuccess(), nil
}

// Given a table and a row get the location of the region that
// would contain the given row key.
// 
// reload = true means the cache will be cleared and the location
// will be fetched from meta.
// 
// Parameters:
//  - Table
//  - Row
//  - Reload
func (p *THBaseServiceClient) GetRegionLocation(ctx context.Context, table []byte, row []byte, reload bool) (_r *THRegionLocation, _err error) {
  var _args107 THBaseServiceGetRegionLocationArgs
  _args107.Table = table
  _args107.Row = row
  _args107.Reload = reload
  var _result109 THBaseServiceGetRegionLocationResult
  var _meta108 thrift.ResponseMeta
  _meta108, _err = p.Client_().Call(ctx, "getRegionLocation", &_args107, &_result109)
  p.SetLastResponseMeta_(_meta108)
  if _err != nil {
    return
  }
  switch {
  case _result109.Io!= nil:
    return _r, _result109.Io
  }

  if _ret110 := _result109.GetSuccess(); _ret110 != nil {
    return _ret110, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getRegionLocation failed: unknown result")
}

// Get all of the region locations for a given table.
// 
// 
// Parameters:
//  - Table
func (p *THBaseServiceClient) GetAllRegionLocations(ctx context.Context, table []byte) (_r []*THRegionLocation, _err error) {
  var _args111 THBaseServiceGetAllRegionLocationsArgs
  _args111.Table = table
  var _result113 THBaseServiceGetAllRegionLocationsResult
  var _meta112 thrift.ResponseMeta
  _meta112, _err = p.Client_().Call(ctx, "getAllRegionLocations", &_args111, &_result113)
  p.SetLastResponseMeta_(_meta112)
  if _err != nil {
    return
  }
  switch {
  case _result113.Io!= nil:
    return _r, _result113.Io
  }

  return _result113.GetSuccess(), nil
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it mutates the row.
// 
// @return true if the row was mutated, false otherwise
// 
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - CompareOp: comparison to make on the value
//  - Value: the expected value to be compared against, if not provided the
// check is for the non-existence of the column in question
//  - RowMutations: row mutations to execute if the value matches
func (p *THBaseServiceClient) CheckAndMutate(ctx context.Context, table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (_r bool, _err error) {
  var _args114 THBaseServiceCheckAndMutateArgs
  _args114.Table = table
  _args114.Row = row
  _args114.Family = family
  _args114.Qualifier = qualifier
  _args114.CompareOp = compareOp
  _args114.Value = value
  _args114.RowMutations = rowMutations
  var _result116 THBaseServiceCheckAndMutateResult
  var _meta115 thrift.ResponseMeta
  _meta115, _err = p.Client_().Call(ctx, "checkAndMutate", &_args114, &_result116)
  p.SetLastResponseMeta_(_meta115)
  if _err != nil {
    return
  }
  switch {
  case _result116.Io!= nil:
    return _r, _result116.Io
  }

  return _result116.GetSuccess(), nil
}

// Get a table descriptor.
// @return the TableDescriptor of the giving tablename
// 
// 
// Parameters:
//  - Table: the tablename of the table to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptor(ctx context.Context, table *TTableName) (_r *TTableDescriptor, _err error) {
  var _args117 THBaseServiceGetTableDescriptorArgs
  _args117.Table = table
  var _result119 THBaseServiceGetTableDescriptorResult
  var _meta118 thrift.ResponseMeta
  _meta118, _err = p.Client_().Call(ctx, "getTableDescriptor", &_args117, &_result119)
  p.SetLastResponseMeta_(_meta118)
  if _err != nil {
    return
  }
  switch {
  case _result119.Io!= nil:
    return _r, _result119.Io
  }

  if _ret120 := _result119.GetSuccess(); _ret120 != nil {
    return _ret120, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getTableDescriptor failed: unknown result")
}

// Get table descriptors of tables.
// @return the TableDescriptor of the giving tablename
// 
// 
// Parameters:
//  - Tables: the tablename list of the tables to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptors(ctx context.Context, tables []*TTableName) (_r []*TTableDescriptor, _err error) {
  var _args121 THBaseServiceGetTableDescriptorsArgs
  _args121.Tables = tables
  var _result123 THBaseServiceGetTableDescriptorsResult
  var _meta122 thrift.ResponseMeta
  _meta122, _err = p.Client_().Call(ctx, "getTableDescriptors", &_args121, &_result123)
  p.SetLastResponseMeta_(_meta122)
  if _err != nil {
    return
  }
  switch {
  case _result123.Io!= nil:
    return _r, _result123.Io
  }

  return _result123.GetSuccess(), nil
}

// 
// @return true if table exists already, false if not
// 
// 
// Parameters:
//  - TableName: the tablename of the tables to check
func (p *THBaseServiceClient) TableExists(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
  var _args124 THBaseServiceTableExistsArgs
  _args124.TableName = tableName
  var _result126 THBaseServiceTableExistsResult
  var _meta125 thrift.ResponseMeta
  _meta125, _err = p.Client_().Call(ctx, "tableExists", &_args124, &_result126)
  p.SetLastResponseMeta_(_meta125)
  if _err != nil {
    return
  }
  switch {
  case _result126.Io!= nil:
    return _r, _result126.Io
  }

  return _result126.GetSuccess(), nil
}

// Get table descriptors of tables that match the given pattern
// @return the tableDescriptors of the matching table
// 
// 
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableDescriptorsByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableDescriptor, _err error) {
  var _args127 THBaseServiceGetTableDescriptorsByPatternArgs
  _args127.Regex = regex
  _args127.IncludeSysTables = includeSysTables
  var _result129 THBaseServiceGetTableDescriptorsByPatternResult
  var _meta128 thrift.ResponseMeta
  _meta128, _err = p.Client_().Call(ctx, "getTableDescriptorsByPattern", &_args127, &_result129)
  p.SetLastResponseMeta_(_meta128)
  if _err != nil {
    return
  }
  switch {
  case _result129.Io!= nil:
    return _r, _result129.Io
  }

  return _result129.GetSuccess(), nil
}

// Get table descriptors of tables in the given namespace
// @return the tableDescriptors in the namespce
// 
// 
// Parameters:
//  - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableDescriptorsByNamespace(ctx context.Context, name string) (_r []*TTableDescriptor, _err error) {
  var _args130 THBaseServiceGetTableDescriptorsByNamespaceArgs
  _args130.Name = name
  var _result132 THBaseServiceGetTableDescriptorsByNamespaceResult
  var _meta131 thrift.ResponseMeta
  _meta131, _err = p.Client_().Call(ctx, "getTableDescriptorsByNamespace", &_args130, &_result132)
  p.SetLastResponseMeta_(_meta131)
  if _err != nil {
    return
  }
  switch {
  case _result132.Io!= nil:
    return _r, _result132.Io
  }

  return _result132.GetSuccess(), nil
}

// Get table names of tables that match the given pattern
// @return the table names of the matching table
// 
// 
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableNamesByPattern(ctx context.Context, regex string, includeSysTables bool) (_r []*TTableName, _err error) {
  var _args133 THBaseServiceGetTableNamesByPatternArgs
  _args133.Regex = regex
  _args133.IncludeSysTables = includeSysTables
  var _result135 THBaseServiceGetTableNamesByPatternResult
  var _meta134 thrift.ResponseMeta
  _meta134, _err = p.Client_().Call(ctx, "getTableNamesByPattern", &_args133, &_result135)
  p.SetLastResponseMeta_(_meta134)
  if _err != nil {
    return
  }
  switch {
  case _result135.Io!= nil:
    return _r, _result135.Io
  }

  return _result135.GetSuccess(), nil
}

// Get table names of tables in the given namespace
// @return the table names of the matching table
// 
// 
// Parameters:
//  - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableNamesByNamespace(ctx context.Context, name string) (_r []*TTableName, _err error) {
  var _args136 THBaseServiceGetTableNamesByNamespaceArgs
  _args136.Name = name
  var _result138 THBaseServiceGetTableNamesByNamespaceResult
  var _meta137 thrift.ResponseMeta
  _meta137, _err = p.Client_().Call(ctx, "getTableNamesByNamespace", &_args136, &_result138)
  p.SetLastResponseMeta_(_meta137)
  if _err != nil {
    return
  }
  switch {
  case _result138.Io!= nil:
    return _r, _result138.Io
  }

  return _result138.GetSuccess(), nil
}

// Creates a new table with an initial set of empty regions defined by the specified split keys.
// The total number of regions created will be the number of split keys plus one. Synchronous
// operation.
// 
// 
// Parameters:
//  - Desc: table descriptor for table
//  - SplitKeys: rray of split keys for the initial regions of the table
func (p *THBaseServiceClient) CreateTable(ctx context.Context, desc *TTableDescriptor, splitKeys [][]byte) (_err error) {
  var _args139 THBaseServiceCreateTableArgs
  _args139.Desc = desc
  _args139.SplitKeys = splitKeys
  var _result141 THBaseServiceCreateTableResult
  var _meta140 thrift.ResponseMeta
  _meta140, _err = p.Client_().Call(ctx, "createTable", &_args139, &_result141)
  p.SetLastResponseMeta_(_meta140)
  if _err != nil {
    return
  }
  switch {
  case _result141.Io!= nil:
    return _result141.Io
  }

  return nil
}

// Deletes a table. Synchronous operation.
// 
// 
// Parameters:
//  - TableName: the tablename to delete
func (p *THBaseServiceClient) DeleteTable(ctx context.Context, tableName *TTableName) (_err error) {
  var _args142 THBaseServiceDeleteTableArgs
  _args142.TableName = tableName
  var _result144 THBaseServiceDeleteTableResult
  var _meta143 thrift.ResponseMeta
  _meta143, _err = p.Client_().Call(ctx, "deleteTable", &_args142, &_result144)
  p.SetLastResponseMeta_(_meta143)
  if _err != nil {
    return
  }
  switch {
  case _result144.Io!= nil:
    return _result144.Io
  }

  return nil
}

// Truncate a table. Synchronous operation.
// 
// 
// Parameters:
//  - TableName: the tablename to truncate
//  - PreserveSplits: whether to  preserve previous splits
func (p *THBaseServiceClient) TruncateTable(ctx context.Context, tableName *TTableName, preserveSplits bool) (_err error) {
  var _args145 THBaseServiceTruncateTableArgs
  _args145.TableName = tableName
  _args145.PreserveSplits = preserveSplits
  var _result147 THBaseServiceTruncateTableResult
  var _meta146 thrift.ResponseMeta
  _meta146, _err = p.Client_().Call(ctx, "truncateTable", &_args145, &_result147)
  p.SetLastResponseMeta_(_meta146)
  if _err != nil {
    return
  }
  switch {
  case _result147.Io!= nil:
    return _result147.Io
  }

  return nil
}

// Enalbe a table
// 
// 
// Parameters:
//  - TableName: the tablename to enable
func (p *THBaseServiceClient) EnableTable(ctx context.Context, tableName *TTableName) (_err error) {
  var _args148 THBaseServiceEnableTableArgs
  _args148.TableName = tableName
  var _result150 THBaseServiceEnableTableResult
  var _meta149 thrift.ResponseMeta
  _meta149, _err = p.Client_().Call(ctx, "enableTable", &_args148, &_result150)
  p.SetLastResponseMeta_(_meta149)
  if _err != nil {
    return
  }
  switch {
  case _result150.Io!= nil:
    return _result150.Io
  }

  return nil
}

// Disable a table
// 
// 
// Parameters:
//  - TableName: the tablename to disable
func (p *THBaseServiceClient) DisableTable(ctx context.Context, tableName *TTableName) (_err error) {
  var _args151 THBaseServiceDisableTableArgs
  _args151.TableName = tableName
  var _result153 THBaseServiceDisableTableResult
  var _meta152 thrift.ResponseMeta
  _meta152, _err = p.Client_().Call(ctx, "disableTable", &_args151, &_result153)
  p.SetLastResponseMeta_(_meta152)
  if _err != nil {
    return
  }
  switch {
  case _result153.Io!= nil:
    return _result153.Io
  }

  return nil
}

// 
// @return true if table is enabled, false if not
// 
// 
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableEnabled(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
  var _args154 THBaseServiceIsTableEnabledArgs
  _args154.TableName = tableName
  var _result156 THBaseServiceIsTableEnabledResult
  var _meta155 thrift.ResponseMeta
  _meta155, _err = p.Client_().Call(ctx, "isTableEnabled", &_args154, &_result156)
  p.SetLastResponseMeta_(_meta155)
  if _err != nil {
    return
  }
  switch {
  case _result156.Io!= nil:
    return _r, _result156.Io
  }

  return _result156.GetSuccess(), nil
}

// 
// @return true if table is disabled, false if not
// 
// 
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableDisabled(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
  var _args157 THBaseServiceIsTableDisabledArgs
  _args157.TableName = tableName
  var _result159 THBaseServiceIsTableDisabledResult
  var _meta158 thrift.ResponseMeta
  _meta158, _err = p.Client_().Call(ctx, "isTableDisabled", &_args157, &_result159)
  p.SetLastResponseMeta_(_meta158)
  if _err != nil {
    return
  }
  switch {
  case _result159.Io!= nil:
    return _r, _result159.Io
  }

  return _result159.GetSuccess(), nil
}

// 
// @return true if table is available, false if not
// 
// 
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableAvailable(ctx context.Context, tableName *TTableName) (_r bool, _err error) {
  var _args160 THBaseServiceIsTableAvailableArgs
  _args160.TableName = tableName
  var _result162 THBaseServiceIsTableAvailableResult
  var _meta161 thrift.ResponseMeta
  _meta161, _err = p.Client_().Call(ctx, "isTableAvailable", &_args160, &_result162)
  p.SetLastResponseMeta_(_meta161)
  if _err != nil {
    return
  }
  switch {
  case _result162.Io!= nil:
    return _r, _result162.Io
  }

  return _result162.GetSuccess(), nil
}

//  * Use this api to check if the table has been created with the specified number of splitkeys
//  * which was used while creating the given table. Note : If this api is used after a table's
//  * region gets splitted, the api may return false.
//  *
//  * @return true if table is available, false if not
//  *
//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
//  * since 2.0.0, we will remove it in 3.0.0 release.
//  * Use {@link #isTableAvailable(TTableName tableName)} instead
// *
// 
// Parameters:
//  - TableName: the tablename to check
//  - SplitKeys: keys to check if the table has been created with all split keys
func (p *THBaseServiceClient) IsTableAvailableWithSplit(ctx context.Context, tableName *TTableName, splitKeys [][]byte) (_r bool, _err error) {
  var _args163 THBaseServiceIsTableAvailableWithSplitArgs
  _args163.TableName = tableName
  _args163.SplitKeys = splitKeys
  var _result165 THBaseServiceIsTableAvailableWithSplitResult
  var _meta164 thrift.ResponseMeta
  _meta164, _err = p.Client_().Call(ctx, "isTableAvailableWithSplit", &_args163, &_result165)
  p.SetLastResponseMeta_(_meta164)
  if _err != nil {
    return
  }
  switch {
  case _result165.Io!= nil:
    return _r, _result165.Io
  }

  return _result165.GetSuccess(), nil
}

// Add a column family to an existing table. Synchronous operation.
// 
// 
// Parameters:
//  - TableName: the tablename to add column family to
//  - Column: column family descriptor of column family to be added
func (p *THBaseServiceClient) AddColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error) {
  var _args166 THBaseServiceAddColumnFamilyArgs
  _args166.TableName = tableName
  _args166.Column = column
  var _result168 THBaseServiceAddColumnFamilyResult
  var _meta167 thrift.ResponseMeta
  _meta167, _err = p.Client_().Call(ctx, "addColumnFamily", &_args166, &_result168)
  p.SetLastResponseMeta_(_meta167)
  if _err != nil {
    return
  }
  switch {
  case _result168.Io!= nil:
    return _result168.Io
  }

  return nil
}

// Delete a column family from a table. Synchronous operation.
// 
// 
// Parameters:
//  - TableName: the tablename to delete column family from
//  - Column: name of column family to be deleted
func (p *THBaseServiceClient) DeleteColumnFamily(ctx context.Context, tableName *TTableName, column []byte) (_err error) {
  var _args169 THBaseServiceDeleteColumnFamilyArgs
  _args169.TableName = tableName
  _args169.Column = column
  var _result171 THBaseServiceDeleteColumnFamilyResult
  var _meta170 thrift.ResponseMeta
  _meta170, _err = p.Client_().Call(ctx, "deleteColumnFamily", &_args169, &_result171)
  p.SetLastResponseMeta_(_meta170)
  if _err != nil {
    return
  }
  switch {
  case _result171.Io!= nil:
    return _result171.Io
  }

  return nil
}

// Modify an existing column family on a table. Synchronous operation.
// 
// 
// Parameters:
//  - TableName: the tablename to modify column family
//  - Column: column family descriptor of column family to be modified
func (p *THBaseServiceClient) ModifyColumnFamily(ctx context.Context, tableName *TTableName, column *TColumnFamilyDescriptor) (_err error) {
  var _args172 THBaseServiceModifyColumnFamilyArgs
  _args172.TableName = tableName
  _args172.Column = column
  var _result174 THBaseServiceModifyColumnFamilyResult
  var _meta173 thrift.ResponseMeta
  _meta173, _err = p.Client_().Call(ctx, "modifyColumnFamily", &_args172, &_result174)
  p.SetLastResponseMeta_(_meta173)
  if _err != nil {
    return
  }
  switch {
  case _result174.Io!= nil:
    return _result174.Io
  }

  return nil
}

// Modify an existing table
// 
// 
// Parameters:
//  - Desc: the descriptor of the table to modify
func (p *THBaseServiceClient) ModifyTable(ctx context.Context, desc *TTableDescriptor) (_err error) {
  var _args175 THBaseServiceModifyTableArgs
  _args175.Desc = desc
  var _result177 THBaseServiceModifyTableResult
  var _meta176 thrift.ResponseMeta
  _meta176, _err = p.Client_().Call(ctx, "modifyTable", &_args175, &_result177)
  p.SetLastResponseMeta_(_meta176)
  if _err != nil {
    return
  }
  switch {
  case _result177.Io!= nil:
    return _result177.Io
  }

  return nil
}

// Create a new namespace. Blocks until namespace has been successfully created or an exception is
// thrown
// 
// 
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) CreateNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error) {
  var _args178 THBaseServiceCreateNamespaceArgs
  _args178.NamespaceDesc = namespaceDesc
  var _result180 THBaseServiceCreateNamespaceResult
  var _meta179 thrift.ResponseMeta
  _meta179, _err = p.Client_().Call(ctx, "createNamespace", &_args178, &_result180)
  p.SetLastResponseMeta_(_meta179)
  if _err != nil {
    return
  }
  switch {
  case _result180.Io!= nil:
    return _result180.Io
  }

  return nil
}

// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
// exception is thrown
// 
// 
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) ModifyNamespace(ctx context.Context, namespaceDesc *TNamespaceDescriptor) (_err error) {
  var _args181 THBaseServiceModifyNamespaceArgs
  _args181.NamespaceDesc = namespaceDesc
  var _result183 THBaseServiceModifyNamespaceResult
  var _meta182 thrift.ResponseMeta
  _meta182, _err = p.Client_().Call(ctx, "modifyNamespace", &_args181, &_result183)
  p.SetLastResponseMeta_(_meta182)
  if _err != nil {
    return
  }
  switch {
  case _result183.Io!= nil:
    return _result183.Io
  }

  return nil
}

// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
// Blocks until namespace has been successfully deleted or an
// exception is thrown.
// 
// 
// Parameters:
//  - Name: namespace name
func (p *THBaseServiceClient) DeleteNamespace(ctx context.Context, name string) (_err error) {
  var _args184 THBaseServiceDeleteNamespaceArgs
  _args184.Name = name
  var _result186 THBaseServiceDeleteNamespaceResult
  var _meta185 thrift.ResponseMeta
  _meta185, _err = p.Client_().Call(ctx, "deleteNamespace", &_args184, &_result186)
  p.SetLastResponseMeta_(_meta185)
  if _err != nil {
    return
  }
  switch {
  case _result186.Io!= nil:
    return _result186.Io
  }

  return nil
}

// Get a namespace descriptor by name.
// @retrun the descriptor
// 
// 
// Parameters:
//  - Name: name of namespace descriptor
func (p *THBaseServiceClient) GetNamespaceDescriptor(ctx context.Context, name string) (_r *TNamespaceDescriptor, _err error) {
  var _args187 THBaseServiceGetNamespaceDescriptorArgs
  _args187.Name = name
  var _result189 THBaseServiceGetNamespaceDescriptorResult
  var _meta188 thrift.ResponseMeta
  _meta188, _err = p.Client_().Call(ctx, "getNamespaceDescriptor", &_args187, &_result189)
  p.SetLastResponseMeta_(_meta188)
  if _err != nil {
    return
  }
  switch {
  case _result189.Io!= nil:
    return _r, _result189.Io
  }

  if _ret190 := _result189.GetSuccess(); _ret190 != nil {
    return _ret190, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNamespaceDescriptor failed: unknown result")
}

// @return all namespaces
// 
func (p *THBaseServiceClient) ListNamespaceDescriptors(ctx context.Context) (_r []*TNamespaceDescriptor, _err error) {
  var _args191 THBaseServiceListNamespaceDescriptorsArgs
  var _result193 THBaseServiceListNamespaceDescriptorsResult
  var _meta192 thrift.ResponseMeta
  _meta192, _err = p.Client_().Call(ctx, "listNamespaceDescriptors", &_args191, &_result193)
  p.SetLastResponseMeta_(_meta192)
  if _err != nil {
    return
  }
  switch {
  case _result193.Io!= nil:
    return _r, _result193.Io
  }

  return _result193.GetSuccess(), nil
}

// @return all namespace names
// 
func (p *THBaseServiceClient) ListNamespaces(ctx context.Context) (_r []string, _err error) {
  var _args194 THBaseServiceListNamespacesArgs
  var _result196 THBaseServiceListNamespacesResult
  var _meta195 thrift.ResponseMeta
  _meta195, _err = p.Client_().Call(ctx, "listNamespaces", &_args194, &_result196)
  p.SetLastResponseMeta_(_meta195)
  if _err != nil {
    return
  }
  switch {
  case _result196.Io!= nil:
    return _r, _result196.Io
  }

  return _result196.GetSuccess(), nil
}

// Get the type of this thrift server.
// 
// @return the type of this thrift server
func (p *THBaseServiceClient) GetThriftServerType(ctx context.Context) (_r TThriftServerType, _err error) {
  var _args197 THBaseServiceGetThriftServerTypeArgs
  var _result199 THBaseServiceGetThriftServerTypeResult
  var _meta198 thrift.ResponseMeta
  _meta198, _err = p.Client_().Call(ctx, "getThriftServerType", &_args197, &_result199)
  p.SetLastResponseMeta_(_meta198)
  if _err != nil {
    return
  }
  return _result199.GetSuccess(), nil
}

// Retrieves online slow RPC logs from the provided list of
// RegionServers
// 
// @return online slowlog response list
// @throws TIOError if a remote or network exception occurs
// 
// Parameters:
//  - ServerNames: @param serverNames Server names to get slowlog responses from
//  - LogQueryFilter: @param logQueryFilter filter to be used if provided
func (p *THBaseServiceClient) GetSlowLogResponses(ctx context.Context, serverNames []*TServerName, logQueryFilter *TLogQueryFilter) (_r []*TOnlineLogRecord, _err error) {
  var _args200 THBaseServiceGetSlowLogResponsesArgs
  _args200.ServerNames = serverNames
  _args200.LogQueryFilter = logQueryFilter
  var _result202 THBaseServiceGetSlowLogResponsesResult
  var _meta201 thrift.ResponseMeta
  _meta201, _err = p.Client_().Call(ctx, "getSlowLogResponses", &_args200, &_result202)
  p.SetLastResponseMeta_(_meta201)
  if _err != nil {
    return
  }
  switch {
  case _result202.Io!= nil:
    return _r, _result202.Io
  }

  return _result202.GetSuccess(), nil
}

// Clears online slow/large RPC logs from the provided list of
// RegionServers
// 
// @return List of booleans representing if online slowlog response buffer is cleaned
//   from each RegionServer
// @throws TIOError if a remote or network exception occurs
// 
// Parameters:
//  - ServerNames: @param serverNames Set of Server names to clean slowlog responses from
func (p *THBaseServiceClient) ClearSlowLogResponses(ctx context.Context, serverNames []*TServerName) (_r []bool, _err error) {
  var _args203 THBaseServiceClearSlowLogResponsesArgs
  _args203.ServerNames = serverNames
  var _result205 THBaseServiceClearSlowLogResponsesResult
  var _meta204 thrift.ResponseMeta
  _meta204, _err = p.Client_().Call(ctx, "clearSlowLogResponses", &_args203, &_result205)
  p.SetLastResponseMeta_(_meta204)
  if _err != nil {
    return
  }
  switch {
  case _result205.Io!= nil:
    return _r, _result205.Io
  }

  return _result205.GetSuccess(), nil
}

// Returns the cluster ID for this cluster.
func (p *THBaseServiceClient) GetClusterId(ctx context.Context) (_r string, _err error) {
  var _args206 THBaseServiceGetClusterIdArgs
  var _result208 THBaseServiceGetClusterIdResult
  var _meta207 thrift.ResponseMeta
  _meta207, _err = p.Client_().Call(ctx, "getClusterId", &_args206, &_result208)
  p.SetLastResponseMeta_(_meta207)
  if _err != nil {
    return
  }
  return _result208.GetSuccess(), nil
}

type THBaseServiceProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

  self209 := &THBaseServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self209.processorMap["exists"] = &tHBaseServiceProcessorExists{handler:handler}
  self209.processorMap["existsAll"] = &tHBaseServiceProcessorExistsAll{handler:handler}
  self209.processorMap["get"] = &tHBaseServiceProcessorGet{handler:handler}
  self209.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler:handler}
  self209.processorMap["put"] = &tHBaseServiceProcessorPut{handler:handler}
  self209.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler:handler}
  self209.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler:handler}
  self209.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler:handler}
  self209.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler:handler}
  self209.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler:handler}
  self209.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler:handler}
  self209.processorMap["append"] = &tHBaseServiceProcessorAppend{handler:handler}
  self209.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler:handler}
  self209.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler:handler}
  self209.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler:handler}
  self209.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler:handler}
  self209.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler:handler}
  self209.processorMap["getRegionLocation"] = &tHBaseServiceProcessorGetRegionLocation{handler:handler}
  self209.processorMap["getAllRegionLocations"] = &tHBaseServiceProcessorGetAllRegionLocations{handler:handler}
  self209.processorMap["checkAndMutate"] = &tHBaseServiceProcessorCheckAndMutate{handler:handler}
  self209.processorMap["getTableDescriptor"] = &tHBaseServiceProcessorGetTableDescriptor{handler:handler}
  self209.processorMap["getTableDescriptors"] = &tHBaseServiceProcessorGetTableDescriptors{handler:handler}
  self209.processorMap["tableExists"] = &tHBaseServiceProcessorTableExists{handler:handler}
  self209.processorMap["getTableDescriptorsByPattern"] = &tHBaseServiceProcessorGetTableDescriptorsByPattern{handler:handler}
  self209.processorMap["getTableDescriptorsByNamespace"] = &tHBaseServiceProcessorGetTableDescriptorsByNamespace{handler:handler}
  self209.processorMap["getTableNamesByPattern"] = &tHBaseServiceProcessorGetTableNamesByPattern{handler:handler}
  self209.processorMap["getTableNamesByNamespace"] = &tHBaseServiceProcessorGetTableNamesByNamespace{handler:handler}
  self209.processorMap["createTable"] = &tHBaseServiceProcessorCreateTable{handler:handler}
  self209.processorMap["deleteTable"] = &tHBaseServiceProcessorDeleteTable{handler:handler}
  self209.processorMap["truncateTable"] = &tHBaseServiceProcessorTruncateTable{handler:handler}
  self209.processorMap["enableTable"] = &tHBaseServiceProcessorEnableTable{handler:handler}
  self209.processorMap["disableTable"] = &tHBaseServiceProcessorDisableTable{handler:handler}
  self209.processorMap["isTableEnabled"] = &tHBaseServiceProcessorIsTableEnabled{handler:handler}
  self209.processorMap["isTableDisabled"] = &tHBaseServiceProcessorIsTableDisabled{handler:handler}
  self209.processorMap["isTableAvailable"] = &tHBaseServiceProcessorIsTableAvailable{handler:handler}
  self209.processorMap["isTableAvailableWithSplit"] = &tHBaseServiceProcessorIsTableAvailableWithSplit{handler:handler}
  self209.processorMap["addColumnFamily"] = &tHBaseServiceProcessorAddColumnFamily{handler:handler}
  self209.processorMap["deleteColumnFamily"] = &tHBaseServiceProcessorDeleteColumnFamily{handler:handler}
  self209.processorMap["modifyColumnFamily"] = &tHBaseServiceProcessorModifyColumnFamily{handler:handler}
  self209.processorMap["modifyTable"] = &tHBaseServiceProcessorModifyTable{handler:handler}
  self209.processorMap["createNamespace"] = &tHBaseServiceProcessorCreateNamespace{handler:handler}
  self209.processorMap["modifyNamespace"] = &tHBaseServiceProcessorModifyNamespace{handler:handler}
  self209.processorMap["deleteNamespace"] = &tHBaseServiceProcessorDeleteNamespace{handler:handler}
  self209.processorMap["getNamespaceDescriptor"] = &tHBaseServiceProcessorGetNamespaceDescriptor{handler:handler}
  self209.processorMap["listNamespaceDescriptors"] = &tHBaseServiceProcessorListNamespaceDescriptors{handler:handler}
  self209.processorMap["listNamespaces"] = &tHBaseServiceProcessorListNamespaces{handler:handler}
  self209.processorMap["getThriftServerType"] = &tHBaseServiceProcessorGetThriftServerType{handler:handler}
  self209.processorMap["getSlowLogResponses"] = &tHBaseServiceProcessorGetSlowLogResponses{handler:handler}
  self209.processorMap["clearSlowLogResponses"] = &tHBaseServiceProcessorClearSlowLogResponses{handler:handler}
  self209.processorMap["getClusterId"] = &tHBaseServiceProcessorGetClusterId{handler:handler}
return self209
}

func (p *THBaseServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x210 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x210.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x210

}

type tHBaseServiceProcessorExists struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err211 error
  args := THBaseServiceExistsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "exists", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceExistsResult{}
  if retval, err2 := p.handler.Exists(ctx, args.Table, args.Tget); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc212 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "exists", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err211 = thrift.WrapTException(err2)
      }
      if err2 := _exc212.Write(ctx, oprot); _write_err211 == nil && err2 != nil {
        _write_err211 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err211 == nil && err2 != nil {
        _write_err211 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err211 == nil && err2 != nil {
        _write_err211 = thrift.WrapTException(err2)
      }
      if _write_err211 != nil {
        return false, thrift.WrapTException(_write_err211)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "exists", thrift.REPLY, seqId); err2 != nil {
    _write_err211 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err211 == nil && err2 != nil {
    _write_err211 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err211 == nil && err2 != nil {
    _write_err211 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err211 == nil && err2 != nil {
    _write_err211 = thrift.WrapTException(err2)
  }
  if _write_err211 != nil {
    return false, thrift.WrapTException(_write_err211)
  }
  return true, err
}

type tHBaseServiceProcessorExistsAll struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorExistsAll) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err213 error
  args := THBaseServiceExistsAllArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "existsAll", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceExistsAllResult{}
  if retval, err2 := p.handler.ExistsAll(ctx, args.Table, args.Tgets); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc214 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing existsAll: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "existsAll", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err213 = thrift.WrapTException(err2)
      }
      if err2 := _exc214.Write(ctx, oprot); _write_err213 == nil && err2 != nil {
        _write_err213 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err213 == nil && err2 != nil {
        _write_err213 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err213 == nil && err2 != nil {
        _write_err213 = thrift.WrapTException(err2)
      }
      if _write_err213 != nil {
        return false, thrift.WrapTException(_write_err213)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "existsAll", thrift.REPLY, seqId); err2 != nil {
    _write_err213 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err213 == nil && err2 != nil {
    _write_err213 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err213 == nil && err2 != nil {
    _write_err213 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err213 == nil && err2 != nil {
    _write_err213 = thrift.WrapTException(err2)
  }
  if _write_err213 != nil {
    return false, thrift.WrapTException(_write_err213)
  }
  return true, err
}

type tHBaseServiceProcessorGet struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err215 error
  args := THBaseServiceGetArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "get", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetResult{}
  if retval, err2 := p.handler.Get(ctx, args.Table, args.Tget); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc216 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "get", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err215 = thrift.WrapTException(err2)
      }
      if err2 := _exc216.Write(ctx, oprot); _write_err215 == nil && err2 != nil {
        _write_err215 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err215 == nil && err2 != nil {
        _write_err215 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err215 == nil && err2 != nil {
        _write_err215 = thrift.WrapTException(err2)
      }
      if _write_err215 != nil {
        return false, thrift.WrapTException(_write_err215)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "get", thrift.REPLY, seqId); err2 != nil {
    _write_err215 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err215 == nil && err2 != nil {
    _write_err215 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err215 == nil && err2 != nil {
    _write_err215 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err215 == nil && err2 != nil {
    _write_err215 = thrift.WrapTException(err2)
  }
  if _write_err215 != nil {
    return false, thrift.WrapTException(_write_err215)
  }
  return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err217 error
  args := THBaseServiceGetMultipleArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getMultiple", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetMultipleResult{}
  if retval, err2 := p.handler.GetMultiple(ctx, args.Table, args.Tgets); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc218 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getMultiple", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err217 = thrift.WrapTException(err2)
      }
      if err2 := _exc218.Write(ctx, oprot); _write_err217 == nil && err2 != nil {
        _write_err217 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err217 == nil && err2 != nil {
        _write_err217 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err217 == nil && err2 != nil {
        _write_err217 = thrift.WrapTException(err2)
      }
      if _write_err217 != nil {
        return false, thrift.WrapTException(_write_err217)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getMultiple", thrift.REPLY, seqId); err2 != nil {
    _write_err217 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err217 == nil && err2 != nil {
    _write_err217 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err217 == nil && err2 != nil {
    _write_err217 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err217 == nil && err2 != nil {
    _write_err217 = thrift.WrapTException(err2)
  }
  if _write_err217 != nil {
    return false, thrift.WrapTException(_write_err217)
  }
  return true, err
}

type tHBaseServiceProcessorPut struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err219 error
  args := THBaseServicePutArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "put", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServicePutResult{}
  if err2 := p.handler.Put(ctx, args.Table, args.Tput); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc220 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "put", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err219 = thrift.WrapTException(err2)
      }
      if err2 := _exc220.Write(ctx, oprot); _write_err219 == nil && err2 != nil {
        _write_err219 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err219 == nil && err2 != nil {
        _write_err219 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err219 == nil && err2 != nil {
        _write_err219 = thrift.WrapTException(err2)
      }
      if _write_err219 != nil {
        return false, thrift.WrapTException(_write_err219)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "put", thrift.REPLY, seqId); err2 != nil {
    _write_err219 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err219 == nil && err2 != nil {
    _write_err219 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err219 == nil && err2 != nil {
    _write_err219 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err219 == nil && err2 != nil {
    _write_err219 = thrift.WrapTException(err2)
  }
  if _write_err219 != nil {
    return false, thrift.WrapTException(_write_err219)
  }
  return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err221 error
  args := THBaseServiceCheckAndPutArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCheckAndPutResult{}
  if retval, err2 := p.handler.CheckAndPut(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc222 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err221 = thrift.WrapTException(err2)
      }
      if err2 := _exc222.Write(ctx, oprot); _write_err221 == nil && err2 != nil {
        _write_err221 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err221 == nil && err2 != nil {
        _write_err221 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err221 == nil && err2 != nil {
        _write_err221 = thrift.WrapTException(err2)
      }
      if _write_err221 != nil {
        return false, thrift.WrapTException(_write_err221)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "checkAndPut", thrift.REPLY, seqId); err2 != nil {
    _write_err221 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err221 == nil && err2 != nil {
    _write_err221 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err221 == nil && err2 != nil {
    _write_err221 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err221 == nil && err2 != nil {
    _write_err221 = thrift.WrapTException(err2)
  }
  if _write_err221 != nil {
    return false, thrift.WrapTException(_write_err221)
  }
  return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err223 error
  args := THBaseServicePutMultipleArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "putMultiple", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServicePutMultipleResult{}
  if err2 := p.handler.PutMultiple(ctx, args.Table, args.Tputs); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc224 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "putMultiple", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err223 = thrift.WrapTException(err2)
      }
      if err2 := _exc224.Write(ctx, oprot); _write_err223 == nil && err2 != nil {
        _write_err223 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err223 == nil && err2 != nil {
        _write_err223 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err223 == nil && err2 != nil {
        _write_err223 = thrift.WrapTException(err2)
      }
      if _write_err223 != nil {
        return false, thrift.WrapTException(_write_err223)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "putMultiple", thrift.REPLY, seqId); err2 != nil {
    _write_err223 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err223 == nil && err2 != nil {
    _write_err223 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err223 == nil && err2 != nil {
    _write_err223 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err223 == nil && err2 != nil {
    _write_err223 = thrift.WrapTException(err2)
  }
  if _write_err223 != nil {
    return false, thrift.WrapTException(_write_err223)
  }
  return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err225 error
  args := THBaseServiceDeleteSingleArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDeleteSingleResult{}
  if err2 := p.handler.DeleteSingle(ctx, args.Table, args.Tdelete); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc226 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err225 = thrift.WrapTException(err2)
      }
      if err2 := _exc226.Write(ctx, oprot); _write_err225 == nil && err2 != nil {
        _write_err225 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err225 == nil && err2 != nil {
        _write_err225 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err225 == nil && err2 != nil {
        _write_err225 = thrift.WrapTException(err2)
      }
      if _write_err225 != nil {
        return false, thrift.WrapTException(_write_err225)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "deleteSingle", thrift.REPLY, seqId); err2 != nil {
    _write_err225 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err225 == nil && err2 != nil {
    _write_err225 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err225 == nil && err2 != nil {
    _write_err225 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err225 == nil && err2 != nil {
    _write_err225 = thrift.WrapTException(err2)
  }
  if _write_err225 != nil {
    return false, thrift.WrapTException(_write_err225)
  }
  return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err227 error
  args := THBaseServiceDeleteMultipleArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDeleteMultipleResult{}
  if retval, err2 := p.handler.DeleteMultiple(ctx, args.Table, args.Tdeletes); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc228 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err227 = thrift.WrapTException(err2)
      }
      if err2 := _exc228.Write(ctx, oprot); _write_err227 == nil && err2 != nil {
        _write_err227 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err227 == nil && err2 != nil {
        _write_err227 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err227 == nil && err2 != nil {
        _write_err227 = thrift.WrapTException(err2)
      }
      if _write_err227 != nil {
        return false, thrift.WrapTException(_write_err227)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "deleteMultiple", thrift.REPLY, seqId); err2 != nil {
    _write_err227 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err227 == nil && err2 != nil {
    _write_err227 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err227 == nil && err2 != nil {
    _write_err227 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err227 == nil && err2 != nil {
    _write_err227 = thrift.WrapTException(err2)
  }
  if _write_err227 != nil {
    return false, thrift.WrapTException(_write_err227)
  }
  return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err229 error
  args := THBaseServiceCheckAndDeleteArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCheckAndDeleteResult{}
  if retval, err2 := p.handler.CheckAndDelete(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc230 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err229 = thrift.WrapTException(err2)
      }
      if err2 := _exc230.Write(ctx, oprot); _write_err229 == nil && err2 != nil {
        _write_err229 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err229 == nil && err2 != nil {
        _write_err229 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err229 == nil && err2 != nil {
        _write_err229 = thrift.WrapTException(err2)
      }
      if _write_err229 != nil {
        return false, thrift.WrapTException(_write_err229)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "checkAndDelete", thrift.REPLY, seqId); err2 != nil {
    _write_err229 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err229 == nil && err2 != nil {
    _write_err229 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err229 == nil && err2 != nil {
    _write_err229 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err229 == nil && err2 != nil {
    _write_err229 = thrift.WrapTException(err2)
  }
  if _write_err229 != nil {
    return false, thrift.WrapTException(_write_err229)
  }
  return true, err
}

type tHBaseServiceProcessorIncrement struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err231 error
  args := THBaseServiceIncrementArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "increment", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceIncrementResult{}
  if retval, err2 := p.handler.Increment(ctx, args.Table, args.Tincrement); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc232 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "increment", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err231 = thrift.WrapTException(err2)
      }
      if err2 := _exc232.Write(ctx, oprot); _write_err231 == nil && err2 != nil {
        _write_err231 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err231 == nil && err2 != nil {
        _write_err231 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err231 == nil && err2 != nil {
        _write_err231 = thrift.WrapTException(err2)
      }
      if _write_err231 != nil {
        return false, thrift.WrapTException(_write_err231)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "increment", thrift.REPLY, seqId); err2 != nil {
    _write_err231 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err231 == nil && err2 != nil {
    _write_err231 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err231 == nil && err2 != nil {
    _write_err231 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err231 == nil && err2 != nil {
    _write_err231 = thrift.WrapTException(err2)
  }
  if _write_err231 != nil {
    return false, thrift.WrapTException(_write_err231)
  }
  return true, err
}

type tHBaseServiceProcessorAppend struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorAppend) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err233 error
  args := THBaseServiceAppendArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "append", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceAppendResult{}
  if retval, err2 := p.handler.Append(ctx, args.Table, args.Tappend); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc234 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "append", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err233 = thrift.WrapTException(err2)
      }
      if err2 := _exc234.Write(ctx, oprot); _write_err233 == nil && err2 != nil {
        _write_err233 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err233 == nil && err2 != nil {
        _write_err233 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err233 == nil && err2 != nil {
        _write_err233 = thrift.WrapTException(err2)
      }
      if _write_err233 != nil {
        return false, thrift.WrapTException(_write_err233)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "append", thrift.REPLY, seqId); err2 != nil {
    _write_err233 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err233 == nil && err2 != nil {
    _write_err233 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err233 == nil && err2 != nil {
    _write_err233 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err233 == nil && err2 != nil {
    _write_err233 = thrift.WrapTException(err2)
  }
  if _write_err233 != nil {
    return false, thrift.WrapTException(_write_err233)
  }
  return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err235 error
  args := THBaseServiceOpenScannerArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "openScanner", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceOpenScannerResult{}
  if retval, err2 := p.handler.OpenScanner(ctx, args.Table, args.Tscan); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc236 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "openScanner", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err235 = thrift.WrapTException(err2)
      }
      if err2 := _exc236.Write(ctx, oprot); _write_err235 == nil && err2 != nil {
        _write_err235 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err235 == nil && err2 != nil {
        _write_err235 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err235 == nil && err2 != nil {
        _write_err235 = thrift.WrapTException(err2)
      }
      if _write_err235 != nil {
        return false, thrift.WrapTException(_write_err235)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "openScanner", thrift.REPLY, seqId); err2 != nil {
    _write_err235 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err235 == nil && err2 != nil {
    _write_err235 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err235 == nil && err2 != nil {
    _write_err235 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err235 == nil && err2 != nil {
    _write_err235 = thrift.WrapTException(err2)
  }
  if _write_err235 != nil {
    return false, thrift.WrapTException(_write_err235)
  }
  return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err237 error
  args := THBaseServiceGetScannerRowsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetScannerRowsResult{}
  if retval, err2 := p.handler.GetScannerRows(ctx, args.ScannerId, args.NumRows); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    case *TIllegalArgument:
      result.Ia = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc238 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err237 = thrift.WrapTException(err2)
      }
      if err2 := _exc238.Write(ctx, oprot); _write_err237 == nil && err2 != nil {
        _write_err237 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err237 == nil && err2 != nil {
        _write_err237 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err237 == nil && err2 != nil {
        _write_err237 = thrift.WrapTException(err2)
      }
      if _write_err237 != nil {
        return false, thrift.WrapTException(_write_err237)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getScannerRows", thrift.REPLY, seqId); err2 != nil {
    _write_err237 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err237 == nil && err2 != nil {
    _write_err237 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err237 == nil && err2 != nil {
    _write_err237 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err237 == nil && err2 != nil {
    _write_err237 = thrift.WrapTException(err2)
  }
  if _write_err237 != nil {
    return false, thrift.WrapTException(_write_err237)
  }
  return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err239 error
  args := THBaseServiceCloseScannerArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "closeScanner", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCloseScannerResult{}
  if err2 := p.handler.CloseScanner(ctx, args.ScannerId); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    case *TIllegalArgument:
      result.Ia = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc240 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "closeScanner", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err239 = thrift.WrapTException(err2)
      }
      if err2 := _exc240.Write(ctx, oprot); _write_err239 == nil && err2 != nil {
        _write_err239 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err239 == nil && err2 != nil {
        _write_err239 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err239 == nil && err2 != nil {
        _write_err239 = thrift.WrapTException(err2)
      }
      if _write_err239 != nil {
        return false, thrift.WrapTException(_write_err239)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "closeScanner", thrift.REPLY, seqId); err2 != nil {
    _write_err239 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err239 == nil && err2 != nil {
    _write_err239 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err239 == nil && err2 != nil {
    _write_err239 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err239 == nil && err2 != nil {
    _write_err239 = thrift.WrapTException(err2)
  }
  if _write_err239 != nil {
    return false, thrift.WrapTException(_write_err239)
  }
  return true, err
}

type tHBaseServiceProcessorMutateRow struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err241 error
  args := THBaseServiceMutateRowArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mutateRow", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceMutateRowResult{}
  if err2 := p.handler.MutateRow(ctx, args.Table, args.TrowMutations); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc242 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "mutateRow", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err241 = thrift.WrapTException(err2)
      }
      if err2 := _exc242.Write(ctx, oprot); _write_err241 == nil && err2 != nil {
        _write_err241 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err241 == nil && err2 != nil {
        _write_err241 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err241 == nil && err2 != nil {
        _write_err241 = thrift.WrapTException(err2)
      }
      if _write_err241 != nil {
        return false, thrift.WrapTException(_write_err241)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "mutateRow", thrift.REPLY, seqId); err2 != nil {
    _write_err241 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err241 == nil && err2 != nil {
    _write_err241 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err241 == nil && err2 != nil {
    _write_err241 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err241 == nil && err2 != nil {
    _write_err241 = thrift.WrapTException(err2)
  }
  if _write_err241 != nil {
    return false, thrift.WrapTException(_write_err241)
  }
  return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err243 error
  args := THBaseServiceGetScannerResultsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetScannerResultsResult{}
  if retval, err2 := p.handler.GetScannerResults(ctx, args.Table, args.Tscan, args.NumRows); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc244 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err243 = thrift.WrapTException(err2)
      }
      if err2 := _exc244.Write(ctx, oprot); _write_err243 == nil && err2 != nil {
        _write_err243 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err243 == nil && err2 != nil {
        _write_err243 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err243 == nil && err2 != nil {
        _write_err243 = thrift.WrapTException(err2)
      }
      if _write_err243 != nil {
        return false, thrift.WrapTException(_write_err243)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getScannerResults", thrift.REPLY, seqId); err2 != nil {
    _write_err243 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err243 == nil && err2 != nil {
    _write_err243 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err243 == nil && err2 != nil {
    _write_err243 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err243 == nil && err2 != nil {
    _write_err243 = thrift.WrapTException(err2)
  }
  if _write_err243 != nil {
    return false, thrift.WrapTException(_write_err243)
  }
  return true, err
}

type tHBaseServiceProcessorGetRegionLocation struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetRegionLocation) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err245 error
  args := THBaseServiceGetRegionLocationArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetRegionLocationResult{}
  if retval, err2 := p.handler.GetRegionLocation(ctx, args.Table, args.Row, args.Reload); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc246 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionLocation: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err245 = thrift.WrapTException(err2)
      }
      if err2 := _exc246.Write(ctx, oprot); _write_err245 == nil && err2 != nil {
        _write_err245 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err245 == nil && err2 != nil {
        _write_err245 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err245 == nil && err2 != nil {
        _write_err245 = thrift.WrapTException(err2)
      }
      if _write_err245 != nil {
        return false, thrift.WrapTException(_write_err245)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getRegionLocation", thrift.REPLY, seqId); err2 != nil {
    _write_err245 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err245 == nil && err2 != nil {
    _write_err245 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err245 == nil && err2 != nil {
    _write_err245 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err245 == nil && err2 != nil {
    _write_err245 = thrift.WrapTException(err2)
  }
  if _write_err245 != nil {
    return false, thrift.WrapTException(_write_err245)
  }
  return true, err
}

type tHBaseServiceProcessorGetAllRegionLocations struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetAllRegionLocations) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err247 error
  args := THBaseServiceGetAllRegionLocationsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetAllRegionLocationsResult{}
  if retval, err2 := p.handler.GetAllRegionLocations(ctx, args.Table); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc248 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAllRegionLocations: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err247 = thrift.WrapTException(err2)
      }
      if err2 := _exc248.Write(ctx, oprot); _write_err247 == nil && err2 != nil {
        _write_err247 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err247 == nil && err2 != nil {
        _write_err247 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err247 == nil && err2 != nil {
        _write_err247 = thrift.WrapTException(err2)
      }
      if _write_err247 != nil {
        return false, thrift.WrapTException(_write_err247)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getAllRegionLocations", thrift.REPLY, seqId); err2 != nil {
    _write_err247 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err247 == nil && err2 != nil {
    _write_err247 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err247 == nil && err2 != nil {
    _write_err247 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err247 == nil && err2 != nil {
    _write_err247 = thrift.WrapTException(err2)
  }
  if _write_err247 != nil {
    return false, thrift.WrapTException(_write_err247)
  }
  return true, err
}

type tHBaseServiceProcessorCheckAndMutate struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndMutate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err249 error
  args := THBaseServiceCheckAndMutateArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCheckAndMutateResult{}
  if retval, err2 := p.handler.CheckAndMutate(ctx, args.Table, args.Row, args.Family, args.Qualifier, args.CompareOp, args.Value, args.RowMutations); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc250 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndMutate: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err249 = thrift.WrapTException(err2)
      }
      if err2 := _exc250.Write(ctx, oprot); _write_err249 == nil && err2 != nil {
        _write_err249 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err249 == nil && err2 != nil {
        _write_err249 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err249 == nil && err2 != nil {
        _write_err249 = thrift.WrapTException(err2)
      }
      if _write_err249 != nil {
        return false, thrift.WrapTException(_write_err249)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "checkAndMutate", thrift.REPLY, seqId); err2 != nil {
    _write_err249 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err249 == nil && err2 != nil {
    _write_err249 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err249 == nil && err2 != nil {
    _write_err249 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err249 == nil && err2 != nil {
    _write_err249 = thrift.WrapTException(err2)
  }
  if _write_err249 != nil {
    return false, thrift.WrapTException(_write_err249)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableDescriptor struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptor) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err251 error
  args := THBaseServiceGetTableDescriptorArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableDescriptorResult{}
  if retval, err2 := p.handler.GetTableDescriptor(ctx, args.Table); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc252 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptor: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err251 = thrift.WrapTException(err2)
      }
      if err2 := _exc252.Write(ctx, oprot); _write_err251 == nil && err2 != nil {
        _write_err251 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err251 == nil && err2 != nil {
        _write_err251 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err251 == nil && err2 != nil {
        _write_err251 = thrift.WrapTException(err2)
      }
      if _write_err251 != nil {
        return false, thrift.WrapTException(_write_err251)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptor", thrift.REPLY, seqId); err2 != nil {
    _write_err251 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err251 == nil && err2 != nil {
    _write_err251 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err251 == nil && err2 != nil {
    _write_err251 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err251 == nil && err2 != nil {
    _write_err251 = thrift.WrapTException(err2)
  }
  if _write_err251 != nil {
    return false, thrift.WrapTException(_write_err251)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableDescriptors struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptors) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err253 error
  args := THBaseServiceGetTableDescriptorsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableDescriptorsResult{}
  if retval, err2 := p.handler.GetTableDescriptors(ctx, args.Tables); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc254 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptors: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err253 = thrift.WrapTException(err2)
      }
      if err2 := _exc254.Write(ctx, oprot); _write_err253 == nil && err2 != nil {
        _write_err253 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err253 == nil && err2 != nil {
        _write_err253 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err253 == nil && err2 != nil {
        _write_err253 = thrift.WrapTException(err2)
      }
      if _write_err253 != nil {
        return false, thrift.WrapTException(_write_err253)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptors", thrift.REPLY, seqId); err2 != nil {
    _write_err253 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err253 == nil && err2 != nil {
    _write_err253 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err253 == nil && err2 != nil {
    _write_err253 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err253 == nil && err2 != nil {
    _write_err253 = thrift.WrapTException(err2)
  }
  if _write_err253 != nil {
    return false, thrift.WrapTException(_write_err253)
  }
  return true, err
}

type tHBaseServiceProcessorTableExists struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorTableExists) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err255 error
  args := THBaseServiceTableExistsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "tableExists", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceTableExistsResult{}
  if retval, err2 := p.handler.TableExists(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc256 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tableExists: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "tableExists", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err255 = thrift.WrapTException(err2)
      }
      if err2 := _exc256.Write(ctx, oprot); _write_err255 == nil && err2 != nil {
        _write_err255 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err255 == nil && err2 != nil {
        _write_err255 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err255 == nil && err2 != nil {
        _write_err255 = thrift.WrapTException(err2)
      }
      if _write_err255 != nil {
        return false, thrift.WrapTException(_write_err255)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "tableExists", thrift.REPLY, seqId); err2 != nil {
    _write_err255 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err255 == nil && err2 != nil {
    _write_err255 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err255 == nil && err2 != nil {
    _write_err255 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err255 == nil && err2 != nil {
    _write_err255 = thrift.WrapTException(err2)
  }
  if _write_err255 != nil {
    return false, thrift.WrapTException(_write_err255)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByPattern struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByPattern) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err257 error
  args := THBaseServiceGetTableDescriptorsByPatternArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableDescriptorsByPatternResult{}
  if retval, err2 := p.handler.GetTableDescriptorsByPattern(ctx, args.Regex, args.IncludeSysTables); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc258 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByPattern: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err257 = thrift.WrapTException(err2)
      }
      if err2 := _exc258.Write(ctx, oprot); _write_err257 == nil && err2 != nil {
        _write_err257 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err257 == nil && err2 != nil {
        _write_err257 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err257 == nil && err2 != nil {
        _write_err257 = thrift.WrapTException(err2)
      }
      if _write_err257 != nil {
        return false, thrift.WrapTException(_write_err257)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByPattern", thrift.REPLY, seqId); err2 != nil {
    _write_err257 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err257 == nil && err2 != nil {
    _write_err257 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err257 == nil && err2 != nil {
    _write_err257 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err257 == nil && err2 != nil {
    _write_err257 = thrift.WrapTException(err2)
  }
  if _write_err257 != nil {
    return false, thrift.WrapTException(_write_err257)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByNamespace struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err259 error
  args := THBaseServiceGetTableDescriptorsByNamespaceArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableDescriptorsByNamespaceResult{}
  if retval, err2 := p.handler.GetTableDescriptorsByNamespace(ctx, args.Name); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc260 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByNamespace: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err259 = thrift.WrapTException(err2)
      }
      if err2 := _exc260.Write(ctx, oprot); _write_err259 == nil && err2 != nil {
        _write_err259 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err259 == nil && err2 != nil {
        _write_err259 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err259 == nil && err2 != nil {
        _write_err259 = thrift.WrapTException(err2)
      }
      if _write_err259 != nil {
        return false, thrift.WrapTException(_write_err259)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableDescriptorsByNamespace", thrift.REPLY, seqId); err2 != nil {
    _write_err259 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err259 == nil && err2 != nil {
    _write_err259 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err259 == nil && err2 != nil {
    _write_err259 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err259 == nil && err2 != nil {
    _write_err259 = thrift.WrapTException(err2)
  }
  if _write_err259 != nil {
    return false, thrift.WrapTException(_write_err259)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableNamesByPattern struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByPattern) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err261 error
  args := THBaseServiceGetTableNamesByPatternArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableNamesByPatternResult{}
  if retval, err2 := p.handler.GetTableNamesByPattern(ctx, args.Regex, args.IncludeSysTables); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc262 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByPattern: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err261 = thrift.WrapTException(err2)
      }
      if err2 := _exc262.Write(ctx, oprot); _write_err261 == nil && err2 != nil {
        _write_err261 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err261 == nil && err2 != nil {
        _write_err261 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err261 == nil && err2 != nil {
        _write_err261 = thrift.WrapTException(err2)
      }
      if _write_err261 != nil {
        return false, thrift.WrapTException(_write_err261)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByPattern", thrift.REPLY, seqId); err2 != nil {
    _write_err261 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err261 == nil && err2 != nil {
    _write_err261 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err261 == nil && err2 != nil {
    _write_err261 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err261 == nil && err2 != nil {
    _write_err261 = thrift.WrapTException(err2)
  }
  if _write_err261 != nil {
    return false, thrift.WrapTException(_write_err261)
  }
  return true, err
}

type tHBaseServiceProcessorGetTableNamesByNamespace struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err263 error
  args := THBaseServiceGetTableNamesByNamespaceArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetTableNamesByNamespaceResult{}
  if retval, err2 := p.handler.GetTableNamesByNamespace(ctx, args.Name); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc264 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByNamespace: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err263 = thrift.WrapTException(err2)
      }
      if err2 := _exc264.Write(ctx, oprot); _write_err263 == nil && err2 != nil {
        _write_err263 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err263 == nil && err2 != nil {
        _write_err263 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err263 == nil && err2 != nil {
        _write_err263 = thrift.WrapTException(err2)
      }
      if _write_err263 != nil {
        return false, thrift.WrapTException(_write_err263)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getTableNamesByNamespace", thrift.REPLY, seqId); err2 != nil {
    _write_err263 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err263 == nil && err2 != nil {
    _write_err263 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err263 == nil && err2 != nil {
    _write_err263 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err263 == nil && err2 != nil {
    _write_err263 = thrift.WrapTException(err2)
  }
  if _write_err263 != nil {
    return false, thrift.WrapTException(_write_err263)
  }
  return true, err
}

type tHBaseServiceProcessorCreateTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCreateTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err265 error
  args := THBaseServiceCreateTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCreateTableResult{}
  if err2 := p.handler.CreateTable(ctx, args.Desc, args.SplitKeys); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc266 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "createTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err265 = thrift.WrapTException(err2)
      }
      if err2 := _exc266.Write(ctx, oprot); _write_err265 == nil && err2 != nil {
        _write_err265 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err265 == nil && err2 != nil {
        _write_err265 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err265 == nil && err2 != nil {
        _write_err265 = thrift.WrapTException(err2)
      }
      if _write_err265 != nil {
        return false, thrift.WrapTException(_write_err265)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "createTable", thrift.REPLY, seqId); err2 != nil {
    _write_err265 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err265 == nil && err2 != nil {
    _write_err265 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err265 == nil && err2 != nil {
    _write_err265 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err265 == nil && err2 != nil {
    _write_err265 = thrift.WrapTException(err2)
  }
  if _write_err265 != nil {
    return false, thrift.WrapTException(_write_err265)
  }
  return true, err
}

type tHBaseServiceProcessorDeleteTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err267 error
  args := THBaseServiceDeleteTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDeleteTableResult{}
  if err2 := p.handler.DeleteTable(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc268 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "deleteTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err267 = thrift.WrapTException(err2)
      }
      if err2 := _exc268.Write(ctx, oprot); _write_err267 == nil && err2 != nil {
        _write_err267 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err267 == nil && err2 != nil {
        _write_err267 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err267 == nil && err2 != nil {
        _write_err267 = thrift.WrapTException(err2)
      }
      if _write_err267 != nil {
        return false, thrift.WrapTException(_write_err267)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "deleteTable", thrift.REPLY, seqId); err2 != nil {
    _write_err267 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err267 == nil && err2 != nil {
    _write_err267 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err267 == nil && err2 != nil {
    _write_err267 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err267 == nil && err2 != nil {
    _write_err267 = thrift.WrapTException(err2)
  }
  if _write_err267 != nil {
    return false, thrift.WrapTException(_write_err267)
  }
  return true, err
}

type tHBaseServiceProcessorTruncateTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorTruncateTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err269 error
  args := THBaseServiceTruncateTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "truncateTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceTruncateTableResult{}
  if err2 := p.handler.TruncateTable(ctx, args.TableName, args.PreserveSplits); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc270 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncateTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "truncateTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err269 = thrift.WrapTException(err2)
      }
      if err2 := _exc270.Write(ctx, oprot); _write_err269 == nil && err2 != nil {
        _write_err269 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err269 == nil && err2 != nil {
        _write_err269 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err269 == nil && err2 != nil {
        _write_err269 = thrift.WrapTException(err2)
      }
      if _write_err269 != nil {
        return false, thrift.WrapTException(_write_err269)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "truncateTable", thrift.REPLY, seqId); err2 != nil {
    _write_err269 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err269 == nil && err2 != nil {
    _write_err269 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err269 == nil && err2 != nil {
    _write_err269 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err269 == nil && err2 != nil {
    _write_err269 = thrift.WrapTException(err2)
  }
  if _write_err269 != nil {
    return false, thrift.WrapTException(_write_err269)
  }
  return true, err
}

type tHBaseServiceProcessorEnableTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorEnableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err271 error
  args := THBaseServiceEnableTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enableTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceEnableTableResult{}
  if err2 := p.handler.EnableTable(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc272 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "enableTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err271 = thrift.WrapTException(err2)
      }
      if err2 := _exc272.Write(ctx, oprot); _write_err271 == nil && err2 != nil {
        _write_err271 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err271 == nil && err2 != nil {
        _write_err271 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err271 == nil && err2 != nil {
        _write_err271 = thrift.WrapTException(err2)
      }
      if _write_err271 != nil {
        return false, thrift.WrapTException(_write_err271)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "enableTable", thrift.REPLY, seqId); err2 != nil {
    _write_err271 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err271 == nil && err2 != nil {
    _write_err271 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err271 == nil && err2 != nil {
    _write_err271 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err271 == nil && err2 != nil {
    _write_err271 = thrift.WrapTException(err2)
  }
  if _write_err271 != nil {
    return false, thrift.WrapTException(_write_err271)
  }
  return true, err
}

type tHBaseServiceProcessorDisableTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDisableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err273 error
  args := THBaseServiceDisableTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "disableTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDisableTableResult{}
  if err2 := p.handler.DisableTable(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc274 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "disableTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err273 = thrift.WrapTException(err2)
      }
      if err2 := _exc274.Write(ctx, oprot); _write_err273 == nil && err2 != nil {
        _write_err273 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err273 == nil && err2 != nil {
        _write_err273 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err273 == nil && err2 != nil {
        _write_err273 = thrift.WrapTException(err2)
      }
      if _write_err273 != nil {
        return false, thrift.WrapTException(_write_err273)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "disableTable", thrift.REPLY, seqId); err2 != nil {
    _write_err273 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err273 == nil && err2 != nil {
    _write_err273 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err273 == nil && err2 != nil {
    _write_err273 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err273 == nil && err2 != nil {
    _write_err273 = thrift.WrapTException(err2)
  }
  if _write_err273 != nil {
    return false, thrift.WrapTException(_write_err273)
  }
  return true, err
}

type tHBaseServiceProcessorIsTableEnabled struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err275 error
  args := THBaseServiceIsTableEnabledArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceIsTableEnabledResult{}
  if retval, err2 := p.handler.IsTableEnabled(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc276 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err275 = thrift.WrapTException(err2)
      }
      if err2 := _exc276.Write(ctx, oprot); _write_err275 == nil && err2 != nil {
        _write_err275 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err275 == nil && err2 != nil {
        _write_err275 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err275 == nil && err2 != nil {
        _write_err275 = thrift.WrapTException(err2)
      }
      if _write_err275 != nil {
        return false, thrift.WrapTException(_write_err275)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "isTableEnabled", thrift.REPLY, seqId); err2 != nil {
    _write_err275 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err275 == nil && err2 != nil {
    _write_err275 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err275 == nil && err2 != nil {
    _write_err275 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err275 == nil && err2 != nil {
    _write_err275 = thrift.WrapTException(err2)
  }
  if _write_err275 != nil {
    return false, thrift.WrapTException(_write_err275)
  }
  return true, err
}

type tHBaseServiceProcessorIsTableDisabled struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableDisabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err277 error
  args := THBaseServiceIsTableDisabledArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceIsTableDisabledResult{}
  if retval, err2 := p.handler.IsTableDisabled(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc278 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableDisabled: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err277 = thrift.WrapTException(err2)
      }
      if err2 := _exc278.Write(ctx, oprot); _write_err277 == nil && err2 != nil {
        _write_err277 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err277 == nil && err2 != nil {
        _write_err277 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err277 == nil && err2 != nil {
        _write_err277 = thrift.WrapTException(err2)
      }
      if _write_err277 != nil {
        return false, thrift.WrapTException(_write_err277)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "isTableDisabled", thrift.REPLY, seqId); err2 != nil {
    _write_err277 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err277 == nil && err2 != nil {
    _write_err277 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err277 == nil && err2 != nil {
    _write_err277 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err277 == nil && err2 != nil {
    _write_err277 = thrift.WrapTException(err2)
  }
  if _write_err277 != nil {
    return false, thrift.WrapTException(_write_err277)
  }
  return true, err
}

type tHBaseServiceProcessorIsTableAvailable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err279 error
  args := THBaseServiceIsTableAvailableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceIsTableAvailableResult{}
  if retval, err2 := p.handler.IsTableAvailable(ctx, args.TableName); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc280 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err279 = thrift.WrapTException(err2)
      }
      if err2 := _exc280.Write(ctx, oprot); _write_err279 == nil && err2 != nil {
        _write_err279 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err279 == nil && err2 != nil {
        _write_err279 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err279 == nil && err2 != nil {
        _write_err279 = thrift.WrapTException(err2)
      }
      if _write_err279 != nil {
        return false, thrift.WrapTException(_write_err279)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailable", thrift.REPLY, seqId); err2 != nil {
    _write_err279 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err279 == nil && err2 != nil {
    _write_err279 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err279 == nil && err2 != nil {
    _write_err279 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err279 == nil && err2 != nil {
    _write_err279 = thrift.WrapTException(err2)
  }
  if _write_err279 != nil {
    return false, thrift.WrapTException(_write_err279)
  }
  return true, err
}

type tHBaseServiceProcessorIsTableAvailableWithSplit struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailableWithSplit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err281 error
  args := THBaseServiceIsTableAvailableWithSplitArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceIsTableAvailableWithSplitResult{}
  if retval, err2 := p.handler.IsTableAvailableWithSplit(ctx, args.TableName, args.SplitKeys); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc282 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailableWithSplit: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err281 = thrift.WrapTException(err2)
      }
      if err2 := _exc282.Write(ctx, oprot); _write_err281 == nil && err2 != nil {
        _write_err281 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err281 == nil && err2 != nil {
        _write_err281 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err281 == nil && err2 != nil {
        _write_err281 = thrift.WrapTException(err2)
      }
      if _write_err281 != nil {
        return false, thrift.WrapTException(_write_err281)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "isTableAvailableWithSplit", thrift.REPLY, seqId); err2 != nil {
    _write_err281 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err281 == nil && err2 != nil {
    _write_err281 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err281 == nil && err2 != nil {
    _write_err281 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err281 == nil && err2 != nil {
    _write_err281 = thrift.WrapTException(err2)
  }
  if _write_err281 != nil {
    return false, thrift.WrapTException(_write_err281)
  }
  return true, err
}

type tHBaseServiceProcessorAddColumnFamily struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorAddColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err283 error
  args := THBaseServiceAddColumnFamilyArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceAddColumnFamilyResult{}
  if err2 := p.handler.AddColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc284 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addColumnFamily: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err283 = thrift.WrapTException(err2)
      }
      if err2 := _exc284.Write(ctx, oprot); _write_err283 == nil && err2 != nil {
        _write_err283 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err283 == nil && err2 != nil {
        _write_err283 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err283 == nil && err2 != nil {
        _write_err283 = thrift.WrapTException(err2)
      }
      if _write_err283 != nil {
        return false, thrift.WrapTException(_write_err283)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "addColumnFamily", thrift.REPLY, seqId); err2 != nil {
    _write_err283 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err283 == nil && err2 != nil {
    _write_err283 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err283 == nil && err2 != nil {
    _write_err283 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err283 == nil && err2 != nil {
    _write_err283 = thrift.WrapTException(err2)
  }
  if _write_err283 != nil {
    return false, thrift.WrapTException(_write_err283)
  }
  return true, err
}

type tHBaseServiceProcessorDeleteColumnFamily struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err285 error
  args := THBaseServiceDeleteColumnFamilyArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDeleteColumnFamilyResult{}
  if err2 := p.handler.DeleteColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc286 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteColumnFamily: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err285 = thrift.WrapTException(err2)
      }
      if err2 := _exc286.Write(ctx, oprot); _write_err285 == nil && err2 != nil {
        _write_err285 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err285 == nil && err2 != nil {
        _write_err285 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err285 == nil && err2 != nil {
        _write_err285 = thrift.WrapTException(err2)
      }
      if _write_err285 != nil {
        return false, thrift.WrapTException(_write_err285)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "deleteColumnFamily", thrift.REPLY, seqId); err2 != nil {
    _write_err285 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err285 == nil && err2 != nil {
    _write_err285 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err285 == nil && err2 != nil {
    _write_err285 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err285 == nil && err2 != nil {
    _write_err285 = thrift.WrapTException(err2)
  }
  if _write_err285 != nil {
    return false, thrift.WrapTException(_write_err285)
  }
  return true, err
}

type tHBaseServiceProcessorModifyColumnFamily struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorModifyColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err287 error
  args := THBaseServiceModifyColumnFamilyArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceModifyColumnFamilyResult{}
  if err2 := p.handler.ModifyColumnFamily(ctx, args.TableName, args.Column); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc288 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyColumnFamily: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err287 = thrift.WrapTException(err2)
      }
      if err2 := _exc288.Write(ctx, oprot); _write_err287 == nil && err2 != nil {
        _write_err287 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err287 == nil && err2 != nil {
        _write_err287 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err287 == nil && err2 != nil {
        _write_err287 = thrift.WrapTException(err2)
      }
      if _write_err287 != nil {
        return false, thrift.WrapTException(_write_err287)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "modifyColumnFamily", thrift.REPLY, seqId); err2 != nil {
    _write_err287 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err287 == nil && err2 != nil {
    _write_err287 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err287 == nil && err2 != nil {
    _write_err287 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err287 == nil && err2 != nil {
    _write_err287 = thrift.WrapTException(err2)
  }
  if _write_err287 != nil {
    return false, thrift.WrapTException(_write_err287)
  }
  return true, err
}

type tHBaseServiceProcessorModifyTable struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorModifyTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err289 error
  args := THBaseServiceModifyTableArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "modifyTable", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceModifyTableResult{}
  if err2 := p.handler.ModifyTable(ctx, args.Desc); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc290 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyTable: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "modifyTable", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err289 = thrift.WrapTException(err2)
      }
      if err2 := _exc290.Write(ctx, oprot); _write_err289 == nil && err2 != nil {
        _write_err289 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err289 == nil && err2 != nil {
        _write_err289 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err289 == nil && err2 != nil {
        _write_err289 = thrift.WrapTException(err2)
      }
      if _write_err289 != nil {
        return false, thrift.WrapTException(_write_err289)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "modifyTable", thrift.REPLY, seqId); err2 != nil {
    _write_err289 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err289 == nil && err2 != nil {
    _write_err289 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err289 == nil && err2 != nil {
    _write_err289 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err289 == nil && err2 != nil {
    _write_err289 = thrift.WrapTException(err2)
  }
  if _write_err289 != nil {
    return false, thrift.WrapTException(_write_err289)
  }
  return true, err
}

type tHBaseServiceProcessorCreateNamespace struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorCreateNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err291 error
  args := THBaseServiceCreateNamespaceArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createNamespace", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceCreateNamespaceResult{}
  if err2 := p.handler.CreateNamespace(ctx, args.NamespaceDesc); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc292 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNamespace: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "createNamespace", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err291 = thrift.WrapTException(err2)
      }
      if err2 := _exc292.Write(ctx, oprot); _write_err291 == nil && err2 != nil {
        _write_err291 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err291 == nil && err2 != nil {
        _write_err291 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err291 == nil && err2 != nil {
        _write_err291 = thrift.WrapTException(err2)
      }
      if _write_err291 != nil {
        return false, thrift.WrapTException(_write_err291)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "createNamespace", thrift.REPLY, seqId); err2 != nil {
    _write_err291 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err291 == nil && err2 != nil {
    _write_err291 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err291 == nil && err2 != nil {
    _write_err291 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err291 == nil && err2 != nil {
    _write_err291 = thrift.WrapTException(err2)
  }
  if _write_err291 != nil {
    return false, thrift.WrapTException(_write_err291)
  }
  return true, err
}

type tHBaseServiceProcessorModifyNamespace struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorModifyNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err293 error
  args := THBaseServiceModifyNamespaceArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceModifyNamespaceResult{}
  if err2 := p.handler.ModifyNamespace(ctx, args.NamespaceDesc); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc294 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyNamespace: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err293 = thrift.WrapTException(err2)
      }
      if err2 := _exc294.Write(ctx, oprot); _write_err293 == nil && err2 != nil {
        _write_err293 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err293 == nil && err2 != nil {
        _write_err293 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err293 == nil && err2 != nil {
        _write_err293 = thrift.WrapTException(err2)
      }
      if _write_err293 != nil {
        return false, thrift.WrapTException(_write_err293)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "modifyNamespace", thrift.REPLY, seqId); err2 != nil {
    _write_err293 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err293 == nil && err2 != nil {
    _write_err293 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err293 == nil && err2 != nil {
    _write_err293 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err293 == nil && err2 != nil {
    _write_err293 = thrift.WrapTException(err2)
  }
  if _write_err293 != nil {
    return false, thrift.WrapTException(_write_err293)
  }
  return true, err
}

type tHBaseServiceProcessorDeleteNamespace struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteNamespace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err295 error
  args := THBaseServiceDeleteNamespaceArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceDeleteNamespaceResult{}
  if err2 := p.handler.DeleteNamespace(ctx, args.Name); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc296 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNamespace: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err295 = thrift.WrapTException(err2)
      }
      if err2 := _exc296.Write(ctx, oprot); _write_err295 == nil && err2 != nil {
        _write_err295 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err295 == nil && err2 != nil {
        _write_err295 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err295 == nil && err2 != nil {
        _write_err295 = thrift.WrapTException(err2)
      }
      if _write_err295 != nil {
        return false, thrift.WrapTException(_write_err295)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "deleteNamespace", thrift.REPLY, seqId); err2 != nil {
    _write_err295 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err295 == nil && err2 != nil {
    _write_err295 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err295 == nil && err2 != nil {
    _write_err295 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err295 == nil && err2 != nil {
    _write_err295 = thrift.WrapTException(err2)
  }
  if _write_err295 != nil {
    return false, thrift.WrapTException(_write_err295)
  }
  return true, err
}

type tHBaseServiceProcessorGetNamespaceDescriptor struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetNamespaceDescriptor) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err297 error
  args := THBaseServiceGetNamespaceDescriptorArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetNamespaceDescriptorResult{}
  if retval, err2 := p.handler.GetNamespaceDescriptor(ctx, args.Name); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc298 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNamespaceDescriptor: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err297 = thrift.WrapTException(err2)
      }
      if err2 := _exc298.Write(ctx, oprot); _write_err297 == nil && err2 != nil {
        _write_err297 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err297 == nil && err2 != nil {
        _write_err297 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err297 == nil && err2 != nil {
        _write_err297 = thrift.WrapTException(err2)
      }
      if _write_err297 != nil {
        return false, thrift.WrapTException(_write_err297)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getNamespaceDescriptor", thrift.REPLY, seqId); err2 != nil {
    _write_err297 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err297 == nil && err2 != nil {
    _write_err297 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err297 == nil && err2 != nil {
    _write_err297 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err297 == nil && err2 != nil {
    _write_err297 = thrift.WrapTException(err2)
  }
  if _write_err297 != nil {
    return false, thrift.WrapTException(_write_err297)
  }
  return true, err
}

type tHBaseServiceProcessorListNamespaceDescriptors struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaceDescriptors) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err299 error
  args := THBaseServiceListNamespaceDescriptorsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceListNamespaceDescriptorsResult{}
  if retval, err2 := p.handler.ListNamespaceDescriptors(ctx); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc300 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaceDescriptors: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err299 = thrift.WrapTException(err2)
      }
      if err2 := _exc300.Write(ctx, oprot); _write_err299 == nil && err2 != nil {
        _write_err299 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err299 == nil && err2 != nil {
        _write_err299 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err299 == nil && err2 != nil {
        _write_err299 = thrift.WrapTException(err2)
      }
      if _write_err299 != nil {
        return false, thrift.WrapTException(_write_err299)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "listNamespaceDescriptors", thrift.REPLY, seqId); err2 != nil {
    _write_err299 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err299 == nil && err2 != nil {
    _write_err299 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err299 == nil && err2 != nil {
    _write_err299 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err299 == nil && err2 != nil {
    _write_err299 = thrift.WrapTException(err2)
  }
  if _write_err299 != nil {
    return false, thrift.WrapTException(_write_err299)
  }
  return true, err
}

type tHBaseServiceProcessorListNamespaces struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaces) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err301 error
  args := THBaseServiceListNamespacesArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listNamespaces", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceListNamespacesResult{}
  if retval, err2 := p.handler.ListNamespaces(ctx); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc302 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaces: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "listNamespaces", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err301 = thrift.WrapTException(err2)
      }
      if err2 := _exc302.Write(ctx, oprot); _write_err301 == nil && err2 != nil {
        _write_err301 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err301 == nil && err2 != nil {
        _write_err301 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err301 == nil && err2 != nil {
        _write_err301 = thrift.WrapTException(err2)
      }
      if _write_err301 != nil {
        return false, thrift.WrapTException(_write_err301)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "listNamespaces", thrift.REPLY, seqId); err2 != nil {
    _write_err301 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err301 == nil && err2 != nil {
    _write_err301 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err301 == nil && err2 != nil {
    _write_err301 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err301 == nil && err2 != nil {
    _write_err301 = thrift.WrapTException(err2)
  }
  if _write_err301 != nil {
    return false, thrift.WrapTException(_write_err301)
  }
  return true, err
}

type tHBaseServiceProcessorGetThriftServerType struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetThriftServerType) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err303 error
  args := THBaseServiceGetThriftServerTypeArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getThriftServerType", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetThriftServerTypeResult{}
  if retval, err2 := p.handler.GetThriftServerType(ctx); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    if errors.Is(err2, thrift.ErrAbandonRequest) {
      return false, thrift.WrapTException(err2)
    }
    _exc304 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getThriftServerType: " + err2.Error())
    if err2 := oprot.WriteMessageBegin(ctx, "getThriftServerType", thrift.EXCEPTION, seqId); err2 != nil {
      _write_err303 = thrift.WrapTException(err2)
    }
    if err2 := _exc304.Write(ctx, oprot); _write_err303 == nil && err2 != nil {
      _write_err303 = thrift.WrapTException(err2)
    }
    if err2 := oprot.WriteMessageEnd(ctx); _write_err303 == nil && err2 != nil {
      _write_err303 = thrift.WrapTException(err2)
    }
    if err2 := oprot.Flush(ctx); _write_err303 == nil && err2 != nil {
      _write_err303 = thrift.WrapTException(err2)
    }
    if _write_err303 != nil {
      return false, thrift.WrapTException(_write_err303)
    }
    return true, err
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getThriftServerType", thrift.REPLY, seqId); err2 != nil {
    _write_err303 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err303 == nil && err2 != nil {
    _write_err303 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err303 == nil && err2 != nil {
    _write_err303 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err303 == nil && err2 != nil {
    _write_err303 = thrift.WrapTException(err2)
  }
  if _write_err303 != nil {
    return false, thrift.WrapTException(_write_err303)
  }
  return true, err
}

type tHBaseServiceProcessorGetSlowLogResponses struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetSlowLogResponses) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err305 error
  args := THBaseServiceGetSlowLogResponsesArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getSlowLogResponses", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetSlowLogResponsesResult{}
  if retval, err2 := p.handler.GetSlowLogResponses(ctx, args.ServerNames, args.LogQueryFilter); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc306 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSlowLogResponses: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "getSlowLogResponses", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err305 = thrift.WrapTException(err2)
      }
      if err2 := _exc306.Write(ctx, oprot); _write_err305 == nil && err2 != nil {
        _write_err305 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err305 == nil && err2 != nil {
        _write_err305 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err305 == nil && err2 != nil {
        _write_err305 = thrift.WrapTException(err2)
      }
      if _write_err305 != nil {
        return false, thrift.WrapTException(_write_err305)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getSlowLogResponses", thrift.REPLY, seqId); err2 != nil {
    _write_err305 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err305 == nil && err2 != nil {
    _write_err305 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err305 == nil && err2 != nil {
    _write_err305 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err305 == nil && err2 != nil {
    _write_err305 = thrift.WrapTException(err2)
  }
  if _write_err305 != nil {
    return false, thrift.WrapTException(_write_err305)
  }
  return true, err
}

type tHBaseServiceProcessorClearSlowLogResponses struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorClearSlowLogResponses) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err307 error
  args := THBaseServiceClearSlowLogResponsesArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "clearSlowLogResponses", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceClearSlowLogResponsesResult{}
  if retval, err2 := p.handler.ClearSlowLogResponses(ctx, args.ServerNames); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *TIOError:
      result.Io = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      _exc308 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing clearSlowLogResponses: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "clearSlowLogResponses", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err307 = thrift.WrapTException(err2)
      }
      if err2 := _exc308.Write(ctx, oprot); _write_err307 == nil && err2 != nil {
        _write_err307 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err307 == nil && err2 != nil {
        _write_err307 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err307 == nil && err2 != nil {
        _write_err307 = thrift.WrapTException(err2)
      }
      if _write_err307 != nil {
        return false, thrift.WrapTException(_write_err307)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "clearSlowLogResponses", thrift.REPLY, seqId); err2 != nil {
    _write_err307 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err307 == nil && err2 != nil {
    _write_err307 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err307 == nil && err2 != nil {
    _write_err307 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err307 == nil && err2 != nil {
    _write_err307 = thrift.WrapTException(err2)
  }
  if _write_err307 != nil {
    return false, thrift.WrapTException(_write_err307)
  }
  return true, err
}

type tHBaseServiceProcessorGetClusterId struct {
  handler THBaseService
}

func (p *tHBaseServiceProcessorGetClusterId) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err309 error
  args := THBaseServiceGetClusterIdArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getClusterId", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := THBaseServiceGetClusterIdResult{}
  if retval, err2 := p.handler.GetClusterId(ctx); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    if errors.Is(err2, thrift.ErrAbandonRequest) {
      return false, thrift.WrapTException(err2)
    }
    _exc310 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getClusterId: " + err2.Error())
    if err2 := oprot.WriteMessageBegin(ctx, "getClusterId", thrift.EXCEPTION, seqId); err2 != nil {
      _write_err309 = thrift.WrapTException(err2)
    }
    if err2 := _exc310.Write(ctx, oprot); _write_err309 == nil && err2 != nil {
      _write_err309 = thrift.WrapTException(err2)
    }
    if err2 := oprot.WriteMessageEnd(ctx); _write_err309 == nil && err2 != nil {
      _write_err309 = thrift.WrapTException(err2)
    }
    if err2 := oprot.Flush(ctx); _write_err309 == nil && err2 != nil {
      _write_err309 = thrift.WrapTException(err2)
    }
    if _write_err309 != nil {
      return false, thrift.WrapTException(_write_err309)
    }
    return true, err
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "getClusterId", thrift.REPLY, seqId); err2 != nil {
    _write_err309 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err309 == nil && err2 != nil {
    _write_err309 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err309 == nil && err2 != nil {
    _write_err309 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err309 == nil && err2 != nil {
    _write_err309 = thrift.WrapTException(err2)
  }
  if _write_err309 != nil {
    return false, thrift.WrapTException(_write_err309)
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Table: the table to check on
//  - Tget: the TGet to check for
type THBaseServiceExistsArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tget *TGet `thrift:"tget,2,required" db:"tget" json:"tget"`
}

func NewTHBaseServiceExistsArgs() *THBaseServiceExistsArgs {
  return &THBaseServiceExistsArgs{}
}


func (p *THBaseServiceExistsArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceExistsArgs_Tget_DEFAULT *TGet
func (p *THBaseServiceExistsArgs) GetTget() *TGet {
  if !p.IsSetTget() {
    return THBaseServiceExistsArgs_Tget_DEFAULT
  }
return p.Tget
}
func (p *THBaseServiceExistsArgs) IsSetTget() bool {
  return p.Tget != nil
}

func (p *THBaseServiceExistsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTget bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTget = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTget{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"));
  }
  return nil
}

func (p *THBaseServiceExistsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceExistsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tget = &TGet{}
  if err := p.Tget.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
  }
  return nil
}

func (p *THBaseServiceExistsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exists_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceExistsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceExistsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tget", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err) }
  if err := p.Tget.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err) }
  return err
}

func (p *THBaseServiceExistsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceExistsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceExistsResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceExistsResult() *THBaseServiceExistsResult {
  return &THBaseServiceExistsResult{}
}

var THBaseServiceExistsResult_Success_DEFAULT bool
func (p *THBaseServiceExistsResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceExistsResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceExistsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceExistsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceExistsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceExistsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceExistsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceExistsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceExistsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceExistsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceExistsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exists_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceExistsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceExistsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceExistsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceExistsResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to check on
//  - Tgets: a list of TGets to check for
type THBaseServiceExistsAllArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tgets []*TGet `thrift:"tgets,2,required" db:"tgets" json:"tgets"`
}

func NewTHBaseServiceExistsAllArgs() *THBaseServiceExistsAllArgs {
  return &THBaseServiceExistsAllArgs{}
}


func (p *THBaseServiceExistsAllArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceExistsAllArgs) GetTgets() []*TGet {
  return p.Tgets
}
func (p *THBaseServiceExistsAllArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTgets bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTgets = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTgets{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"));
  }
  return nil
}

func (p *THBaseServiceExistsAllArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceExistsAllArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TGet, 0, size)
  p.Tgets =  tSlice
  for i := 0; i < size; i ++ {
    _elem311 := &TGet{}
    if err := _elem311.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem311), err)
    }
    p.Tgets = append(p.Tgets, _elem311)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceExistsAllArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "existsAll_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceExistsAllArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceExistsAllArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tgets", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tgets)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tgets {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err) }
  return err
}

func (p *THBaseServiceExistsAllArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceExistsAllArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceExistsAllResult struct {
  Success []bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceExistsAllResult() *THBaseServiceExistsAllResult {
  return &THBaseServiceExistsAllResult{}
}

var THBaseServiceExistsAllResult_Success_DEFAULT []bool

func (p *THBaseServiceExistsAllResult) GetSuccess() []bool {
  return p.Success
}
var THBaseServiceExistsAllResult_Io_DEFAULT *TIOError
func (p *THBaseServiceExistsAllResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceExistsAllResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceExistsAllResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceExistsAllResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceExistsAllResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceExistsAllResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]bool, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem312 bool
    if v, err := iprot.ReadBool(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem312 = v
}
    p.Success = append(p.Success, _elem312)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceExistsAllResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceExistsAllResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "existsAll_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceExistsAllResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.BOOL, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBool(ctx, bool(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceExistsAllResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceExistsAllResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceExistsAllResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get from
//  - Tget: the TGet to fetch
type THBaseServiceGetArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tget *TGet `thrift:"tget,2,required" db:"tget" json:"tget"`
}

func NewTHBaseServiceGetArgs() *THBaseServiceGetArgs {
  return &THBaseServiceGetArgs{}
}


func (p *THBaseServiceGetArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceGetArgs_Tget_DEFAULT *TGet
func (p *THBaseServiceGetArgs) GetTget() *TGet {
  if !p.IsSetTget() {
    return THBaseServiceGetArgs_Tget_DEFAULT
  }
return p.Tget
}
func (p *THBaseServiceGetArgs) IsSetTget() bool {
  return p.Tget != nil
}

func (p *THBaseServiceGetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTget bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTget = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTget{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"));
  }
  return nil
}

func (p *THBaseServiceGetArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceGetArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tget = &TGet{}
  if err := p.Tget.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
  }
  return nil
}

func (p *THBaseServiceGetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tget", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err) }
  if err := p.Tget.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err) }
  return err
}

func (p *THBaseServiceGetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetResult struct {
  Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetResult() *THBaseServiceGetResult {
  return &THBaseServiceGetResult{}
}

var THBaseServiceGetResult_Success_DEFAULT *TResult_
func (p *THBaseServiceGetResult) GetSuccess() *TResult_ {
  if !p.IsSetSuccess() {
    return THBaseServiceGetResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceGetResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &TResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceGetResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "get_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get from
//  - Tgets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
type THBaseServiceGetMultipleArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tgets []*TGet `thrift:"tgets,2,required" db:"tgets" json:"tgets"`
}

func NewTHBaseServiceGetMultipleArgs() *THBaseServiceGetMultipleArgs {
  return &THBaseServiceGetMultipleArgs{}
}


func (p *THBaseServiceGetMultipleArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceGetMultipleArgs) GetTgets() []*TGet {
  return p.Tgets
}
func (p *THBaseServiceGetMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTgets bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTgets = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTgets{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"));
  }
  return nil
}

func (p *THBaseServiceGetMultipleArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceGetMultipleArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TGet, 0, size)
  p.Tgets =  tSlice
  for i := 0; i < size; i ++ {
    _elem313 := &TGet{}
    if err := _elem313.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem313), err)
    }
    p.Tgets = append(p.Tgets, _elem313)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getMultiple_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tgets", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tgets)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tgets {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err) }
  return err
}

func (p *THBaseServiceGetMultipleArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetMultipleResult struct {
  Success []*TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetMultipleResult() *THBaseServiceGetMultipleResult {
  return &THBaseServiceGetMultipleResult{}
}

var THBaseServiceGetMultipleResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetMultipleResult) GetSuccess() []*TResult_ {
  return p.Success
}
var THBaseServiceGetMultipleResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetMultipleResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetMultipleResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetMultipleResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetMultipleResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetMultipleResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TResult_, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem314 := &TResult_{}
    if err := _elem314.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem314), err)
    }
    p.Success = append(p.Success, _elem314)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetMultipleResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getMultiple_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetMultipleResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetMultipleResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to put data in
//  - Tput: the TPut to put
type THBaseServicePutArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tput *TPut `thrift:"tput,2,required" db:"tput" json:"tput"`
}

func NewTHBaseServicePutArgs() *THBaseServicePutArgs {
  return &THBaseServicePutArgs{}
}


func (p *THBaseServicePutArgs) GetTable() []byte {
  return p.Table
}
var THBaseServicePutArgs_Tput_DEFAULT *TPut
func (p *THBaseServicePutArgs) GetTput() *TPut {
  if !p.IsSetTput() {
    return THBaseServicePutArgs_Tput_DEFAULT
  }
return p.Tput
}
func (p *THBaseServicePutArgs) IsSetTput() bool {
  return p.Tput != nil
}

func (p *THBaseServicePutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTput bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTput = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTput{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"));
  }
  return nil
}

func (p *THBaseServicePutArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServicePutArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tput = &TPut{}
  if err := p.Tput.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
  }
  return nil
}

func (p *THBaseServicePutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "put_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServicePutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServicePutArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tput", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tput: ", p), err) }
  if err := p.Tput.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tput: ", p), err) }
  return err
}

func (p *THBaseServicePutArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServicePutArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServicePutResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServicePutResult() *THBaseServicePutResult {
  return &THBaseServicePutResult{}
}

var THBaseServicePutResult_Io_DEFAULT *TIOError
func (p *THBaseServicePutResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServicePutResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServicePutResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServicePutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServicePutResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServicePutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "put_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServicePutResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServicePutResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServicePutResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tput: the TPut to put if the check succeeds
type THBaseServiceCheckAndPutArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Row []byte `thrift:"row,2,required" db:"row" json:"row"`
  Family []byte `thrift:"family,3,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
  Value []byte `thrift:"value,5" db:"value" json:"value"`
  Tput *TPut `thrift:"tput,6,required" db:"tput" json:"tput"`
}

func NewTHBaseServiceCheckAndPutArgs() *THBaseServiceCheckAndPutArgs {
  return &THBaseServiceCheckAndPutArgs{}
}


func (p *THBaseServiceCheckAndPutArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceCheckAndPutArgs) GetRow() []byte {
  return p.Row
}

func (p *THBaseServiceCheckAndPutArgs) GetFamily() []byte {
  return p.Family
}

func (p *THBaseServiceCheckAndPutArgs) GetQualifier() []byte {
  return p.Qualifier
}

func (p *THBaseServiceCheckAndPutArgs) GetValue() []byte {
  return p.Value
}
var THBaseServiceCheckAndPutArgs_Tput_DEFAULT *TPut
func (p *THBaseServiceCheckAndPutArgs) GetTput() *TPut {
  if !p.IsSetTput() {
    return THBaseServiceCheckAndPutArgs_Tput_DEFAULT
  }
return p.Tput
}
func (p *THBaseServiceCheckAndPutArgs) IsSetTput() bool {
  return p.Tput != nil
}

func (p *THBaseServiceCheckAndPutArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetRow bool = false;
  var issetFamily bool = false;
  var issetQualifier bool = false;
  var issetTput bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
        issetTput = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  if !issetTput{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"));
  }
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *THBaseServiceCheckAndPutArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tput = &TPut{}
  if err := p.Tput.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndPutArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndPut_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndPutArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tput", thrift.STRUCT, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tput: ", p), err) }
  if err := p.Tput.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tput: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndPutArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndPutArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndPutResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndPutResult() *THBaseServiceCheckAndPutResult {
  return &THBaseServiceCheckAndPutResult{}
}

var THBaseServiceCheckAndPutResult_Success_DEFAULT bool
func (p *THBaseServiceCheckAndPutResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceCheckAndPutResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceCheckAndPutResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCheckAndPutResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCheckAndPutResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceCheckAndPutResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceCheckAndPutResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCheckAndPutResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndPutResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceCheckAndPutResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndPutResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndPut_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndPutResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndPutResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndPutResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndPutResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to put data in
//  - Tputs: a list of TPuts to commit
type THBaseServicePutMultipleArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tputs []*TPut `thrift:"tputs,2,required" db:"tputs" json:"tputs"`
}

func NewTHBaseServicePutMultipleArgs() *THBaseServicePutMultipleArgs {
  return &THBaseServicePutMultipleArgs{}
}


func (p *THBaseServicePutMultipleArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServicePutMultipleArgs) GetTputs() []*TPut {
  return p.Tputs
}
func (p *THBaseServicePutMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTputs bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTputs = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTputs{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tputs is not set"));
  }
  return nil
}

func (p *THBaseServicePutMultipleArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServicePutMultipleArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TPut, 0, size)
  p.Tputs =  tSlice
  for i := 0; i < size; i ++ {
    _elem315 := &TPut{}
    if err := _elem315.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem315), err)
    }
    p.Tputs = append(p.Tputs, _elem315)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServicePutMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "putMultiple_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServicePutMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServicePutMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tputs", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tputs: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tputs)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tputs {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tputs: ", p), err) }
  return err
}

func (p *THBaseServicePutMultipleArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServicePutMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServicePutMultipleResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServicePutMultipleResult() *THBaseServicePutMultipleResult {
  return &THBaseServicePutMultipleResult{}
}

var THBaseServicePutMultipleResult_Io_DEFAULT *TIOError
func (p *THBaseServicePutMultipleResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServicePutMultipleResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServicePutMultipleResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServicePutMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServicePutMultipleResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServicePutMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "putMultiple_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServicePutMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServicePutMultipleResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServicePutMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to delete from
//  - Tdelete: the TDelete to delete
type THBaseServiceDeleteSingleArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tdelete *TDelete `thrift:"tdelete,2,required" db:"tdelete" json:"tdelete"`
}

func NewTHBaseServiceDeleteSingleArgs() *THBaseServiceDeleteSingleArgs {
  return &THBaseServiceDeleteSingleArgs{}
}


func (p *THBaseServiceDeleteSingleArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT *TDelete
func (p *THBaseServiceDeleteSingleArgs) GetTdelete() *TDelete {
  if !p.IsSetTdelete() {
    return THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT
  }
return p.Tdelete
}
func (p *THBaseServiceDeleteSingleArgs) IsSetTdelete() bool {
  return p.Tdelete != nil
}

func (p *THBaseServiceDeleteSingleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTdelete bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTdelete = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTdelete{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"));
  }
  return nil
}

func (p *THBaseServiceDeleteSingleArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceDeleteSingleArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tdelete = &TDelete{
  DeleteType: 1,
}
  if err := p.Tdelete.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
  }
  return nil
}

func (p *THBaseServiceDeleteSingleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteSingle_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteSingleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteSingleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tdelete", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdelete: ", p), err) }
  if err := p.Tdelete.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdelete: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteSingleArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteSingleArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteSingleResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteSingleResult() *THBaseServiceDeleteSingleResult {
  return &THBaseServiceDeleteSingleResult{}
}

var THBaseServiceDeleteSingleResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDeleteSingleResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDeleteSingleResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDeleteSingleResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDeleteSingleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDeleteSingleResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDeleteSingleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteSingle_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteSingleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteSingleResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteSingleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to delete from
//  - Tdeletes: list of TDeletes to delete
type THBaseServiceDeleteMultipleArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tdeletes []*TDelete `thrift:"tdeletes,2,required" db:"tdeletes" json:"tdeletes"`
}

func NewTHBaseServiceDeleteMultipleArgs() *THBaseServiceDeleteMultipleArgs {
  return &THBaseServiceDeleteMultipleArgs{}
}


func (p *THBaseServiceDeleteMultipleArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceDeleteMultipleArgs) GetTdeletes() []*TDelete {
  return p.Tdeletes
}
func (p *THBaseServiceDeleteMultipleArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTdeletes bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTdeletes = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTdeletes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdeletes is not set"));
  }
  return nil
}

func (p *THBaseServiceDeleteMultipleArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceDeleteMultipleArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TDelete, 0, size)
  p.Tdeletes =  tSlice
  for i := 0; i < size; i ++ {
    _elem316 := &TDelete{
    DeleteType: 1,
}
    if err := _elem316.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem316), err)
    }
    p.Tdeletes = append(p.Tdeletes, _elem316)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceDeleteMultipleArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteMultiple_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteMultipleArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteMultipleArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tdeletes", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdeletes: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tdeletes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tdeletes {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdeletes: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteMultipleArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceDeleteMultipleResult struct {
  Success []*TDelete `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteMultipleResult() *THBaseServiceDeleteMultipleResult {
  return &THBaseServiceDeleteMultipleResult{}
}

var THBaseServiceDeleteMultipleResult_Success_DEFAULT []*TDelete

func (p *THBaseServiceDeleteMultipleResult) GetSuccess() []*TDelete {
  return p.Success
}
var THBaseServiceDeleteMultipleResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDeleteMultipleResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDeleteMultipleResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDeleteMultipleResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceDeleteMultipleResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDeleteMultipleResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDeleteMultipleResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TDelete, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem317 := &TDelete{
    DeleteType: 1,
}
    if err := _elem317.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem317), err)
    }
    p.Success = append(p.Success, _elem317)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceDeleteMultipleResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDeleteMultipleResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteMultiple_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteMultipleResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteMultipleResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteMultipleResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tdelete: the TDelete to execute if the check succeeds
type THBaseServiceCheckAndDeleteArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Row []byte `thrift:"row,2,required" db:"row" json:"row"`
  Family []byte `thrift:"family,3,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
  Value []byte `thrift:"value,5" db:"value" json:"value"`
  Tdelete *TDelete `thrift:"tdelete,6,required" db:"tdelete" json:"tdelete"`
}

func NewTHBaseServiceCheckAndDeleteArgs() *THBaseServiceCheckAndDeleteArgs {
  return &THBaseServiceCheckAndDeleteArgs{}
}


func (p *THBaseServiceCheckAndDeleteArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceCheckAndDeleteArgs) GetRow() []byte {
  return p.Row
}

func (p *THBaseServiceCheckAndDeleteArgs) GetFamily() []byte {
  return p.Family
}

func (p *THBaseServiceCheckAndDeleteArgs) GetQualifier() []byte {
  return p.Qualifier
}

func (p *THBaseServiceCheckAndDeleteArgs) GetValue() []byte {
  return p.Value
}
var THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT *TDelete
func (p *THBaseServiceCheckAndDeleteArgs) GetTdelete() *TDelete {
  if !p.IsSetTdelete() {
    return THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT
  }
return p.Tdelete
}
func (p *THBaseServiceCheckAndDeleteArgs) IsSetTdelete() bool {
  return p.Tdelete != nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetRow bool = false;
  var issetFamily bool = false;
  var issetQualifier bool = false;
  var issetTdelete bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
        issetTdelete = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  if !issetTdelete{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"));
  }
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tdelete = &TDelete{
  DeleteType: 1,
}
  if err := p.Tdelete.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndDelete_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tdelete", thrift.STRUCT, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tdelete: ", p), err) }
  if err := p.Tdelete.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tdelete: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndDeleteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndDeleteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndDeleteResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndDeleteResult() *THBaseServiceCheckAndDeleteResult {
  return &THBaseServiceCheckAndDeleteResult{}
}

var THBaseServiceCheckAndDeleteResult_Success_DEFAULT bool
func (p *THBaseServiceCheckAndDeleteResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceCheckAndDeleteResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceCheckAndDeleteResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCheckAndDeleteResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCheckAndDeleteResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceCheckAndDeleteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceCheckAndDeleteResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCheckAndDeleteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndDeleteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceCheckAndDeleteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndDeleteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndDelete_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndDeleteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndDeleteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndDeleteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndDeleteResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to increment the value on
//  - Tincrement: the TIncrement to increment
type THBaseServiceIncrementArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tincrement *TIncrement `thrift:"tincrement,2,required" db:"tincrement" json:"tincrement"`
}

func NewTHBaseServiceIncrementArgs() *THBaseServiceIncrementArgs {
  return &THBaseServiceIncrementArgs{}
}


func (p *THBaseServiceIncrementArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceIncrementArgs_Tincrement_DEFAULT *TIncrement
func (p *THBaseServiceIncrementArgs) GetTincrement() *TIncrement {
  if !p.IsSetTincrement() {
    return THBaseServiceIncrementArgs_Tincrement_DEFAULT
  }
return p.Tincrement
}
func (p *THBaseServiceIncrementArgs) IsSetTincrement() bool {
  return p.Tincrement != nil
}

func (p *THBaseServiceIncrementArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTincrement bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTincrement = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTincrement{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tincrement is not set"));
  }
  return nil
}

func (p *THBaseServiceIncrementArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceIncrementArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tincrement = &TIncrement{}
  if err := p.Tincrement.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tincrement), err)
  }
  return nil
}

func (p *THBaseServiceIncrementArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "increment_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIncrementArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceIncrementArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tincrement", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tincrement: ", p), err) }
  if err := p.Tincrement.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tincrement), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tincrement: ", p), err) }
  return err
}

func (p *THBaseServiceIncrementArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIncrementArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIncrementResult struct {
  Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIncrementResult() *THBaseServiceIncrementResult {
  return &THBaseServiceIncrementResult{}
}

var THBaseServiceIncrementResult_Success_DEFAULT *TResult_
func (p *THBaseServiceIncrementResult) GetSuccess() *TResult_ {
  if !p.IsSetSuccess() {
    return THBaseServiceIncrementResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceIncrementResult_Io_DEFAULT *TIOError
func (p *THBaseServiceIncrementResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceIncrementResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceIncrementResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceIncrementResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceIncrementResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceIncrementResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &TResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceIncrementResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceIncrementResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "increment_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIncrementResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIncrementResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIncrementResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIncrementResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to append the value on
//  - Tappend: the TAppend to append
type THBaseServiceAppendArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tappend *TAppend `thrift:"tappend,2,required" db:"tappend" json:"tappend"`
}

func NewTHBaseServiceAppendArgs() *THBaseServiceAppendArgs {
  return &THBaseServiceAppendArgs{}
}


func (p *THBaseServiceAppendArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceAppendArgs_Tappend_DEFAULT *TAppend
func (p *THBaseServiceAppendArgs) GetTappend() *TAppend {
  if !p.IsSetTappend() {
    return THBaseServiceAppendArgs_Tappend_DEFAULT
  }
return p.Tappend
}
func (p *THBaseServiceAppendArgs) IsSetTappend() bool {
  return p.Tappend != nil
}

func (p *THBaseServiceAppendArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTappend bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTappend = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTappend{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tappend is not set"));
  }
  return nil
}

func (p *THBaseServiceAppendArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceAppendArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tappend = &TAppend{}
  if err := p.Tappend.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tappend), err)
  }
  return nil
}

func (p *THBaseServiceAppendArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "append_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceAppendArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceAppendArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tappend", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tappend: ", p), err) }
  if err := p.Tappend.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tappend), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tappend: ", p), err) }
  return err
}

func (p *THBaseServiceAppendArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceAppendArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceAppendResult struct {
  Success *TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceAppendResult() *THBaseServiceAppendResult {
  return &THBaseServiceAppendResult{}
}

var THBaseServiceAppendResult_Success_DEFAULT *TResult_
func (p *THBaseServiceAppendResult) GetSuccess() *TResult_ {
  if !p.IsSetSuccess() {
    return THBaseServiceAppendResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceAppendResult_Io_DEFAULT *TIOError
func (p *THBaseServiceAppendResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceAppendResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceAppendResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceAppendResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceAppendResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceAppendResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &TResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceAppendResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceAppendResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "append_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceAppendResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceAppendResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceAppendResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceAppendResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
type THBaseServiceOpenScannerArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tscan *TScan `thrift:"tscan,2,required" db:"tscan" json:"tscan"`
}

func NewTHBaseServiceOpenScannerArgs() *THBaseServiceOpenScannerArgs {
  return &THBaseServiceOpenScannerArgs{}
}


func (p *THBaseServiceOpenScannerArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceOpenScannerArgs_Tscan_DEFAULT *TScan
func (p *THBaseServiceOpenScannerArgs) GetTscan() *TScan {
  if !p.IsSetTscan() {
    return THBaseServiceOpenScannerArgs_Tscan_DEFAULT
  }
return p.Tscan
}
func (p *THBaseServiceOpenScannerArgs) IsSetTscan() bool {
  return p.Tscan != nil
}

func (p *THBaseServiceOpenScannerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTscan bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTscan = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTscan{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"));
  }
  return nil
}

func (p *THBaseServiceOpenScannerArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceOpenScannerArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tscan = &TScan{
  MaxVersions: 1,
}
  if err := p.Tscan.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
  }
  return nil
}

func (p *THBaseServiceOpenScannerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openScanner_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceOpenScannerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceOpenScannerArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tscan", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err) }
  if err := p.Tscan.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err) }
  return err
}

func (p *THBaseServiceOpenScannerArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceOpenScannerArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceOpenScannerResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceOpenScannerResult() *THBaseServiceOpenScannerResult {
  return &THBaseServiceOpenScannerResult{}
}

var THBaseServiceOpenScannerResult_Success_DEFAULT int32
func (p *THBaseServiceOpenScannerResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return THBaseServiceOpenScannerResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceOpenScannerResult_Io_DEFAULT *TIOError
func (p *THBaseServiceOpenScannerResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceOpenScannerResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceOpenScannerResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceOpenScannerResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceOpenScannerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceOpenScannerResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceOpenScannerResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceOpenScannerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openScanner_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceOpenScannerResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceOpenScannerResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceOpenScannerResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceOpenScannerResult(%+v)", *p)
}

// Attributes:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
type THBaseServiceGetScannerRowsArgs struct {
  ScannerId int32 `thrift:"scannerId,1,required" db:"scannerId" json:"scannerId"`
  NumRows int32 `thrift:"numRows,2" db:"numRows" json:"numRows"`
}

func NewTHBaseServiceGetScannerRowsArgs() *THBaseServiceGetScannerRowsArgs {
  return &THBaseServiceGetScannerRowsArgs{
NumRows: 1,
}
}


func (p *THBaseServiceGetScannerRowsArgs) GetScannerId() int32 {
  return p.ScannerId
}

func (p *THBaseServiceGetScannerRowsArgs) GetNumRows() int32 {
  return p.NumRows
}
func (p *THBaseServiceGetScannerRowsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetScannerId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetScannerId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetScannerId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"));
  }
  return nil
}

func (p *THBaseServiceGetScannerRowsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ScannerId = v
}
  return nil
}

func (p *THBaseServiceGetScannerRowsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NumRows = v
}
  return nil
}

func (p *THBaseServiceGetScannerRowsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getScannerRows_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetScannerRowsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scannerId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ScannerId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err) }
  return err
}

func (p *THBaseServiceGetScannerRowsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numRows", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numRows: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.NumRows)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numRows (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numRows: ", p), err) }
  return err
}

func (p *THBaseServiceGetScannerRowsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetScannerRowsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
//  - Ia: if the scannerId is invalid
type THBaseServiceGetScannerRowsResult struct {
  Success []*TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
  Ia *TIllegalArgument `thrift:"ia,2" db:"ia" json:"ia,omitempty"`
}

func NewTHBaseServiceGetScannerRowsResult() *THBaseServiceGetScannerRowsResult {
  return &THBaseServiceGetScannerRowsResult{}
}

var THBaseServiceGetScannerRowsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerRowsResult) GetSuccess() []*TResult_ {
  return p.Success
}
var THBaseServiceGetScannerRowsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetScannerRowsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetScannerRowsResult_Io_DEFAULT
  }
return p.Io
}
var THBaseServiceGetScannerRowsResult_Ia_DEFAULT *TIllegalArgument
func (p *THBaseServiceGetScannerRowsResult) GetIa() *TIllegalArgument {
  if !p.IsSetIa() {
    return THBaseServiceGetScannerRowsResult_Ia_DEFAULT
  }
return p.Ia
}
func (p *THBaseServiceGetScannerRowsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIa() bool {
  return p.Ia != nil
}

func (p *THBaseServiceGetScannerRowsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerRowsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TResult_, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem318 := &TResult_{}
    if err := _elem318.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem318), err)
    }
    p.Success = append(p.Success, _elem318)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetScannerRowsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerRowsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ia = &TIllegalArgument{}
  if err := p.Ia.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerRowsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getScannerRows_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetScannerRowsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIa() {
    if err := oprot.WriteFieldBegin(ctx, "ia", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err) }
    if err := p.Ia.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetScannerRowsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetScannerRowsResult(%+v)", *p)
}

// Attributes:
//  - ScannerId: the Id of the Scanner to close *
type THBaseServiceCloseScannerArgs struct {
  ScannerId int32 `thrift:"scannerId,1,required" db:"scannerId" json:"scannerId"`
}

func NewTHBaseServiceCloseScannerArgs() *THBaseServiceCloseScannerArgs {
  return &THBaseServiceCloseScannerArgs{}
}


func (p *THBaseServiceCloseScannerArgs) GetScannerId() int32 {
  return p.ScannerId
}
func (p *THBaseServiceCloseScannerArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetScannerId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetScannerId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetScannerId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"));
  }
  return nil
}

func (p *THBaseServiceCloseScannerArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ScannerId = v
}
  return nil
}

func (p *THBaseServiceCloseScannerArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeScanner_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCloseScannerArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "scannerId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ScannerId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err) }
  return err
}

func (p *THBaseServiceCloseScannerArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCloseScannerArgs(%+v)", *p)
}

// Attributes:
//  - Io
//  - Ia: if the scannerId is invalid
type THBaseServiceCloseScannerResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
  Ia *TIllegalArgument `thrift:"ia,2" db:"ia" json:"ia,omitempty"`
}

func NewTHBaseServiceCloseScannerResult() *THBaseServiceCloseScannerResult {
  return &THBaseServiceCloseScannerResult{}
}

var THBaseServiceCloseScannerResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCloseScannerResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCloseScannerResult_Io_DEFAULT
  }
return p.Io
}
var THBaseServiceCloseScannerResult_Ia_DEFAULT *TIllegalArgument
func (p *THBaseServiceCloseScannerResult) GetIa() *TIllegalArgument {
  if !p.IsSetIa() {
    return THBaseServiceCloseScannerResult_Ia_DEFAULT
  }
return p.Ia
}
func (p *THBaseServiceCloseScannerResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCloseScannerResult) IsSetIa() bool {
  return p.Ia != nil
}

func (p *THBaseServiceCloseScannerResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCloseScannerResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCloseScannerResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ia = &TIllegalArgument{}
  if err := p.Ia.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
  }
  return nil
}

func (p *THBaseServiceCloseScannerResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeScanner_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCloseScannerResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCloseScannerResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIa() {
    if err := oprot.WriteFieldBegin(ctx, "ia", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err) }
    if err := p.Ia.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCloseScannerResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCloseScannerResult(%+v)", *p)
}

// Attributes:
//  - Table: table to apply the mutations
//  - TrowMutations: mutations to apply
type THBaseServiceMutateRowArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  TrowMutations *TRowMutations `thrift:"trowMutations,2,required" db:"trowMutations" json:"trowMutations"`
}

func NewTHBaseServiceMutateRowArgs() *THBaseServiceMutateRowArgs {
  return &THBaseServiceMutateRowArgs{}
}


func (p *THBaseServiceMutateRowArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceMutateRowArgs_TrowMutations_DEFAULT *TRowMutations
func (p *THBaseServiceMutateRowArgs) GetTrowMutations() *TRowMutations {
  if !p.IsSetTrowMutations() {
    return THBaseServiceMutateRowArgs_TrowMutations_DEFAULT
  }
return p.TrowMutations
}
func (p *THBaseServiceMutateRowArgs) IsSetTrowMutations() bool {
  return p.TrowMutations != nil
}

func (p *THBaseServiceMutateRowArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTrowMutations bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTrowMutations = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTrowMutations{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TrowMutations is not set"));
  }
  return nil
}

func (p *THBaseServiceMutateRowArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceMutateRowArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.TrowMutations = &TRowMutations{}
  if err := p.TrowMutations.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TrowMutations), err)
  }
  return nil
}

func (p *THBaseServiceMutateRowArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mutateRow_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceMutateRowArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceMutateRowArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "trowMutations", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:trowMutations: ", p), err) }
  if err := p.TrowMutations.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TrowMutations), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:trowMutations: ", p), err) }
  return err
}

func (p *THBaseServiceMutateRowArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceMutateRowArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceMutateRowResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceMutateRowResult() *THBaseServiceMutateRowResult {
  return &THBaseServiceMutateRowResult{}
}

var THBaseServiceMutateRowResult_Io_DEFAULT *TIOError
func (p *THBaseServiceMutateRowResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceMutateRowResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceMutateRowResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceMutateRowResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceMutateRowResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceMutateRowResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mutateRow_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceMutateRowResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceMutateRowResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceMutateRowResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
type THBaseServiceGetScannerResultsArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Tscan *TScan `thrift:"tscan,2,required" db:"tscan" json:"tscan"`
  NumRows int32 `thrift:"numRows,3" db:"numRows" json:"numRows"`
}

func NewTHBaseServiceGetScannerResultsArgs() *THBaseServiceGetScannerResultsArgs {
  return &THBaseServiceGetScannerResultsArgs{
NumRows: 1,
}
}


func (p *THBaseServiceGetScannerResultsArgs) GetTable() []byte {
  return p.Table
}
var THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT *TScan
func (p *THBaseServiceGetScannerResultsArgs) GetTscan() *TScan {
  if !p.IsSetTscan() {
    return THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT
  }
return p.Tscan
}

func (p *THBaseServiceGetScannerResultsArgs) GetNumRows() int32 {
  return p.NumRows
}
func (p *THBaseServiceGetScannerResultsArgs) IsSetTscan() bool {
  return p.Tscan != nil
}

func (p *THBaseServiceGetScannerResultsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetTscan bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTscan = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetTscan{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"));
  }
  return nil
}

func (p *THBaseServiceGetScannerResultsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceGetScannerResultsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tscan = &TScan{
  MaxVersions: 1,
}
  if err := p.Tscan.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerResultsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NumRows = v
}
  return nil
}

func (p *THBaseServiceGetScannerResultsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getScannerResults_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetScannerResultsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tscan", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err) }
  if err := p.Tscan.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err) }
  return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numRows", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numRows: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.NumRows)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numRows (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numRows: ", p), err) }
  return err
}

func (p *THBaseServiceGetScannerResultsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetScannerResultsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetScannerResultsResult struct {
  Success []*TResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetScannerResultsResult() *THBaseServiceGetScannerResultsResult {
  return &THBaseServiceGetScannerResultsResult{}
}

var THBaseServiceGetScannerResultsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerResultsResult) GetSuccess() []*TResult_ {
  return p.Success
}
var THBaseServiceGetScannerResultsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetScannerResultsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetScannerResultsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetScannerResultsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetScannerResultsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetScannerResultsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerResultsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TResult_, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem319 := &TResult_{}
    if err := _elem319.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem319), err)
    }
    p.Success = append(p.Success, _elem319)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetScannerResultsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetScannerResultsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getScannerResults_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetScannerResultsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetScannerResultsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetScannerResultsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetScannerResultsResult(%+v)", *p)
}

// Attributes:
//  - Table
//  - Row
//  - Reload
type THBaseServiceGetRegionLocationArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Row []byte `thrift:"row,2,required" db:"row" json:"row"`
  Reload bool `thrift:"reload,3" db:"reload" json:"reload"`
}

func NewTHBaseServiceGetRegionLocationArgs() *THBaseServiceGetRegionLocationArgs {
  return &THBaseServiceGetRegionLocationArgs{}
}


func (p *THBaseServiceGetRegionLocationArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceGetRegionLocationArgs) GetRow() []byte {
  return p.Row
}

func (p *THBaseServiceGetRegionLocationArgs) GetReload() bool {
  return p.Reload
}
func (p *THBaseServiceGetRegionLocationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetRow bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  return nil
}

func (p *THBaseServiceGetRegionLocationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceGetRegionLocationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *THBaseServiceGetRegionLocationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Reload = v
}
  return nil
}

func (p *THBaseServiceGetRegionLocationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getRegionLocation_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetRegionLocationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err) }
  return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reload", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reload: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Reload)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reload (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reload: ", p), err) }
  return err
}

func (p *THBaseServiceGetRegionLocationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetRegionLocationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetRegionLocationResult struct {
  Success *THRegionLocation `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetRegionLocationResult() *THBaseServiceGetRegionLocationResult {
  return &THBaseServiceGetRegionLocationResult{}
}

var THBaseServiceGetRegionLocationResult_Success_DEFAULT *THRegionLocation
func (p *THBaseServiceGetRegionLocationResult) GetSuccess() *THRegionLocation {
  if !p.IsSetSuccess() {
    return THBaseServiceGetRegionLocationResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceGetRegionLocationResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetRegionLocationResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetRegionLocationResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetRegionLocationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetRegionLocationResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetRegionLocationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetRegionLocationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &THRegionLocation{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceGetRegionLocationResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetRegionLocationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getRegionLocation_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetRegionLocationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetRegionLocationResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetRegionLocationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetRegionLocationResult(%+v)", *p)
}

// Attributes:
//  - Table
type THBaseServiceGetAllRegionLocationsArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
}

func NewTHBaseServiceGetAllRegionLocationsArgs() *THBaseServiceGetAllRegionLocationsArgs {
  return &THBaseServiceGetAllRegionLocationsArgs{}
}


func (p *THBaseServiceGetAllRegionLocationsArgs) GetTable() []byte {
  return p.Table
}
func (p *THBaseServiceGetAllRegionLocationsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getAllRegionLocations_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetAllRegionLocationsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetAllRegionLocationsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetAllRegionLocationsResult struct {
  Success []*THRegionLocation `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetAllRegionLocationsResult() *THBaseServiceGetAllRegionLocationsResult {
  return &THBaseServiceGetAllRegionLocationsResult{}
}

var THBaseServiceGetAllRegionLocationsResult_Success_DEFAULT []*THRegionLocation

func (p *THBaseServiceGetAllRegionLocationsResult) GetSuccess() []*THRegionLocation {
  return p.Success
}
var THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetAllRegionLocationsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetAllRegionLocationsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*THRegionLocation, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem320 := &THRegionLocation{}
    if err := _elem320.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem320), err)
    }
    p.Success = append(p.Success, _elem320)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getAllRegionLocations_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetAllRegionLocationsResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - CompareOp: comparison to make on the value
//  - Value: the expected value to be compared against, if not provided the
// check is for the non-existence of the column in question
//  - RowMutations: row mutations to execute if the value matches
type THBaseServiceCheckAndMutateArgs struct {
  Table []byte `thrift:"table,1,required" db:"table" json:"table"`
  Row []byte `thrift:"row,2,required" db:"row" json:"row"`
  Family []byte `thrift:"family,3,required" db:"family" json:"family"`
  Qualifier []byte `thrift:"qualifier,4,required" db:"qualifier" json:"qualifier"`
  CompareOp TCompareOp `thrift:"compareOp,5,required" db:"compareOp" json:"compareOp"`
  Value []byte `thrift:"value,6" db:"value" json:"value"`
  RowMutations *TRowMutations `thrift:"rowMutations,7,required" db:"rowMutations" json:"rowMutations"`
}

func NewTHBaseServiceCheckAndMutateArgs() *THBaseServiceCheckAndMutateArgs {
  return &THBaseServiceCheckAndMutateArgs{}
}


func (p *THBaseServiceCheckAndMutateArgs) GetTable() []byte {
  return p.Table
}

func (p *THBaseServiceCheckAndMutateArgs) GetRow() []byte {
  return p.Row
}

func (p *THBaseServiceCheckAndMutateArgs) GetFamily() []byte {
  return p.Family
}

func (p *THBaseServiceCheckAndMutateArgs) GetQualifier() []byte {
  return p.Qualifier
}

func (p *THBaseServiceCheckAndMutateArgs) GetCompareOp() TCompareOp {
  return p.CompareOp
}

func (p *THBaseServiceCheckAndMutateArgs) GetValue() []byte {
  return p.Value
}
var THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT *TRowMutations
func (p *THBaseServiceCheckAndMutateArgs) GetRowMutations() *TRowMutations {
  if !p.IsSetRowMutations() {
    return THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT
  }
return p.RowMutations
}
func (p *THBaseServiceCheckAndMutateArgs) IsSetRowMutations() bool {
  return p.RowMutations != nil
}

func (p *THBaseServiceCheckAndMutateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;
  var issetRow bool = false;
  var issetFamily bool = false;
  var issetQualifier bool = false;
  var issetCompareOp bool = false;
  var issetRowMutations bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRow = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetFamily = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetQualifier = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
        issetCompareOp = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
        issetRowMutations = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  if !issetRow{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"));
  }
  if !issetFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"));
  }
  if !issetQualifier{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"));
  }
  if !issetCompareOp{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CompareOp is not set"));
  }
  if !issetRowMutations{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RowMutations is not set"));
  }
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Table = v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Row = v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Family = v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Qualifier = v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := TCompareOp(v)
  p.CompareOp = temp
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.RowMutations = &TRowMutations{}
  if err := p.RowMutations.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RowMutations), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndMutate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndMutateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Table); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "row", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Row); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "family", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Family); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "qualifier", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Qualifier); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "compareOp", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:compareOp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CompareOp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compareOp (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:compareOp: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:value: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rowMutations", thrift.STRUCT, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:rowMutations: ", p), err) }
  if err := p.RowMutations.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RowMutations), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:rowMutations: ", p), err) }
  return err
}

func (p *THBaseServiceCheckAndMutateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndMutateArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndMutateResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndMutateResult() *THBaseServiceCheckAndMutateResult {
  return &THBaseServiceCheckAndMutateResult{}
}

var THBaseServiceCheckAndMutateResult_Success_DEFAULT bool
func (p *THBaseServiceCheckAndMutateResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceCheckAndMutateResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceCheckAndMutateResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCheckAndMutateResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCheckAndMutateResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceCheckAndMutateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceCheckAndMutateResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCheckAndMutateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndMutateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceCheckAndMutateResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCheckAndMutateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkAndMutate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCheckAndMutateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndMutateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCheckAndMutateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCheckAndMutateResult(%+v)", *p)
}

// Attributes:
//  - Table: the tablename of the table to get tableDescriptor
type THBaseServiceGetTableDescriptorArgs struct {
  Table *TTableName `thrift:"table,1,required" db:"table" json:"table"`
}

func NewTHBaseServiceGetTableDescriptorArgs() *THBaseServiceGetTableDescriptorArgs {
  return &THBaseServiceGetTableDescriptorArgs{}
}

var THBaseServiceGetTableDescriptorArgs_Table_DEFAULT *TTableName
func (p *THBaseServiceGetTableDescriptorArgs) GetTable() *TTableName {
  if !p.IsSetTable() {
    return THBaseServiceGetTableDescriptorArgs_Table_DEFAULT
  }
return p.Table
}
func (p *THBaseServiceGetTableDescriptorArgs) IsSetTable() bool {
  return p.Table != nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTable bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTable = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTable{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Table = &TTableName{}
  if err := p.Table.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptor_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "table", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err) }
  if err := p.Table.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableDescriptorArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorResult struct {
  Success *TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorResult() *THBaseServiceGetTableDescriptorResult {
  return &THBaseServiceGetTableDescriptorResult{}
}

var THBaseServiceGetTableDescriptorResult_Success_DEFAULT *TTableDescriptor
func (p *THBaseServiceGetTableDescriptorResult) GetSuccess() *TTableDescriptor {
  if !p.IsSetSuccess() {
    return THBaseServiceGetTableDescriptorResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceGetTableDescriptorResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableDescriptorResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableDescriptorResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableDescriptorResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &TTableDescriptor{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptor_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorResult(%+v)", *p)
}

// Attributes:
//  - Tables: the tablename list of the tables to get tableDescriptor
type THBaseServiceGetTableDescriptorsArgs struct {
  Tables []*TTableName `thrift:"tables,1,required" db:"tables" json:"tables"`
}

func NewTHBaseServiceGetTableDescriptorsArgs() *THBaseServiceGetTableDescriptorsArgs {
  return &THBaseServiceGetTableDescriptorsArgs{}
}


func (p *THBaseServiceGetTableDescriptorsArgs) GetTables() []*TTableName {
  return p.Tables
}
func (p *THBaseServiceGetTableDescriptorsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTables bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTables = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTables{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tables is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableName, 0, size)
  p.Tables =  tSlice
  for i := 0; i < size; i ++ {
    _elem321 := &TTableName{}
    if err := _elem321.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem321), err)
    }
    p.Tables = append(p.Tables, _elem321)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptors_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tables", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tables: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tables)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tables {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tables: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableDescriptorsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsResult struct {
  Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsResult() *THBaseServiceGetTableDescriptorsResult {
  return &THBaseServiceGetTableDescriptorsResult{}
}

var THBaseServiceGetTableDescriptorsResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsResult) GetSuccess() []*TTableDescriptor {
  return p.Success
}
var THBaseServiceGetTableDescriptorsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableDescriptorsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableDescriptorsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableDescriptorsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableDescriptor, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem322 := &TTableDescriptor{}
    if err := _elem322.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem322), err)
    }
    p.Success = append(p.Success, _elem322)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptors_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename of the tables to check
type THBaseServiceTableExistsArgs struct {
  TableName *TTableName `thrift:"tableName,1" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceTableExistsArgs() *THBaseServiceTableExistsArgs {
  return &THBaseServiceTableExistsArgs{}
}

var THBaseServiceTableExistsArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceTableExistsArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceTableExistsArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceTableExistsArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceTableExistsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceTableExistsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceTableExistsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tableExists_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceTableExistsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceTableExistsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceTableExistsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceTableExistsResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceTableExistsResult() *THBaseServiceTableExistsResult {
  return &THBaseServiceTableExistsResult{}
}

var THBaseServiceTableExistsResult_Success_DEFAULT bool
func (p *THBaseServiceTableExistsResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceTableExistsResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceTableExistsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceTableExistsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceTableExistsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceTableExistsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceTableExistsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceTableExistsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceTableExistsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceTableExistsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceTableExistsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "tableExists_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceTableExistsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceTableExistsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceTableExistsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceTableExistsResult(%+v)", *p)
}

// Attributes:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableDescriptorsByPatternArgs struct {
  Regex string `thrift:"regex,1" db:"regex" json:"regex"`
  IncludeSysTables bool `thrift:"includeSysTables,2,required" db:"includeSysTables" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternArgs() *THBaseServiceGetTableDescriptorsByPatternArgs {
  return &THBaseServiceGetTableDescriptorsByPatternArgs{}
}


func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetRegex() string {
  return p.Regex
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetIncludeSysTables() bool {
  return p.IncludeSysTables
}
func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetIncludeSysTables bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetIncludeSysTables = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetIncludeSysTables{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Regex = v
}
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeSysTables = v
}
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByPattern_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "regex", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Regex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "includeSysTables", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IncludeSysTables)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsByPatternResult struct {
  Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternResult() *THBaseServiceGetTableDescriptorsByPatternResult {
  return &THBaseServiceGetTableDescriptorsByPatternResult{}
}

var THBaseServiceGetTableDescriptorsByPatternResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetSuccess() []*TTableDescriptor {
  return p.Success
}
var THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableDescriptor, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem323 := &TTableDescriptor{}
    if err := _elem323.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem323), err)
    }
    p.Success = append(p.Success, _elem323)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByPattern_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternResult(%+v)", *p)
}

// Attributes:
//  - Name: The namesapce's name
type THBaseServiceGetTableDescriptorsByNamespaceArgs struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceArgs() *THBaseServiceGetTableDescriptorsByNamespaceArgs {
  return &THBaseServiceGetTableDescriptorsByNamespaceArgs{}
}


func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) GetName() string {
  return p.Name
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByNamespace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsByNamespaceResult struct {
  Success []*TTableDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceResult() *THBaseServiceGetTableDescriptorsByNamespaceResult {
  return &THBaseServiceGetTableDescriptorsByNamespaceResult{}
}

var THBaseServiceGetTableDescriptorsByNamespaceResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetSuccess() []*TTableDescriptor {
  return p.Success
}
var THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableDescriptor, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem324 := &TTableDescriptor{}
    if err := _elem324.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem324), err)
    }
    p.Success = append(p.Success, _elem324)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableDescriptorsByNamespace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableNamesByPatternArgs struct {
  Regex string `thrift:"regex,1" db:"regex" json:"regex"`
  IncludeSysTables bool `thrift:"includeSysTables,2,required" db:"includeSysTables" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableNamesByPatternArgs() *THBaseServiceGetTableNamesByPatternArgs {
  return &THBaseServiceGetTableNamesByPatternArgs{}
}


func (p *THBaseServiceGetTableNamesByPatternArgs) GetRegex() string {
  return p.Regex
}

func (p *THBaseServiceGetTableNamesByPatternArgs) GetIncludeSysTables() bool {
  return p.IncludeSysTables
}
func (p *THBaseServiceGetTableNamesByPatternArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetIncludeSysTables bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetIncludeSysTables = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetIncludeSysTables{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Regex = v
}
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeSysTables = v
}
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableNamesByPattern_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "regex", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Regex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "includeSysTables", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IncludeSysTables)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableNamesByPatternArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableNamesByPatternResult struct {
  Success []*TTableName `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByPatternResult() *THBaseServiceGetTableNamesByPatternResult {
  return &THBaseServiceGetTableNamesByPatternResult{}
}

var THBaseServiceGetTableNamesByPatternResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByPatternResult) GetSuccess() []*TTableName {
  return p.Success
}
var THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableNamesByPatternResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableNamesByPatternResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableName, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem325 := &TTableName{}
    if err := _elem325.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem325), err)
    }
    p.Success = append(p.Success, _elem325)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableNamesByPattern_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableNamesByPatternResult(%+v)", *p)
}

// Attributes:
//  - Name: The namesapce's name
type THBaseServiceGetTableNamesByNamespaceArgs struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetTableNamesByNamespaceArgs() *THBaseServiceGetTableNamesByNamespaceArgs {
  return &THBaseServiceGetTableNamesByNamespaceArgs{}
}


func (p *THBaseServiceGetTableNamesByNamespaceArgs) GetName() string {
  return p.Name
}
func (p *THBaseServiceGetTableNamesByNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableNamesByNamespace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableNamesByNamespaceResult struct {
  Success []*TTableName `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByNamespaceResult() *THBaseServiceGetTableNamesByNamespaceResult {
  return &THBaseServiceGetTableNamesByNamespaceResult{}
}

var THBaseServiceGetTableNamesByNamespaceResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByNamespaceResult) GetSuccess() []*TTableName {
  return p.Success
}
var THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetTableNamesByNamespaceResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TTableName, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem326 := &TTableName{}
    if err := _elem326.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem326), err)
    }
    p.Success = append(p.Success, _elem326)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTableNamesByNamespace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Desc: table descriptor for table
//  - SplitKeys: rray of split keys for the initial regions of the table
type THBaseServiceCreateTableArgs struct {
  Desc *TTableDescriptor `thrift:"desc,1,required" db:"desc" json:"desc"`
  SplitKeys [][]byte `thrift:"splitKeys,2" db:"splitKeys" json:"splitKeys"`
}

func NewTHBaseServiceCreateTableArgs() *THBaseServiceCreateTableArgs {
  return &THBaseServiceCreateTableArgs{}
}

var THBaseServiceCreateTableArgs_Desc_DEFAULT *TTableDescriptor
func (p *THBaseServiceCreateTableArgs) GetDesc() *TTableDescriptor {
  if !p.IsSetDesc() {
    return THBaseServiceCreateTableArgs_Desc_DEFAULT
  }
return p.Desc
}

func (p *THBaseServiceCreateTableArgs) GetSplitKeys() [][]byte {
  return p.SplitKeys
}
func (p *THBaseServiceCreateTableArgs) IsSetDesc() bool {
  return p.Desc != nil
}

func (p *THBaseServiceCreateTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetDesc bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetDesc = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetDesc{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"));
  }
  return nil
}

func (p *THBaseServiceCreateTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Desc = &TTableDescriptor{}
  if err := p.Desc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
  }
  return nil
}

func (p *THBaseServiceCreateTableArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.SplitKeys =  tSlice
  for i := 0; i < size; i ++ {
var _elem327 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem327 = v
}
    p.SplitKeys = append(p.SplitKeys, _elem327)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceCreateTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCreateTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "desc", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err) }
  if err := p.Desc.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err) }
  return err
}

func (p *THBaseServiceCreateTableArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "splitKeys", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SplitKeys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SplitKeys {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err) }
  return err
}

func (p *THBaseServiceCreateTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCreateTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceCreateTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCreateTableResult() *THBaseServiceCreateTableResult {
  return &THBaseServiceCreateTableResult{}
}

var THBaseServiceCreateTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCreateTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCreateTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceCreateTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCreateTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCreateTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCreateTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCreateTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCreateTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCreateTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to delete
type THBaseServiceDeleteTableArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceDeleteTableArgs() *THBaseServiceDeleteTableArgs {
  return &THBaseServiceDeleteTableArgs{}
}

var THBaseServiceDeleteTableArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceDeleteTableArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceDeleteTableArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceDeleteTableArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceDeleteTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceDeleteTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceDeleteTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteTableResult() *THBaseServiceDeleteTableResult {
  return &THBaseServiceDeleteTableResult{}
}

var THBaseServiceDeleteTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDeleteTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDeleteTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDeleteTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDeleteTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDeleteTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDeleteTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to truncate
//  - PreserveSplits: whether to  preserve previous splits
type THBaseServiceTruncateTableArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  PreserveSplits bool `thrift:"preserveSplits,2,required" db:"preserveSplits" json:"preserveSplits"`
}

func NewTHBaseServiceTruncateTableArgs() *THBaseServiceTruncateTableArgs {
  return &THBaseServiceTruncateTableArgs{}
}

var THBaseServiceTruncateTableArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceTruncateTableArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceTruncateTableArgs_TableName_DEFAULT
  }
return p.TableName
}

func (p *THBaseServiceTruncateTableArgs) GetPreserveSplits() bool {
  return p.PreserveSplits
}
func (p *THBaseServiceTruncateTableArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceTruncateTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;
  var issetPreserveSplits bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetPreserveSplits = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  if !issetPreserveSplits{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PreserveSplits is not set"));
  }
  return nil
}

func (p *THBaseServiceTruncateTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceTruncateTableArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PreserveSplits = v
}
  return nil
}

func (p *THBaseServiceTruncateTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "truncateTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceTruncateTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceTruncateTableArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "preserveSplits", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:preserveSplits: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.PreserveSplits)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.preserveSplits (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:preserveSplits: ", p), err) }
  return err
}

func (p *THBaseServiceTruncateTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceTruncateTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceTruncateTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceTruncateTableResult() *THBaseServiceTruncateTableResult {
  return &THBaseServiceTruncateTableResult{}
}

var THBaseServiceTruncateTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceTruncateTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceTruncateTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceTruncateTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceTruncateTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceTruncateTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceTruncateTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "truncateTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceTruncateTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceTruncateTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceTruncateTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to enable
type THBaseServiceEnableTableArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceEnableTableArgs() *THBaseServiceEnableTableArgs {
  return &THBaseServiceEnableTableArgs{}
}

var THBaseServiceEnableTableArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceEnableTableArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceEnableTableArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceEnableTableArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceEnableTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceEnableTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceEnableTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enableTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceEnableTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceEnableTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceEnableTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceEnableTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceEnableTableResult() *THBaseServiceEnableTableResult {
  return &THBaseServiceEnableTableResult{}
}

var THBaseServiceEnableTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceEnableTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceEnableTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceEnableTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceEnableTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceEnableTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceEnableTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enableTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceEnableTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceEnableTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceEnableTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to disable
type THBaseServiceDisableTableArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceDisableTableArgs() *THBaseServiceDisableTableArgs {
  return &THBaseServiceDisableTableArgs{}
}

var THBaseServiceDisableTableArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceDisableTableArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceDisableTableArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceDisableTableArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceDisableTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceDisableTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceDisableTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "disableTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDisableTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceDisableTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDisableTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDisableTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDisableTableResult() *THBaseServiceDisableTableResult {
  return &THBaseServiceDisableTableResult{}
}

var THBaseServiceDisableTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDisableTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDisableTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDisableTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDisableTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDisableTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDisableTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "disableTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDisableTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDisableTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDisableTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableEnabledArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableEnabledArgs() *THBaseServiceIsTableEnabledArgs {
  return &THBaseServiceIsTableEnabledArgs{}
}

var THBaseServiceIsTableEnabledArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceIsTableEnabledArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceIsTableEnabledArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceIsTableEnabledArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceIsTableEnabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceIsTableEnabledArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceIsTableEnabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableEnabled_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableEnabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceIsTableEnabledArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableEnabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableEnabledResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableEnabledResult() *THBaseServiceIsTableEnabledResult {
  return &THBaseServiceIsTableEnabledResult{}
}

var THBaseServiceIsTableEnabledResult_Success_DEFAULT bool
func (p *THBaseServiceIsTableEnabledResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceIsTableEnabledResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceIsTableEnabledResult_Io_DEFAULT *TIOError
func (p *THBaseServiceIsTableEnabledResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceIsTableEnabledResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceIsTableEnabledResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceIsTableEnabledResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceIsTableEnabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceIsTableEnabledResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceIsTableEnabledResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceIsTableEnabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableEnabled_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableEnabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableEnabledResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableEnabledResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableEnabledResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableDisabledArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableDisabledArgs() *THBaseServiceIsTableDisabledArgs {
  return &THBaseServiceIsTableDisabledArgs{}
}

var THBaseServiceIsTableDisabledArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceIsTableDisabledArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceIsTableDisabledArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceIsTableDisabledArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceIsTableDisabledArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceIsTableDisabledArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceIsTableDisabledArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableDisabled_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableDisabledArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceIsTableDisabledArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableDisabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableDisabledResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableDisabledResult() *THBaseServiceIsTableDisabledResult {
  return &THBaseServiceIsTableDisabledResult{}
}

var THBaseServiceIsTableDisabledResult_Success_DEFAULT bool
func (p *THBaseServiceIsTableDisabledResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceIsTableDisabledResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceIsTableDisabledResult_Io_DEFAULT *TIOError
func (p *THBaseServiceIsTableDisabledResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceIsTableDisabledResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceIsTableDisabledResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceIsTableDisabledResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceIsTableDisabledResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceIsTableDisabledResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceIsTableDisabledResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceIsTableDisabledResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableDisabled_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableDisabledResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableDisabledResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableDisabledResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableDisabledResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableAvailableArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
}

func NewTHBaseServiceIsTableAvailableArgs() *THBaseServiceIsTableAvailableArgs {
  return &THBaseServiceIsTableAvailableArgs{}
}

var THBaseServiceIsTableAvailableArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceIsTableAvailableArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceIsTableAvailableArgs_TableName_DEFAULT
  }
return p.TableName
}
func (p *THBaseServiceIsTableAvailableArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableAvailable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableAvailableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceIsTableAvailableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableAvailableArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableAvailableResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableResult() *THBaseServiceIsTableAvailableResult {
  return &THBaseServiceIsTableAvailableResult{}
}

var THBaseServiceIsTableAvailableResult_Success_DEFAULT bool
func (p *THBaseServiceIsTableAvailableResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceIsTableAvailableResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceIsTableAvailableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceIsTableAvailableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceIsTableAvailableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceIsTableAvailableResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceIsTableAvailableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableAvailable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableAvailableResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableAvailableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableAvailableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableAvailableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
//  - SplitKeys: keys to check if the table has been created with all split keys
type THBaseServiceIsTableAvailableWithSplitArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  SplitKeys [][]byte `thrift:"splitKeys,2" db:"splitKeys" json:"splitKeys"`
}

func NewTHBaseServiceIsTableAvailableWithSplitArgs() *THBaseServiceIsTableAvailableWithSplitArgs {
  return &THBaseServiceIsTableAvailableWithSplitArgs{}
}

var THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT
  }
return p.TableName
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetSplitKeys() [][]byte {
  return p.SplitKeys
}
func (p *THBaseServiceIsTableAvailableWithSplitArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.SplitKeys =  tSlice
  for i := 0; i < size; i ++ {
var _elem328 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem328 = v
}
    p.SplitKeys = append(p.SplitKeys, _elem328)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableAvailableWithSplit_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "splitKeys", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SplitKeys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SplitKeys {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err) }
  return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableAvailableWithSplitResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableWithSplitResult() *THBaseServiceIsTableAvailableWithSplitResult {
  return &THBaseServiceIsTableAvailableWithSplitResult{}
}

var THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT bool
func (p *THBaseServiceIsTableAvailableWithSplitResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT
  }
return *p.Success
}
var THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT *TIOError
func (p *THBaseServiceIsTableAvailableWithSplitResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "isTableAvailableWithSplit_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to add column family to
//  - Column: column family descriptor of column family to be added
type THBaseServiceAddColumnFamilyArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  Column *TColumnFamilyDescriptor `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceAddColumnFamilyArgs() *THBaseServiceAddColumnFamilyArgs {
  return &THBaseServiceAddColumnFamilyArgs{}
}

var THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceAddColumnFamilyArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT
  }
return p.TableName
}
var THBaseServiceAddColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor
func (p *THBaseServiceAddColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
  if !p.IsSetColumn() {
    return THBaseServiceAddColumnFamilyArgs_Column_DEFAULT
  }
return p.Column
}
func (p *THBaseServiceAddColumnFamilyArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) IsSetColumn() bool {
  return p.Column != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;
  var issetColumn bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumn = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  if !issetColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"));
  }
  return nil
}

func (p *THBaseServiceAddColumnFamilyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceAddColumnFamilyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Column = &TColumnFamilyDescriptor{}
  if err := p.Column.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
  }
  return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "addColumnFamily_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err) }
  if err := p.Column.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err) }
  return err
}

func (p *THBaseServiceAddColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceAddColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceAddColumnFamilyResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceAddColumnFamilyResult() *THBaseServiceAddColumnFamilyResult {
  return &THBaseServiceAddColumnFamilyResult{}
}

var THBaseServiceAddColumnFamilyResult_Io_DEFAULT *TIOError
func (p *THBaseServiceAddColumnFamilyResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceAddColumnFamilyResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceAddColumnFamilyResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceAddColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceAddColumnFamilyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceAddColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "addColumnFamily_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceAddColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceAddColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceAddColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to delete column family from
//  - Column: name of column family to be deleted
type THBaseServiceDeleteColumnFamilyArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  Column []byte `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceDeleteColumnFamilyArgs() *THBaseServiceDeleteColumnFamilyArgs {
  return &THBaseServiceDeleteColumnFamilyArgs{}
}

var THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceDeleteColumnFamilyArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT
  }
return p.TableName
}

func (p *THBaseServiceDeleteColumnFamilyArgs) GetColumn() []byte {
  return p.Column
}
func (p *THBaseServiceDeleteColumnFamilyArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;
  var issetColumn bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumn = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  if !issetColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"));
  }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Column = v
}
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteColumnFamily_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Column); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteColumnFamilyResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteColumnFamilyResult() *THBaseServiceDeleteColumnFamilyResult {
  return &THBaseServiceDeleteColumnFamilyResult{}
}

var THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDeleteColumnFamilyResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDeleteColumnFamilyResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteColumnFamily_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to modify column family
//  - Column: column family descriptor of column family to be modified
type THBaseServiceModifyColumnFamilyArgs struct {
  TableName *TTableName `thrift:"tableName,1,required" db:"tableName" json:"tableName"`
  Column *TColumnFamilyDescriptor `thrift:"column,2,required" db:"column" json:"column"`
}

func NewTHBaseServiceModifyColumnFamilyArgs() *THBaseServiceModifyColumnFamilyArgs {
  return &THBaseServiceModifyColumnFamilyArgs{}
}

var THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT *TTableName
func (p *THBaseServiceModifyColumnFamilyArgs) GetTableName() *TTableName {
  if !p.IsSetTableName() {
    return THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT
  }
return p.TableName
}
var THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor
func (p *THBaseServiceModifyColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
  if !p.IsSetColumn() {
    return THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT
  }
return p.Column
}
func (p *THBaseServiceModifyColumnFamilyArgs) IsSetTableName() bool {
  return p.TableName != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) IsSetColumn() bool {
  return p.Column != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTableName bool = false;
  var issetColumn bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTableName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetColumn = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTableName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"));
  }
  if !issetColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"));
  }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TableName = &TTableName{}
  if err := p.TableName.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
  }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Column = &TColumnFamilyDescriptor{}
  if err := p.Column.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
  }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyColumnFamily_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tableName", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err) }
  if err := p.TableName.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err) }
  return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "column", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err) }
  if err := p.Column.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err) }
  return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyColumnFamilyResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyColumnFamilyResult() *THBaseServiceModifyColumnFamilyResult {
  return &THBaseServiceModifyColumnFamilyResult{}
}

var THBaseServiceModifyColumnFamilyResult_Io_DEFAULT *TIOError
func (p *THBaseServiceModifyColumnFamilyResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceModifyColumnFamilyResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceModifyColumnFamilyResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyColumnFamily_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceModifyColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - Desc: the descriptor of the table to modify
type THBaseServiceModifyTableArgs struct {
  Desc *TTableDescriptor `thrift:"desc,1,required" db:"desc" json:"desc"`
}

func NewTHBaseServiceModifyTableArgs() *THBaseServiceModifyTableArgs {
  return &THBaseServiceModifyTableArgs{}
}

var THBaseServiceModifyTableArgs_Desc_DEFAULT *TTableDescriptor
func (p *THBaseServiceModifyTableArgs) GetDesc() *TTableDescriptor {
  if !p.IsSetDesc() {
    return THBaseServiceModifyTableArgs_Desc_DEFAULT
  }
return p.Desc
}
func (p *THBaseServiceModifyTableArgs) IsSetDesc() bool {
  return p.Desc != nil
}

func (p *THBaseServiceModifyTableArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetDesc bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetDesc = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetDesc{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"));
  }
  return nil
}

func (p *THBaseServiceModifyTableArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Desc = &TTableDescriptor{}
  if err := p.Desc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
  }
  return nil
}

func (p *THBaseServiceModifyTableArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyTable_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyTableArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "desc", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err) }
  if err := p.Desc.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err) }
  return err
}

func (p *THBaseServiceModifyTableArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyTableResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyTableResult() *THBaseServiceModifyTableResult {
  return &THBaseServiceModifyTableResult{}
}

var THBaseServiceModifyTableResult_Io_DEFAULT *TIOError
func (p *THBaseServiceModifyTableResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceModifyTableResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceModifyTableResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceModifyTableResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceModifyTableResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceModifyTableResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyTable_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyTableResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceModifyTableResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyTableResult(%+v)", *p)
}

// Attributes:
//  - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceCreateNamespaceArgs struct {
  NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" db:"namespaceDesc" json:"namespaceDesc"`
}

func NewTHBaseServiceCreateNamespaceArgs() *THBaseServiceCreateNamespaceArgs {
  return &THBaseServiceCreateNamespaceArgs{}
}

var THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor
func (p *THBaseServiceCreateNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
  if !p.IsSetNamespaceDesc() {
    return THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT
  }
return p.NamespaceDesc
}
func (p *THBaseServiceCreateNamespaceArgs) IsSetNamespaceDesc() bool {
  return p.NamespaceDesc != nil
}

func (p *THBaseServiceCreateNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetNamespaceDesc bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetNamespaceDesc = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetNamespaceDesc{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"));
  }
  return nil
}

func (p *THBaseServiceCreateNamespaceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.NamespaceDesc = &TNamespaceDescriptor{}
  if err := p.NamespaceDesc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
  }
  return nil
}

func (p *THBaseServiceCreateNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNamespace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCreateNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "namespaceDesc", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err) }
  if err := p.NamespaceDesc.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err) }
  return err
}

func (p *THBaseServiceCreateNamespaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCreateNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceCreateNamespaceResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceCreateNamespaceResult() *THBaseServiceCreateNamespaceResult {
  return &THBaseServiceCreateNamespaceResult{}
}

var THBaseServiceCreateNamespaceResult_Io_DEFAULT *TIOError
func (p *THBaseServiceCreateNamespaceResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceCreateNamespaceResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceCreateNamespaceResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceCreateNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceCreateNamespaceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceCreateNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNamespace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceCreateNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceCreateNamespaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceCreateNamespaceResult(%+v)", *p)
}

// Attributes:
//  - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceModifyNamespaceArgs struct {
  NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" db:"namespaceDesc" json:"namespaceDesc"`
}

func NewTHBaseServiceModifyNamespaceArgs() *THBaseServiceModifyNamespaceArgs {
  return &THBaseServiceModifyNamespaceArgs{}
}

var THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor
func (p *THBaseServiceModifyNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
  if !p.IsSetNamespaceDesc() {
    return THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT
  }
return p.NamespaceDesc
}
func (p *THBaseServiceModifyNamespaceArgs) IsSetNamespaceDesc() bool {
  return p.NamespaceDesc != nil
}

func (p *THBaseServiceModifyNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetNamespaceDesc bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetNamespaceDesc = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetNamespaceDesc{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"));
  }
  return nil
}

func (p *THBaseServiceModifyNamespaceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.NamespaceDesc = &TNamespaceDescriptor{}
  if err := p.NamespaceDesc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
  }
  return nil
}

func (p *THBaseServiceModifyNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyNamespace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "namespaceDesc", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err) }
  if err := p.NamespaceDesc.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err) }
  return err
}

func (p *THBaseServiceModifyNamespaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyNamespaceResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceModifyNamespaceResult() *THBaseServiceModifyNamespaceResult {
  return &THBaseServiceModifyNamespaceResult{}
}

var THBaseServiceModifyNamespaceResult_Io_DEFAULT *TIOError
func (p *THBaseServiceModifyNamespaceResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceModifyNamespaceResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceModifyNamespaceResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceModifyNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceModifyNamespaceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceModifyNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "modifyNamespace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceModifyNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceModifyNamespaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceModifyNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Name: namespace name
type THBaseServiceDeleteNamespaceArgs struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceDeleteNamespaceArgs() *THBaseServiceDeleteNamespaceArgs {
  return &THBaseServiceDeleteNamespaceArgs{}
}


func (p *THBaseServiceDeleteNamespaceArgs) GetName() string {
  return p.Name
}
func (p *THBaseServiceDeleteNamespaceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *THBaseServiceDeleteNamespaceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteNamespace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *THBaseServiceDeleteNamespaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteNamespaceResult struct {
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteNamespaceResult() *THBaseServiceDeleteNamespaceResult {
  return &THBaseServiceDeleteNamespaceResult{}
}

var THBaseServiceDeleteNamespaceResult_Io_DEFAULT *TIOError
func (p *THBaseServiceDeleteNamespaceResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceDeleteNamespaceResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceDeleteNamespaceResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceDeleteNamespaceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceDeleteNamespaceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceDeleteNamespaceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteNamespace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceDeleteNamespaceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceDeleteNamespaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceDeleteNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Name: name of namespace descriptor
type THBaseServiceGetNamespaceDescriptorArgs struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewTHBaseServiceGetNamespaceDescriptorArgs() *THBaseServiceGetNamespaceDescriptorArgs {
  return &THBaseServiceGetNamespaceDescriptorArgs{}
}


func (p *THBaseServiceGetNamespaceDescriptorArgs) GetName() string {
  return p.Name
}
func (p *THBaseServiceGetNamespaceDescriptorArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNamespaceDescriptor_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetNamespaceDescriptorResult struct {
  Success *TNamespaceDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetNamespaceDescriptorResult() *THBaseServiceGetNamespaceDescriptorResult {
  return &THBaseServiceGetNamespaceDescriptorResult{}
}

var THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT *TNamespaceDescriptor
func (p *THBaseServiceGetNamespaceDescriptorResult) GetSuccess() *TNamespaceDescriptor {
  if !p.IsSetSuccess() {
    return THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT
  }
return p.Success
}
var THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetNamespaceDescriptorResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &TNamespaceDescriptor{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNamespaceDescriptor_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorResult(%+v)", *p)
}

type THBaseServiceListNamespaceDescriptorsArgs struct {
}

func NewTHBaseServiceListNamespaceDescriptorsArgs() *THBaseServiceListNamespaceDescriptorsArgs {
  return &THBaseServiceListNamespaceDescriptorsArgs{}
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNamespaceDescriptors_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceListNamespaceDescriptorsResult struct {
  Success []*TNamespaceDescriptor `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceListNamespaceDescriptorsResult() *THBaseServiceListNamespaceDescriptorsResult {
  return &THBaseServiceListNamespaceDescriptorsResult{}
}

var THBaseServiceListNamespaceDescriptorsResult_Success_DEFAULT []*TNamespaceDescriptor

func (p *THBaseServiceListNamespaceDescriptorsResult) GetSuccess() []*TNamespaceDescriptor {
  return p.Success
}
var THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT *TIOError
func (p *THBaseServiceListNamespaceDescriptorsResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TNamespaceDescriptor, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem329 := &TNamespaceDescriptor{}
    if err := _elem329.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem329), err)
    }
    p.Success = append(p.Success, _elem329)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNamespaceDescriptors_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsResult(%+v)", *p)
}

type THBaseServiceListNamespacesArgs struct {
}

func NewTHBaseServiceListNamespacesArgs() *THBaseServiceListNamespacesArgs {
  return &THBaseServiceListNamespacesArgs{}
}

func (p *THBaseServiceListNamespacesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceListNamespacesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNamespaces_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceListNamespacesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceListNamespacesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceListNamespacesResult struct {
  Success []string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceListNamespacesResult() *THBaseServiceListNamespacesResult {
  return &THBaseServiceListNamespacesResult{}
}

var THBaseServiceListNamespacesResult_Success_DEFAULT []string

func (p *THBaseServiceListNamespacesResult) GetSuccess() []string {
  return p.Success
}
var THBaseServiceListNamespacesResult_Io_DEFAULT *TIOError
func (p *THBaseServiceListNamespacesResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceListNamespacesResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceListNamespacesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceListNamespacesResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceListNamespacesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceListNamespacesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem330 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem330 = v
}
    p.Success = append(p.Success, _elem330)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceListNamespacesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceListNamespacesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNamespaces_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceListNamespacesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceListNamespacesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceListNamespacesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceListNamespacesResult(%+v)", *p)
}

type THBaseServiceGetThriftServerTypeArgs struct {
}

func NewTHBaseServiceGetThriftServerTypeArgs() *THBaseServiceGetThriftServerTypeArgs {
  return &THBaseServiceGetThriftServerTypeArgs{}
}

func (p *THBaseServiceGetThriftServerTypeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetThriftServerTypeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getThriftServerType_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetThriftServerTypeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetThriftServerTypeArgs(%+v)", *p)
}

// Attributes:
//  - Success
type THBaseServiceGetThriftServerTypeResult struct {
  Success *TThriftServerType `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTHBaseServiceGetThriftServerTypeResult() *THBaseServiceGetThriftServerTypeResult {
  return &THBaseServiceGetThriftServerTypeResult{}
}

var THBaseServiceGetThriftServerTypeResult_Success_DEFAULT TThriftServerType
func (p *THBaseServiceGetThriftServerTypeResult) GetSuccess() TThriftServerType {
  if !p.IsSetSuccess() {
    return THBaseServiceGetThriftServerTypeResult_Success_DEFAULT
  }
return *p.Success
}
func (p *THBaseServiceGetThriftServerTypeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetThriftServerTypeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetThriftServerTypeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := TThriftServerType(v)
  p.Success = &temp
}
  return nil
}

func (p *THBaseServiceGetThriftServerTypeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getThriftServerType_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetThriftServerTypeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetThriftServerTypeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetThriftServerTypeResult(%+v)", *p)
}

// Attributes:
//  - ServerNames: @param serverNames Server names to get slowlog responses from
//  - LogQueryFilter: @param logQueryFilter filter to be used if provided
type THBaseServiceGetSlowLogResponsesArgs struct {
  ServerNames []*TServerName `thrift:"serverNames,1" db:"serverNames" json:"serverNames"`
  LogQueryFilter *TLogQueryFilter `thrift:"logQueryFilter,2" db:"logQueryFilter" json:"logQueryFilter"`
}

func NewTHBaseServiceGetSlowLogResponsesArgs() *THBaseServiceGetSlowLogResponsesArgs {
  return &THBaseServiceGetSlowLogResponsesArgs{}
}


func (p *THBaseServiceGetSlowLogResponsesArgs) GetServerNames() []*TServerName {
  return p.ServerNames
}
var THBaseServiceGetSlowLogResponsesArgs_LogQueryFilter_DEFAULT *TLogQueryFilter
func (p *THBaseServiceGetSlowLogResponsesArgs) GetLogQueryFilter() *TLogQueryFilter {
  if !p.IsSetLogQueryFilter() {
    return THBaseServiceGetSlowLogResponsesArgs_LogQueryFilter_DEFAULT
  }
return p.LogQueryFilter
}
func (p *THBaseServiceGetSlowLogResponsesArgs) IsSetLogQueryFilter() bool {
  return p.LogQueryFilter != nil
}

func (p *THBaseServiceGetSlowLogResponsesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*TServerName, 0, size)
  p.ServerNames =  tSet
  for i := 0; i < size; i ++ {
    _elem331 := &TServerName{}
    if err := _elem331.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem331), err)
    }
    p.ServerNames = append(p.ServerNames, _elem331)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LogQueryFilter = &TLogQueryFilter{
  Limit: 10,

  LogType: 1,

  FilterByOperator: 1,
}
  if err := p.LogQueryFilter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LogQueryFilter), err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSlowLogResponses_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serverNames", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverNames: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.ServerNames)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.ServerNames); i++ {
    for j := i+1; j<len(p.ServerNames); j++ {
      if func(tgt, src *TServerName) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.ServerNames[i], p.ServerNames[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.ServerNames))
      }
    }
  }
  for _, v := range p.ServerNames {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverNames: ", p), err) }
  return err
}

func (p *THBaseServiceGetSlowLogResponsesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "logQueryFilter", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:logQueryFilter: ", p), err) }
  if err := p.LogQueryFilter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LogQueryFilter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:logQueryFilter: ", p), err) }
  return err
}

func (p *THBaseServiceGetSlowLogResponsesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetSlowLogResponsesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetSlowLogResponsesResult struct {
  Success []*TOnlineLogRecord `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceGetSlowLogResponsesResult() *THBaseServiceGetSlowLogResponsesResult {
  return &THBaseServiceGetSlowLogResponsesResult{}
}

var THBaseServiceGetSlowLogResponsesResult_Success_DEFAULT []*TOnlineLogRecord

func (p *THBaseServiceGetSlowLogResponsesResult) GetSuccess() []*TOnlineLogRecord {
  return p.Success
}
var THBaseServiceGetSlowLogResponsesResult_Io_DEFAULT *TIOError
func (p *THBaseServiceGetSlowLogResponsesResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceGetSlowLogResponsesResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceGetSlowLogResponsesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetSlowLogResponsesResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceGetSlowLogResponsesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TOnlineLogRecord, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem332 := &TOnlineLogRecord{}
    if err := _elem332.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem332), err)
    }
    p.Success = append(p.Success, _elem332)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSlowLogResponses_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetSlowLogResponsesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetSlowLogResponsesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetSlowLogResponsesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetSlowLogResponsesResult(%+v)", *p)
}

// Attributes:
//  - ServerNames: @param serverNames Set of Server names to clean slowlog responses from
type THBaseServiceClearSlowLogResponsesArgs struct {
  ServerNames []*TServerName `thrift:"serverNames,1" db:"serverNames" json:"serverNames"`
}

func NewTHBaseServiceClearSlowLogResponsesArgs() *THBaseServiceClearSlowLogResponsesArgs {
  return &THBaseServiceClearSlowLogResponsesArgs{}
}


func (p *THBaseServiceClearSlowLogResponsesArgs) GetServerNames() []*TServerName {
  return p.ServerNames
}
func (p *THBaseServiceClearSlowLogResponsesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*TServerName, 0, size)
  p.ServerNames =  tSet
  for i := 0; i < size; i ++ {
    _elem333 := &TServerName{}
    if err := _elem333.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem333), err)
    }
    p.ServerNames = append(p.ServerNames, _elem333)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "clearSlowLogResponses_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serverNames", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serverNames: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.ServerNames)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.ServerNames); i++ {
    for j := i+1; j<len(p.ServerNames); j++ {
      if func(tgt, src *TServerName) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.ServerNames[i], p.ServerNames[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.ServerNames))
      }
    }
  }
  for _, v := range p.ServerNames {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serverNames: ", p), err) }
  return err
}

func (p *THBaseServiceClearSlowLogResponsesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceClearSlowLogResponsesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceClearSlowLogResponsesResult struct {
  Success []bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Io *TIOError `thrift:"io,1" db:"io" json:"io,omitempty"`
}

func NewTHBaseServiceClearSlowLogResponsesResult() *THBaseServiceClearSlowLogResponsesResult {
  return &THBaseServiceClearSlowLogResponsesResult{}
}

var THBaseServiceClearSlowLogResponsesResult_Success_DEFAULT []bool

func (p *THBaseServiceClearSlowLogResponsesResult) GetSuccess() []bool {
  return p.Success
}
var THBaseServiceClearSlowLogResponsesResult_Io_DEFAULT *TIOError
func (p *THBaseServiceClearSlowLogResponsesResult) GetIo() *TIOError {
  if !p.IsSetIo() {
    return THBaseServiceClearSlowLogResponsesResult_Io_DEFAULT
  }
return p.Io
}
func (p *THBaseServiceClearSlowLogResponsesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceClearSlowLogResponsesResult) IsSetIo() bool {
  return p.Io != nil
}

func (p *THBaseServiceClearSlowLogResponsesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]bool, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem334 bool
    if v, err := iprot.ReadBool(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem334 = v
}
    p.Success = append(p.Success, _elem334)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Io = &TIOError{}
  if err := p.Io.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
  }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "clearSlowLogResponses_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceClearSlowLogResponsesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.BOOL, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBool(ctx, bool(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceClearSlowLogResponsesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIo() {
    if err := oprot.WriteFieldBegin(ctx, "io", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err) }
    if err := p.Io.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err) }
  }
  return err
}

func (p *THBaseServiceClearSlowLogResponsesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceClearSlowLogResponsesResult(%+v)", *p)
}

type THBaseServiceGetClusterIdArgs struct {
}

func NewTHBaseServiceGetClusterIdArgs() *THBaseServiceGetClusterIdArgs {
  return &THBaseServiceGetClusterIdArgs{}
}

func (p *THBaseServiceGetClusterIdArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetClusterIdArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getClusterId_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetClusterIdArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetClusterIdArgs(%+v)", *p)
}

// Attributes:
//  - Success
type THBaseServiceGetClusterIdResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewTHBaseServiceGetClusterIdResult() *THBaseServiceGetClusterIdResult {
  return &THBaseServiceGetClusterIdResult{}
}

var THBaseServiceGetClusterIdResult_Success_DEFAULT string
func (p *THBaseServiceGetClusterIdResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return THBaseServiceGetClusterIdResult_Success_DEFAULT
  }
return *p.Success
}
func (p *THBaseServiceGetClusterIdResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *THBaseServiceGetClusterIdResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *THBaseServiceGetClusterIdResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *THBaseServiceGetClusterIdResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getClusterId_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *THBaseServiceGetClusterIdResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *THBaseServiceGetClusterIdResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("THBaseServiceGetClusterIdResult(%+v)", *p)
}


